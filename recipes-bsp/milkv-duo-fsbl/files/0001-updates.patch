From 63c154ecfd1f7b53e4db1265d6fade6083911573 Mon Sep 17 00:00:00 2001
From: root <root@test.lan>
Date: Fri, 16 Aug 2024 11:02:07 +0000
Subject: [PATCH] updates

changes taken from upstream [https://github.com/milkv-duo/duo-buildroot-sdk/tree/46c7636d]

Upstream-Status: Submitted [https://github.com/milkv-duo/milkv-duo-buildroot-libraries/pull/1]
---
 firmware/Makefile                             |    10 -
 firmware/README.rst                           |    13 +-
 firmware/lib/cpu/riscv/bl2_entrypoint.S       |     4 -
 firmware/lib/cpu/riscv/cpu.mk                 |     9 +-
 firmware/lib/lzma/lzma.c                      |     0
 firmware/plat/cv180x/bl2/bl2_main.c           |    26 +
 firmware/plat/cv180x/bl2/bl2_opt.c            |   536 +
 firmware/plat/cv180x/chip_conf.py             |    39 +-
 .../plat/cv180x/ddr/cvx16_dram_cap_check.c    |   111 +
 firmware/plat/cv180x/ddr/cvx16_pinmux.c       |   580 +
 firmware/plat/cv180x/ddr/ddr.c                |    20 +
 firmware/plat/cv180x/ddr/ddr.mk               |   107 +
 .../ddr_config/ddr2_1333_x16/ddr_patch_regs.c |   114 +
 .../ddr/ddr_config/ddr2_1333_x16/ddrc_init.c  |   385 +
 .../ddr/ddr_config/ddr2_1333_x16/phy_init.c   |   271 +
 .../ddr_config/ddr3_1866_x16/ddr_patch_regs.c |   110 +
 .../ddr/ddr_config/ddr3_1866_x16/ddrc_init.c  |   343 +
 .../ddr/ddr_config/ddr3_1866_x16/phy_init.c   |   271 +
 .../ddr_config/ddr3_2133_x16/ddr_patch_regs.c |   108 +
 .../ddr/ddr_config/ddr3_2133_x16/ddrc_init.c  |   350 +
 .../ddr/ddr_config/ddr3_2133_x16/phy_init.c   |   271 +
 .../ddr_config/ddr_auto_x16/ddr_patch_regs.c  |   218 +
 .../ddr/ddr_config/ddr_auto_x16/ddrc_init.c   |   720 +
 .../ddr/ddr_config/ddr_auto_x16/phy_init.c    |   280 +
 firmware/plat/cv180x/ddr/ddr_pkg_info.c       |   161 +
 firmware/plat/cv180x/ddr/ddr_sys.c            | 10834 ++++++++++++++++
 firmware/plat/cv180x/ddr/ddr_sys_bring_up.c   |   493 +
 firmware/plat/cv180x/ddr/phy_pll_init.c       |    40 +
 firmware/plat/cv180x/fipsign.py               |   253 +-
 firmware/plat/cv180x/fiptool.py               |   803 +-
 firmware/plat/cv180x/include/bl2.h            |    46 +-
 .../plat/cv180x/include/cvi_board_memmap.h    |    74 -
 .../ddr_config/ddr_auto_x16/ddr2_1333_init.h  |  1156 ++
 .../ddr_config/ddr_auto_x16/ddr3_1866_init.h  |  1157 ++
 .../plat/cv180x/include/ddr/ddr_pkg_info.h    |     2 +
 firmware/plat/cv180x/include/ddr/ddr_sys.h    |     1 +
 firmware/plat/cv180x/include/ddr/regconfig.h  |     8 +-
 firmware/plat/cv180x/include/rom_api.h        |    22 +-
 firmware/plat/cv180x/include/rtc.h            |    50 +-
 firmware/plat/cv180x/multi.its                |    42 -
 firmware/plat/cv180x/platform.c               |   467 +
 firmware/plat/cv180x/platform.mk              |    10 +-
 firmware/plat/cv180x/platform_device.c        |   115 +
 firmware/plat/cv180x/security                 |     1 +
 firmware/plat/cv180x/uart                     |     1 +
 firmware/plat/cv180x/usb/cps_cvi.c            |    87 +
 firmware/plat/cv180x/usb/cv_usb.c             |    29 +
 firmware/plat/cv180x/usb/dwc2_udc_otg.c       |  1146 ++
 firmware/plat/cv180x/usb/dwc2_udc_otg_phy.c   |   100 +
 .../plat/cv180x/usb/dwc2_udc_otg_xfer_dma.c   |  1691 +++
 firmware/plat/cv180x/usb/usb_tty.c            |   986 ++
 firmware/plat/cv181x/bl2/bl2_main.c           |    45 +-
 firmware/plat/cv181x/bl2/bl2_opt.c            |   431 +
 .../plat/cv181x/ddr/cvx16_dram_cap_check.c    |   111 +
 firmware/plat/cv181x/ddr/cvx16_pinmux.c       |   576 +
 firmware/plat/cv181x/ddr/ddr.c                |    20 +
 firmware/plat/cv181x/ddr/ddr.mk               |    83 +
 .../ddr_config/ddr2_1333_x16/ddr_patch_regs.c |   109 +
 .../ddr/ddr_config/ddr2_1333_x16/ddrc_init.c  |   376 +
 .../ddr/ddr_config/ddr2_1333_x16/phy_init.c   |   271 +
 .../ddr_config/ddr3_1866_x16/ddr_patch_regs.c |   108 +
 .../ddr/ddr_config/ddr3_1866_x16/ddrc_init.c  |   336 +
 .../ddr/ddr_config/ddr3_1866_x16/phy_init.c   |   271 +
 .../ddr_config/ddr3_2133_x16/ddr_patch_regs.c |   108 +
 .../ddr/ddr_config/ddr3_2133_x16/ddrc_init.c  |   337 +
 .../ddr/ddr_config/ddr3_2133_x16/phy_init.c   |   271 +
 .../ddr_config/ddr_auto_x16/ddr_patch_regs.c  |   211 +
 .../ddr/ddr_config/ddr_auto_x16/ddrc_init.c   |   706 +
 .../ddr/ddr_config/ddr_auto_x16/phy_init.c    |   281 +
 firmware/plat/cv181x/ddr/ddr_pkg_info.c       |   150 +
 firmware/plat/cv181x/ddr/ddr_sys.c            | 10731 +++++++++++++++
 firmware/plat/cv181x/ddr/ddr_sys_bring_up.c   |   547 +
 firmware/plat/cv181x/ddr/phy_pll_init.c       |    40 +
 firmware/plat/cv181x/include/platform.h       |    12 +-
 firmware/plat/cv181x/include/platform_def.h   |     2 +
 firmware/plat/cv181x/platform.c               |   540 +
 firmware/plat/cv181x/platform.mk              |    10 +-
 firmware/plat/cv181x/security/security.c      |   213 +
 .../plat/cv181x/uart/16550_console_aarch64.S  |   161 +
 firmware/plat/cv181x/uart/uart_dw.c           |   124 +
 80 files changed, 40484 insertions(+), 1368 deletions(-)
 delete mode 100644 firmware/lib/lzma/lzma.c
 create mode 100644 firmware/plat/cv180x/bl2/bl2_opt.c
 mode change 100755 => 120000 firmware/plat/cv180x/chip_conf.py
 create mode 100644 firmware/plat/cv180x/ddr/cvx16_dram_cap_check.c
 create mode 100644 firmware/plat/cv180x/ddr/cvx16_pinmux.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr.mk
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/phy_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/phy_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/phy_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/phy_init.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_pkg_info.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_sys.c
 create mode 100644 firmware/plat/cv180x/ddr/ddr_sys_bring_up.c
 create mode 100644 firmware/plat/cv180x/ddr/phy_pll_init.c
 mode change 100644 => 120000 firmware/plat/cv180x/fipsign.py
 mode change 100755 => 120000 firmware/plat/cv180x/fiptool.py
 mode change 100644 => 120000 firmware/plat/cv180x/include/bl2.h
 delete mode 100644 firmware/plat/cv180x/include/cvi_board_memmap.h
 create mode 100644 firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr2_1333_init.h
 create mode 100644 firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr3_1866_init.h
 mode change 100644 => 120000 firmware/plat/cv180x/include/rom_api.h
 mode change 100644 => 120000 firmware/plat/cv180x/include/rtc.h
 delete mode 100644 firmware/plat/cv180x/multi.its
 create mode 100644 firmware/plat/cv180x/platform.c
 create mode 100644 firmware/plat/cv180x/platform_device.c
 create mode 120000 firmware/plat/cv180x/security
 create mode 120000 firmware/plat/cv180x/uart
 create mode 100644 firmware/plat/cv180x/usb/cps_cvi.c
 create mode 100644 firmware/plat/cv180x/usb/cv_usb.c
 create mode 100644 firmware/plat/cv180x/usb/dwc2_udc_otg.c
 create mode 100644 firmware/plat/cv180x/usb/dwc2_udc_otg_phy.c
 create mode 100644 firmware/plat/cv180x/usb/dwc2_udc_otg_xfer_dma.c
 create mode 100644 firmware/plat/cv180x/usb/usb_tty.c
 create mode 100644 firmware/plat/cv181x/bl2/bl2_opt.c
 create mode 100644 firmware/plat/cv181x/ddr/cvx16_dram_cap_check.c
 create mode 100644 firmware/plat/cv181x/ddr/cvx16_pinmux.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr.mk
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/phy_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/phy_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/phy_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/phy_init.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_pkg_info.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_sys.c
 create mode 100644 firmware/plat/cv181x/ddr/ddr_sys_bring_up.c
 create mode 100644 firmware/plat/cv181x/ddr/phy_pll_init.c
 create mode 100644 firmware/plat/cv181x/platform.c
 create mode 100644 firmware/plat/cv181x/security/security.c
 create mode 100644 firmware/plat/cv181x/uart/16550_console_aarch64.S
 create mode 100644 firmware/plat/cv181x/uart/uart_dw.c

diff --git a/firmware/Makefile b/firmware/Makefile
index d0fbd76..c193060 100644
--- a/firmware/Makefile
+++ b/firmware/Makefile
@@ -31,10 +31,6 @@ ifeq (${CROSS_COMPILE},)
 $(error CROSS_COMPILE is undefined)
 endif
 
-ifeq (${FREE_RAM_SIZE},)
-$(error FREE_RAM_SIZE is undefined)
-endif
-
 ################################################################################
 # Default values for build configurations, and their dependencies
 ################################################################################
@@ -169,12 +165,6 @@ else
 $(eval $(call add_define_val,TOC_HEADER_NAME,0xAA640001))
 endif
 
-ifeq (${FREE_RAM_SIZE},64MB)
-$(eval $(call add_define_val,CVI_BUILDROOT_64MB,1))
-else
-$(eval $(call add_define_val,CVI_BUILDROOT_ION,1))
-endif
-
 ifeq (${RTOS_ENABLE_FREERTOS},y)
 $(eval $(call add_define,RTOS_ENABLE_FREERTOS))
 $(eval $(call add_define_val,RTOS_DUMP_PRINT_SZ_IDX,${RTOS_DUMP_PRINT_SZ_IDX}))
diff --git a/firmware/README.rst b/firmware/README.rst
index 980a8c5..1fee7ab 100644
--- a/firmware/README.rst
+++ b/firmware/README.rst
@@ -1,10 +1,5 @@
-============
-Milk-V Duo Firmware First Stage Bootloader
-============
+FSBL
+====
 
-This package is obtained from https://github.com/milkv-duo/duo-buildroot-sdk, from which we download the first stage bootloader source and compile it, generating the atf ``bl2.bin``. At the mean time, we will use the ``fiptool.py`` in this package to create the binary file ``fip.bin`` to pack the opensbi, u-boot and so on.
-
-If you are using Buildroot to generate the whole SD card image or the ``fip.bin``, you must say Y to this package!
-
-
-https://github.com/gtxzsxxk/milkv-duo-firmware-fsbl
+FSBL is First Stage Boot Loader.
+Act as ATF BL2.
diff --git a/firmware/lib/cpu/riscv/bl2_entrypoint.S b/firmware/lib/cpu/riscv/bl2_entrypoint.S
index 2d3c53d..7344387 100644
--- a/firmware/lib/cpu/riscv/bl2_entrypoint.S
+++ b/firmware/lib/cpu/riscv/bl2_entrypoint.S
@@ -2,10 +2,6 @@
 #include "csr.h"
 #include <riscv/asm_macros.S>
 
-#define mxstatus 0x7c0
-#define mhcr 0x7c1
-#define mcor 0x7c2
-
   .option norvc
   .section .text.init,"ax",@progbits
   .globl bl2_entrypoint
diff --git a/firmware/lib/cpu/riscv/cpu.mk b/firmware/lib/cpu/riscv/cpu.mk
index eab0360..bffa5f8 100644
--- a/firmware/lib/cpu/riscv/cpu.mk
+++ b/firmware/lib/cpu/riscv/cpu.mk
@@ -4,15 +4,16 @@ ASFLAGS +=\
 	$(CPPFLAGS) \
 	-DRISCV \
 	-D__ASSEMBLY__ \
-	-march=rv64imafdc -mstrict-align \
+	-march=rv64imafdcvxthead -mstrict-align \
 	-mcmodel=medany \
 	-mabi=lp64d \
-	-ffreestanding
+	-ffreestanding  \
+	-Wa,--fatal-warnings
 
 TF_CFLAGS += \
 	$(CPPFLAGS) \
 	-DRISCV \
-	-march=rv64imafdc \
+	-march=rv64imafdcvxthead \
 	-mcmodel=medany \
 	-mabi=lp64d \
 	-ffreestanding -fno-builtin -Wall -std=gnu99 \
@@ -20,7 +21,7 @@ TF_CFLAGS += \
 	-fno-delete-null-pointer-checks
 
 TF_LDFLAGS += \
-	 -Os \
+	--fatal-warnings -Os \
 	--gc-sections \
 	${TF_LDFLAGS_aarch64}
 
diff --git a/firmware/lib/lzma/lzma.c b/firmware/lib/lzma/lzma.c
deleted file mode 100644
index e69de29..0000000
diff --git a/firmware/plat/cv180x/bl2/bl2_main.c b/firmware/plat/cv180x/bl2/bl2_main.c
index c19ad1f..d48416d 100644
--- a/firmware/plat/cv180x/bl2/bl2_main.c
+++ b/firmware/plat/cv180x/bl2/bl2_main.c
@@ -46,8 +46,34 @@ int dec_verify_image(const void *image, size_t size, size_t dec_skip, struct fip
 }
 #endif
 
+// Start of addition
+#define UART_DLL 0x04140000
+#define UART_DLH 0x04140004
+#define UART_LCR 0x0414000C
+
+void set_baudrate()
+{
+	// 14 for 115200, 13 for 128000
+	int baud_divisor = 14;
+
+	// set DLAB to 1 to set dll and dlh
+	*(volatile uint32_t*)(UART_LCR) |= (uint32_t)0x80;
+
+	// set divisor
+	*(volatile uint32_t*)(UART_DLL) = (uint32_t)(baud_divisor & 0xff);
+	*(volatile uint32_t*)(UART_DLH) = (uint32_t)((baud_divisor >> 8) & 0xff);
+
+	// set DLAB back to 0
+	*(volatile uint32_t*)(UART_LCR) &= (uint32_t)(~0x80);
+}
+// End of addition
+
 void bl2_main(void)
 {
+	// Start of addition
+	set_baudrate();
+	// End of addition
+	
 	ATF_STATE = ATF_STATE_BL2_MAIN;
 	time_records->fsbl_start = read_time_ms();
 
diff --git a/firmware/plat/cv180x/bl2/bl2_opt.c b/firmware/plat/cv180x/bl2/bl2_opt.c
new file mode 100644
index 0000000..0e8dd50
--- /dev/null
+++ b/firmware/plat/cv180x/bl2/bl2_opt.c
@@ -0,0 +1,536 @@
+/*
+ * Copyright (c) 2013-2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <debug.h>
+#include <bitwise_ops.h>
+#include <console.h>
+#include <platform.h>
+#include <rom_api.h>
+#include <bl2.h>
+#include <ddr.h>
+#include <string.h>
+#include <decompress.h>
+#include <delay_timer.h>
+#include <security/security.h>
+#include <cv_usb.h>
+
+struct _time_records *time_records = (void *)TIME_RECORDS_ADDR;
+struct fip_param1 *fip_param1 = (void *)PARAM1_BASE;
+static struct fip_param2 fip_param2 __aligned(BLOCK_SIZE);
+static union {
+	struct ddr_param ddr_param;
+	struct loader_2nd_header loader_2nd_header;
+	uint8_t buf[BLOCK_SIZE];
+} sram_union_buf __aligned(BLOCK_SIZE);
+
+int init_comm_info(int ret) __attribute__((weak));
+int init_comm_info(int ret)
+{
+	return ret;
+}
+
+void print_sram_log(void)
+{
+	uint32_t *const log_size = (void *)BOOT_LOG_LEN_ADDR;
+	uint8_t *const log_buf = (void *)phys_to_dma(BOOT_LOG_BUF_BASE);
+	uint32_t i;
+
+	static const char m1[] = "\nSRAM Log: ========================================\n";
+	static const char m2[] = "\nSRAM Log end: ====================================\n";
+
+	for (i = 0; m1[i]; i++)
+		console_putc(m1[i]);
+
+	for (i = 0; i < *log_size; i++)
+		console_putc(log_buf[i]);
+
+	for (i = 0; m2[i]; i++)
+		console_putc(m2[i]);
+}
+
+void lock_efuse_chipsn(void)
+{
+	int value = mmio_read_32(EFUSE_W_LOCK0_REG);
+
+	if (efuse_power_on()) {
+		NOTICE("efuse power on fail\n");
+		return;
+	}
+
+	if ((value & (0x1 << BIT_FTSN3_LOCK)) == 0)
+		efuse_program_bit(0x26, BIT_FTSN3_LOCK);
+
+	if ((value & (0x1 << BIT_FTSN4_LOCK)) == 0)
+		efuse_program_bit(0x26, BIT_FTSN4_LOCK);
+
+	if (efuse_refresh_shadow()) {
+		NOTICE("efuse refresh shadow fail\n");
+		return;
+	}
+
+	value = mmio_read_32(EFUSE_W_LOCK0_REG);
+	if (((value & (0x3 << BIT_FTSN3_LOCK)) >> BIT_FTSN3_LOCK) !=  0x3)
+		NOTICE("lock efuse chipsn fail\n");
+
+	if (efuse_power_off()) {
+		NOTICE("efuse power off fail\n");
+		return;
+	}
+}
+
+#ifdef USB_DL_BY_FSBL
+int load_image_by_usb(void *buf, uint32_t offset, size_t image_size, int retry_num)
+{
+
+	int ret = -1;
+
+	if (usb_polling(buf, offset, image_size) == CV_USB_DL)
+		ret = 0;
+	else
+		ret = -2;
+
+	INFO("LIE/%d/%p/0x%x/%lu.\n", ret, buf, offset, image_size);
+
+	return ret;
+}
+#endif
+
+int load_param2(int retry)
+{
+	uint32_t crc;
+	int ret = -1;
+
+	NOTICE("P2S/0x%lx/%p.\n", sizeof(fip_param2), &fip_param2);
+
+#ifdef USB_DL_BY_FSBL
+	if (p_rom_api_get_boot_src() == BOOT_SRC_USB)
+		ret = load_image_by_usb(&fip_param2, fip_param1->param2_loadaddr, PARAM2_SIZE, retry);
+	else
+#endif
+		ret = p_rom_api_load_image(&fip_param2, fip_param1->param2_loadaddr, PARAM2_SIZE, retry);
+
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (fip_param2.magic1 != FIP_PARAM2_MAGIC1) {
+		WARN("LP2_NOMAGIC\n");
+		return -1;
+	}
+
+	crc = p_rom_api_image_crc(&fip_param2.reserved1, sizeof(fip_param2) - 12);
+	if (crc != fip_param2.param2_cksum) {
+		ERROR("param2_cksum (0x%x/0x%x)\n", crc, fip_param2.param2_cksum);
+		return -1;
+	}
+
+	NOTICE("P2E.\n");
+
+	return 0;
+}
+
+int load_ddr_param(int retry)
+{
+	uint32_t crc;
+	int ret = -1;
+
+	NOTICE("DPS/0x%x/0x%x.\n", fip_param2.ddr_param_loadaddr, fip_param2.ddr_param_size);
+
+	if (fip_param2.ddr_param_size >= sizeof(sram_union_buf.ddr_param))
+		fip_param2.ddr_param_size = sizeof(sram_union_buf.ddr_param);
+
+#ifdef USB_DL_BY_FSBL
+	if (p_rom_api_get_boot_src() == BOOT_SRC_USB)
+		ret = load_image_by_usb(&sram_union_buf.ddr_param, fip_param2.ddr_param_loadaddr,
+		fip_param2.ddr_param_size,  retry);
+	else
+#endif
+		ret = p_rom_api_load_image(&sram_union_buf.ddr_param, fip_param2.ddr_param_loadaddr,
+		fip_param2.ddr_param_size, retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	crc = p_rom_api_image_crc(&sram_union_buf.ddr_param, fip_param2.ddr_param_size);
+	if (crc != fip_param2.ddr_param_cksum) {
+		ERROR("ddr_param_cksum (0x%x/0x%x)\n", crc, fip_param2.ddr_param_cksum);
+		return -1;
+	}
+
+	NOTICE("DPE.\n");
+
+	return 0;
+}
+
+int load_ddr(void)
+{
+	int retry = 0;
+
+retry_from_flash:
+	for (retry = 0; retry < p_rom_api_get_number_of_retries(); retry++) {
+		if (load_param2(retry) < 0)
+			continue;
+		if (load_ddr_param(retry) < 0)
+			continue;
+
+		break;
+	}
+
+	if (retry >= p_rom_api_get_number_of_retries()) {
+		switch (p_rom_api_get_boot_src()) {
+		case BOOT_SRC_UART:
+		case BOOT_SRC_SD:
+		case BOOT_SRC_USB:
+			WARN("DL cancelled. Load flash. (%d).\n", retry);
+			// Continue to boot from flash if boot from external source
+			p_rom_api_flash_init();
+			goto retry_from_flash;
+		default:
+			ERROR("Failed to load DDR param (%d).\n", retry);
+			panic_handler();
+		}
+	}
+
+	time_records->ddr_init_start = read_time_ms();
+	ddr_init(&sram_union_buf.ddr_param);
+	time_records->ddr_init_end = read_time_ms();
+
+	return 0;
+}
+
+int load_blcp_2nd(int retry)
+{
+	uint32_t crc, rtos_base;
+	int ret = -1;
+
+	// if no blcp_2nd, release_blcp_2nd should be ddr_init_end
+	time_records->release_blcp_2nd = time_records->ddr_init_end;
+
+	NOTICE("C2S/0x%x/0x%x/0x%x.\n", fip_param2.blcp_2nd_loadaddr, fip_param2.blcp_2nd_runaddr,
+	       fip_param2.blcp_2nd_size);
+
+	if (!fip_param2.blcp_2nd_runaddr) {
+		NOTICE("No C906L image.\n");
+		return 0;
+	}
+
+	if (!IN_RANGE(fip_param2.blcp_2nd_runaddr, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("blcp_2nd_runaddr (0x%x) is not in DRAM.\n", fip_param2.blcp_2nd_runaddr);
+		panic_handler();
+	}
+
+	if (!IN_RANGE(fip_param2.blcp_2nd_runaddr + fip_param2.blcp_2nd_size, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("blcp_2nd_size (0x%x) is not in DRAM.\n", fip_param2.blcp_2nd_size);
+		panic_handler();
+	}
+
+#ifdef USB_DL_BY_FSBL
+	if (p_rom_api_get_boot_src() == BOOT_SRC_USB)
+		ret = load_image_by_usb((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_loadaddr,
+					fip_param2.blcp_2nd_size, retry);
+	else
+#endif
+		ret = p_rom_api_load_image((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_loadaddr,
+					fip_param2.blcp_2nd_size, retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	crc = p_rom_api_image_crc((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_size);
+	if (crc != fip_param2.blcp_2nd_cksum) {
+		ERROR("blcp_2nd_cksum (0x%x/0x%x)\n", crc, fip_param2.blcp_2nd_cksum);
+		return -1;
+	}
+
+	ret = dec_verify_image((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_size, 0, fip_param1);
+	if (ret < 0) {
+		ERROR("verify blcp 2nd (%d)\n", ret);
+		return ret;
+	}
+
+	flush_dcache_range(fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_size);
+
+	rtos_base = mmio_read_32(AXI_SRAM_RTOS_BASE);
+	init_comm_info(0);
+
+	time_records->release_blcp_2nd = read_time_ms();
+	if (rtos_base == CVI_RTOS_MAGIC_CODE) {
+		mmio_write_32(AXI_SRAM_RTOS_BASE, fip_param2.blcp_2nd_runaddr);
+	} else {
+		reset_c906l(fip_param2.blcp_2nd_runaddr);
+	}
+
+	NOTICE("C2E.\n");
+
+	return 0;
+}
+
+int load_monitor(int retry, uint64_t *monitor_entry)
+{
+	uint32_t crc;
+	int ret = -1;
+
+	NOTICE("MS/0x%x/0x%x/0x%x.\n", fip_param2.monitor_loadaddr, fip_param2.monitor_runaddr,
+	       fip_param2.monitor_size);
+
+	if (!fip_param2.monitor_runaddr) {
+		NOTICE("No monitor.\n");
+		return 0;
+	}
+
+	if (!IN_RANGE(fip_param2.monitor_runaddr, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("monitor_runaddr (0x%x) is not in DRAM.\n", fip_param2.monitor_runaddr);
+		panic_handler();
+	}
+
+	if (!IN_RANGE(fip_param2.monitor_runaddr + fip_param2.monitor_size, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("monitor_size (0x%x) is not in DRAM.\n", fip_param2.monitor_size);
+		panic_handler();
+	}
+
+#ifdef USB_DL_BY_FSBL
+	if (p_rom_api_get_boot_src() == BOOT_SRC_USB)
+		ret = load_image_by_usb((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_loadaddr,
+					fip_param2.monitor_size, retry);
+	else
+#endif
+		ret = p_rom_api_load_image((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_loadaddr,
+					fip_param2.monitor_size, retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	crc = p_rom_api_image_crc((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_size);
+	if (crc != fip_param2.monitor_cksum) {
+		ERROR("monitor_cksum (0x%x/0x%x)\n", crc, fip_param2.monitor_cksum);
+		return -1;
+	}
+
+	ret = dec_verify_image((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_size, 0, fip_param1);
+	if (ret < 0) {
+		ERROR("verify monitor (%d)\n", ret);
+		return ret;
+	}
+
+	flush_dcache_range(fip_param2.monitor_runaddr, fip_param2.monitor_size);
+	NOTICE("ME.\n");
+
+	*monitor_entry = fip_param2.monitor_runaddr;
+
+	return 0;
+}
+
+int load_loader_2nd(int retry, uint64_t *loader_2nd_entry)
+{
+	struct loader_2nd_header *loader_2nd_header = &sram_union_buf.loader_2nd_header;
+	uint32_t crc;
+	int ret = -1;
+	const int cksum_offset =
+		offsetof(struct loader_2nd_header, cksum) + sizeof(((struct loader_2nd_header *)0)->cksum);
+
+	enum COMPRESS_TYPE comp_type = COMP_NONE;
+	int reading_size;
+	void *image_buf;
+
+	NOTICE("L2/0x%x.\n", fip_param2.loader_2nd_loadaddr);
+
+#ifdef USB_DL_BY_FSBL
+	if (p_rom_api_get_boot_src() == BOOT_SRC_USB)
+		ret = load_image_by_usb(loader_2nd_header, fip_param2.loader_2nd_loadaddr, BLOCK_SIZE, retry);
+	else
+#endif
+		ret = p_rom_api_load_image(loader_2nd_header, fip_param2.loader_2nd_loadaddr, BLOCK_SIZE, retry);
+	if (ret < 0) {
+		return -1;
+	}
+
+	reading_size = ROUND_UP(loader_2nd_header->size, BLOCK_SIZE);
+
+	NOTICE("L2/0x%x/0x%x/0x%lx/0x%x/0x%x\n", loader_2nd_header->magic, loader_2nd_header->cksum,
+	       loader_2nd_header->runaddr, loader_2nd_header->size, reading_size);
+
+	switch (loader_2nd_header->magic) {
+	case LOADER_2ND_MAGIC_LZMA:
+		comp_type = COMP_LZMA;
+		break;
+	case LOADER_2ND_MAGIC_LZ4:
+		comp_type = COMP_LZ4;
+		break;
+	default:
+		comp_type = COMP_NONE;
+		break;
+	}
+
+	if (comp_type) {
+		NOTICE("COMP/%d.\n", comp_type);
+		image_buf = (void *)DECOMP_BUF_ADDR;
+	} else {
+		image_buf = (void *)loader_2nd_header->runaddr;
+	}
+
+#ifdef USB_DL_BY_FSBL
+	if (p_rom_api_get_boot_src() == BOOT_SRC_USB)
+		ret = load_image_by_usb(image_buf, fip_param2.loader_2nd_loadaddr, reading_size, retry);
+	else
+#endif
+		ret = p_rom_api_load_image(image_buf, fip_param2.loader_2nd_loadaddr, reading_size, retry);
+	if (ret < 0) {
+		return -1;
+	}
+
+	crc = p_rom_api_image_crc(image_buf + cksum_offset, loader_2nd_header->size - cksum_offset);
+	if (crc != loader_2nd_header->cksum) {
+		ERROR("loader_2nd_cksum (0x%x/0x%x)\n", crc, loader_2nd_header->cksum);
+		return -1;
+	}
+
+	ret = dec_verify_image(image_buf + cksum_offset, loader_2nd_header->size - cksum_offset,
+			       sizeof(struct loader_2nd_header) - cksum_offset, fip_param1);
+	if (ret < 0) {
+		ERROR("verify loader 2nd (%d)\n", ret);
+		return ret;
+	}
+
+	time_records->load_loader_2nd_end = read_time_ms();
+
+	sys_switch_all_to_pll();
+
+	time_records->fsbl_decomp_start = read_time_ms();
+	if (comp_type) {
+		size_t dst_size = DECOMP_DST_SIZE;
+
+		// header is not compressed.
+		void *dst = (void *)loader_2nd_header->runaddr;
+
+		memcpy(dst, image_buf, sizeof(struct loader_2nd_header));
+		image_buf += sizeof(struct loader_2nd_header);
+
+		ret = decompress(dst + sizeof(struct loader_2nd_header), &dst_size, image_buf, loader_2nd_header->size,
+				 comp_type);
+		if (ret < 0) {
+			ERROR("Failed to decompress loader_2nd (%d/%lu)\n", ret, dst_size);
+			return -1;
+		}
+
+		reading_size = dst_size;
+	}
+
+	flush_dcache_range(loader_2nd_header->runaddr, reading_size);
+	time_records->fsbl_decomp_end = read_time_ms();
+	NOTICE("Loader_2nd loaded.\n");
+
+	*loader_2nd_entry = loader_2nd_header->runaddr + sizeof(struct loader_2nd_header);
+
+	return 0;
+}
+
+int load_rest(void)
+{
+	int retry = 0;
+	uint64_t monitor_entry = 0;
+	uint64_t loader_2nd_entry = 0;
+
+	// Init sys PLL and switch clocks to PLL
+	sys_pll_init();
+
+retry_from_flash:
+	for (retry = 0; retry < p_rom_api_get_number_of_retries(); retry++) {
+		if (load_blcp_2nd(retry) < 0)
+			continue;
+
+		if (load_monitor(retry, &monitor_entry) < 0)
+			continue;
+
+		if (load_loader_2nd(retry, &loader_2nd_entry) < 0)
+			continue;
+
+		break;
+	}
+
+	if (retry >= p_rom_api_get_number_of_retries()) {
+		switch (p_rom_api_get_boot_src()) {
+		case BOOT_SRC_UART:
+		case BOOT_SRC_SD:
+		case BOOT_SRC_USB:
+			WARN("DL cancelled. Load flash. (%d).\n", retry);
+			// Continue to boot from flash if boot from external source
+			p_rom_api_flash_init();
+			goto retry_from_flash;
+		default:
+			ERROR("Failed to load rest (%d).\n", retry);
+			panic_handler();
+		}
+	}
+
+	sync_cache();
+	console_flush();
+
+	switch_rtc_mode_2nd_stage();
+
+	if (monitor_entry) {
+		NOTICE("Jump to monitor at 0x%lx.\n", monitor_entry);
+		jump_to_monitor(monitor_entry, loader_2nd_entry);
+	} else {
+		NOTICE("Jump to loader_2nd at 0x%lx.\n", loader_2nd_entry);
+		jump_to_loader_2nd(loader_2nd_entry);
+	}
+
+	return 0;
+}
+
+int load_rest_od_sel(void)
+{
+	int retry = 0;
+	uint64_t monitor_entry = 0;
+	uint64_t loader_2nd_entry = 0;
+
+	// Init sys PLL and switch clocks to PLL
+	sys_pll_init_od_sel();
+
+retry_from_flash:
+	for (retry = 0; retry < p_rom_api_get_number_of_retries(); retry++) {
+		if (load_blcp_2nd(retry) < 0)
+			continue;
+
+		if (load_monitor(retry, &monitor_entry) < 0)
+			continue;
+
+		if (load_loader_2nd(retry, &loader_2nd_entry) < 0)
+			continue;
+
+		break;
+	}
+
+	if (retry >= p_rom_api_get_number_of_retries()) {
+		switch (p_rom_api_get_boot_src()) {
+		case BOOT_SRC_UART:
+		case BOOT_SRC_SD:
+		case BOOT_SRC_USB:
+			WARN("DL cancelled. Load flash. (%d).\n", retry);
+			// Continue to boot from flash if boot from external source
+			p_rom_api_flash_init();
+			goto retry_from_flash;
+		default:
+			ERROR("Failed to load rest (%d).\n", retry);
+			panic_handler();
+		}
+	}
+
+	sync_cache();
+	console_flush();
+
+	switch_rtc_mode_2nd_stage();
+
+	if (monitor_entry) {
+		NOTICE("Jump to monitor at 0x%lx.\n", monitor_entry);
+		jump_to_monitor(monitor_entry, loader_2nd_entry);
+	} else {
+		NOTICE("Jump to loader_2nd at 0x%lx.\n", loader_2nd_entry);
+		jump_to_loader_2nd(loader_2nd_entry);
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/firmware/plat/cv180x/chip_conf.py b/firmware/plat/cv180x/chip_conf.py
deleted file mode 100755
index 2c487ed..0000000
--- a/firmware/plat/cv180x/chip_conf.py
+++ /dev/null
@@ -1,38 +0,0 @@
-#!/usr/bin/env python3
-
-import logging
-import struct
-import argparse
-
-CHIP_CONF_CMD_DELAY_MS = 0xFFFFFFFD
-CHIP_CONF_CMD_DELAY_US = 0xFFFFFFFE
-
-CHIP_CONF_SCAN_START_1 = 0xFFFFFFA0
-
-
-def gen_chip_conf(args):
-    logging.info("gen_chip_conf")
-    regs = [
-        (0x0E00000C, 0xA0000001),  # ATF_DBG_REG = 0x0E00000C
-        (0x0E00000C, 0xA0000002),
-        # (CHIP_CONF_CMD_DELAY_MS, 100),
-        # (CHIP_CONF_CMD_DELAY_US, 100),
-        (CHIP_CONF_SCAN_START_1, 0xFFFFFFFF),
-    ]
-
-    chip_conf = b"".join(struct.pack("<II", a, v) for a, v in regs)
-    logging.info("chip_conf=%d bytes", len(chip_conf))
-
-    with open(args.CHIP_CONF, "wb") as fp:
-        fp.write(chip_conf)
-
-
-def main():
-    parser = argparse.ArgumentParser(description="generate test cases")
-    parser.add_argument("CHIP_CONF", type=str)
-    args = parser.parse_args()
-    gen_chip_conf(args)
-
-
-if __name__ == "__main__":
-    main()
diff --git a/firmware/plat/cv180x/chip_conf.py b/firmware/plat/cv180x/chip_conf.py
new file mode 120000
index 0000000..3a1bf9d
--- /dev/null
+++ b/firmware/plat/cv180x/chip_conf.py
@@ -0,0 +1 @@
+../cv181x/chip_conf.py
\ No newline at end of file
diff --git a/firmware/plat/cv180x/ddr/cvx16_dram_cap_check.c b/firmware/plat/cv180x/ddr/cvx16_dram_cap_check.c
new file mode 100644
index 0000000..54881a9
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/cvx16_dram_cap_check.c
@@ -0,0 +1,111 @@
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+
+void cvx16_dram_cap_check(uint8_t size)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x5A);
+	// ddr_debug_num_write();
+	KC_MSG("-5A- %s\n", __func__);
+
+#ifdef ETRON_DDR2_512
+	KC_MSG("ETRON_DDR2_512\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif ESMT_N25_DDR3_1G
+	KC_MSG("ESMT_N25_DDR3_1G\n");
+
+	if (size == 7) {
+		KC_MSG("dram_cap_check = 1Gb (128MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif ESMT_DDR3_2G
+	KC_MSG("ESMT_DDR3_2G\n");
+
+	if (size == 8) {
+		KC_MSG("dram_cap_check = 2Gb (256MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif ETRON_DDR3_1G
+	KC_MSG("ETRON_DDR3_1G\n");
+
+	if (size == 7) {
+		KC_MSG("dram_cap_check = 1Gb (128MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_1G
+	KC_MSG("DDR3_1G\n");
+
+	if (size == 7) {
+		KC_MSG("dram_cap_check = 1Gb (128MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_2G
+	KC_MSG("DDR3_2G\n");
+
+	if (size == 8) {
+		KC_MSG("dram_cap_check = 2Gb (256MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_4G
+	KC_MSG("DDR3_4G\n");
+
+	if (size == 9) {
+		KC_MSG("dram_cap_check = 4Gb (512MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_DBG
+	KC_MSG("DDR3_DBG\n");
+
+	if (size == 9) {
+		KC_MSG("dram_cap_check = 4Gb (512MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_PINMUX
+	KC_MSG("DDR3_6mil\n");
+
+	if (size == 9) {
+		KC_MSG("dram_cap_check = 4Gb (512MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR2_512
+	KC_MSG("DDR2_512\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif N25_DDR2_512
+	KC_MSG("N25_DDR2_512\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR2_PINMUX
+	KC_MSG("DDR2\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#else
+	KC_MSG("no pinmux\n");
+#endif
+}
\ No newline at end of file
diff --git a/firmware/plat/cv180x/ddr/cvx16_pinmux.c b/firmware/plat/cv180x/ddr/cvx16_pinmux.c
new file mode 100644
index 0000000..f5d0199
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/cvx16_pinmux.c
@@ -0,0 +1,580 @@
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_pkg_info.h>
+
+void cvx16_pinmux(void)
+{
+	uartlog("%s\n", __func__);
+	//		ddr_debug_wr32(0x4E);
+	//		ddr_debug_num_write();
+#ifndef DDR_SIM
+	switch (get_ddr_vendor()) {
+	case DDR_VENDOR_NY_4G:
+		// DDR3_4G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x12141013);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x0C041503);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x06050001);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x08070B02);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0A0F0E09);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x0016110D);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x02136574);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000008);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76512308);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_NY_2G:
+		// DDR3_2G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x08070D09);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x0605020B);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x14040100);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x15030E0C);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0A0F1213);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00111016);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x82135764);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x67513028);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ESMT_1G:
+		// DDR3_1G
+		KC_MSG("pin mux X16 mode DDR_VENDOR_ESMT_1G setting\n");
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x08070B09);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x05000206);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0C04010D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x15030A14);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x10111213);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x000F160E);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x31756024);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000008);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x26473518);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000000);
+		break;
+	case DDR_VENDOR_ESMT_512M_DDR2:
+		// N25_DDR2_512
+		KC_MSG("pin mux X16 mode DDR_VENDOR_ESMT_512M_DDR2 setting\n");
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x0C06080B);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x070D0904);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x00010502);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x110A0E03);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0F141610);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00151312);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x71840532);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000006);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76103425);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000008);
+		break;
+	case DDR_VENDOR_ESMT_2G:
+		// DDR3_2G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x080B0D06);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x09010407);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x1405020C);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x15000E03);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0A0F1213);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00111016);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x82135764);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x67513208);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ETRON_1G:
+		// ETRON_DDR3_1G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x0B060908);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x02000107);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0C05040D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x13141503);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x160A1112);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x000F100E);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x28137564);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76158320);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ESMT_N25_1G:
+		// ESMT_N25_DDR3_1G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x08060B09);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x02040701);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0C00050D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x13150314);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x10111216);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x000F0A0E);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x82135674);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76153280);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ETRON_512M_DDR2:
+		// ETRON_DDR2_512
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x070B090C);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x04050608);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0E02030D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x110A0100);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0F131614);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00151012);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x86014532);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000007);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76012345);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000008);
+		break;
+	}
+#endif //ndef DDR_SIM
+
+#ifdef ETRON_DDR2_512
+	KC_MSG("pin mux X16 mode ETRON_DDR2_512 setting\n");
+	//------------------------------
+	//  pin mux base on PHYA
+	//------------------------------
+	//param_phyd_data_byte_swap_slice0    [1:     0]
+	//param_phyd_data_byte_swap_slice1    [9:     8]
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dq0_mux    [3:     0]
+	//param_phyd_swap_byte0_dq1_mux    [7:     4]
+	//param_phyd_swap_byte0_dq2_mux    [11:    8]
+	//param_phyd_swap_byte0_dq3_mux    [15:   12]
+	//param_phyd_swap_byte0_dq4_mux    [19:   16]
+	//param_phyd_swap_byte0_dq5_mux    [23:   20]
+	//param_phyd_swap_byte0_dq6_mux    [27:   24]
+	//param_phyd_swap_byte0_dq7_mux    [31:   28]
+	rddata = 0x86014532;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dm_mux     [3:     0]
+	rddata = 0x00000007;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dq0_mux    [3:     0]
+	//param_phyd_swap_byte1_dq1_mux    [7:     4]
+	//param_phyd_swap_byte1_dq2_mux    [11:    8]
+	//param_phyd_swap_byte1_dq3_mux    [15:   12]
+	//param_phyd_swap_byte1_dq4_mux    [19:   16]
+	//param_phyd_swap_byte1_dq5_mux    [23:   20]
+	//param_phyd_swap_byte1_dq6_mux    [27:   24]
+	//param_phyd_swap_byte1_dq7_mux    [31:   28]
+	rddata = 0x76012345;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dm_mux     [3:     0]
+	rddata = 0x00000008;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca0    [4:     0]
+	//param_phyd_swap_ca1    [12:    8]
+	//param_phyd_swap_ca2    [20:   16]
+	//param_phyd_swap_ca3    [28:   24]
+	rddata = 0x070B090C;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca4    [4:     0]
+	//param_phyd_swap_ca5    [12:    8]
+	//param_phyd_swap_ca6    [20:   16]
+	//param_phyd_swap_ca7    [28:   24]
+	rddata = 0x04050608;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca8    [4:     0]
+	//param_phyd_swap_ca9    [12:    8]
+	//param_phyd_swap_ca10   [20:   16]
+	//param_phyd_swap_ca11   [28:   24]
+	rddata = 0x0E02030D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca12   [4:     0]
+	//param_phyd_swap_ca13   [12:    8]
+	//param_phyd_swap_ca14   [20:   16]
+	//param_phyd_swap_ca15   [28:   24]
+	rddata = 0x110A0100;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca16   [4:     0]
+	//param_phyd_swap_ca17   [12:    8]
+	//param_phyd_swap_ca18   [20:   16]
+	//param_phyd_swap_ca19   [28:   24]
+	rddata = 0x0F131614;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca20   [4:     0]
+	//param_phyd_swap_ca21   [12:    8]
+	//param_phyd_swap_ca22   [20:   16]
+	rddata = 0x00151012;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_cke0   [0:0]
+	//param_phyd_swap_cs0    [4:4]
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+	//pinmux
+#ifdef ESMT_N25_DDR3_1G
+	KC_MSG("pin mux X16 mode ESMT_N25_DDR3_1G setting\n");
+	//------------------------------
+	//  pin mux base on PHYA
+	//------------------------------
+	//param_phyd_data_byte_swap_slice0    [1:     0]
+	//param_phyd_data_byte_swap_slice1    [9:     8]
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dq0_mux    [3:     0]
+	//param_phyd_swap_byte0_dq1_mux    [7:     4]
+	//param_phyd_swap_byte0_dq2_mux    [11:    8]
+	//param_phyd_swap_byte0_dq3_mux    [15:   12]
+	//param_phyd_swap_byte0_dq4_mux    [19:   16]
+	//param_phyd_swap_byte0_dq5_mux    [23:   20]
+	//param_phyd_swap_byte0_dq6_mux    [27:   24]
+	//param_phyd_swap_byte0_dq7_mux    [31:   28]
+	rddata = 0x82135674;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dm_mux     [3:     0]
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dq0_mux    [3:     0]
+	//param_phyd_swap_byte1_dq1_mux    [7:     4]
+	//param_phyd_swap_byte1_dq2_mux    [11:    8]
+	//param_phyd_swap_byte1_dq3_mux    [15:   12]
+	//param_phyd_swap_byte1_dq4_mux    [19:   16]
+	//param_phyd_swap_byte1_dq5_mux    [23:   20]
+	//param_phyd_swap_byte1_dq6_mux    [27:   24]
+	//param_phyd_swap_byte1_dq7_mux    [31:   28]
+	rddata = 0x76153280;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dm_mux     [3:     0]
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca0    [4:     0]
+	//param_phyd_swap_ca1    [12:    8]
+	//param_phyd_swap_ca2    [20:   16]
+	//param_phyd_swap_ca3    [28:   24]
+	rddata = 0x08060B09;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca4    [4:     0]
+	//param_phyd_swap_ca5    [12:    8]
+	//param_phyd_swap_ca6    [20:   16]
+	//param_phyd_swap_ca7    [28:   24]
+	rddata = 0x02040701;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca8    [4:     0]
+	//param_phyd_swap_ca9    [12:    8]
+	//param_phyd_swap_ca10   [20:   16]
+	//param_phyd_swap_ca11   [28:   24]
+	rddata = 0x0C00050D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca12   [4:     0]
+	//param_phyd_swap_ca13   [12:    8]
+	//param_phyd_swap_ca14   [20:   16]
+	//param_phyd_swap_ca15   [28:   24]
+	rddata = 0x13150314;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca16   [4:     0]
+	//param_phyd_swap_ca17   [12:    8]
+	//param_phyd_swap_ca18   [20:   16]
+	//param_phyd_swap_ca19   [28:   24]
+	rddata = 0x10111216;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca20   [4:     0]
+	//param_phyd_swap_ca21   [12:    8]
+	//param_phyd_swap_ca22   [20:   16]
+	rddata = 0x000F0A0E;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_cke0   [0:     0]
+	//param_phyd_swap_cs0    [4:     4]
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef ESMT_DDR3_2G
+	KC_MSG("pin mux X16 mode ESMT_DDR3_2G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x82135764;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x67513208;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x080B0D06;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x09010407;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x1405020C;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x15000E03;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A0F1213;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00111016;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef ETRON_DDR3_1G
+	KC_MSG("pin mux X16 mode ETRON_DDR3_1G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x28137564;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x76158320;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0B060908;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x02000107;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C05040D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x13141503;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x160A1112;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x000F100E;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_1G
+	KC_MSG("pin mux X16 mode DDR3_1G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x31756024;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x26473518;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x08070B09;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x05000206;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C04010D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x15030A14;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x10111213;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x000F160E;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_2G
+	KC_MSG("pin mux X16 mode DDR3_2G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x82135764;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x67513028;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x08070D09;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0605020B;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x14040100;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x15030E0C;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A0F1213;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00111016;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_4G
+	KC_MSG("pin mux X16 mode DDR3_4G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x02136574;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x76512308;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x12141013;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C041503;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x06050001;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x08070B02;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A0F0E09;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0016110D;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_DBG
+	KC_MSG("pin mux X16 mode DDR3_DBG setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x30587246;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000001;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x26417538;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0002080E;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x04060D01;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x090C030B;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x05071412;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A151013;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0016110F;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+#ifdef DDR3_PINMUX
+	KC_MSG("pin mux X16 mode DDR3_6mil setting\n");
+	rddata = 0x00000001;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x40613578;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000002;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x03582467;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000001;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x020E0D00;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x07090806;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C05010B;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x12141503;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x100A0413;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00160F11;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR2_512
+	KC_MSG("pin mux X16 mode DDR2_512 setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x60851243;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000007;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x67012354;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C06080B;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x090D0204;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x01050700;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x160A0E03;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0F141110;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00151312;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef N25_DDR2_512
+	KC_MSG("pin mux X16 mode N25_DDR2_512 setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x71840532;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000006;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x76103425;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C06080B;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x070D0904;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00010502;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x110A0E03;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0F141610;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00151312;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+#ifdef DDR2_PINMUX
+	KC_MSG("pin mux X16 mode DDR2 setting\n");
+	rddata = 0x00000001;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x40613578;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000002;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x03582467;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000001;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x020E0D00;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x07090806;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C05010B;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x12141503;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x100A0413;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00160F11;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+}
diff --git a/firmware/plat/cv180x/ddr/ddr.c b/firmware/plat/cv180x/ddr/ddr.c
new file mode 100644
index 0000000..41fd13c
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr.c
@@ -0,0 +1,20 @@
+#include <platform.h>
+#include <ddr.h>
+#include <ddr_sys_bring_up.h>
+#include <ddr_pkg_info.h>
+
+
+int ddr_init(const struct ddr_param *ddr_param)
+{
+	NOTICE("DDR init.\n");
+	NOTICE("ddr_param[0]=0x%x.\n", ((const uint32_t *)ddr_param)[0]);
+
+	// read_ddr_pkg_info();
+	// bldp_init((void *)ddr_param);
+#ifndef NO_DDR_CFG
+	read_ddr_pkg_info();
+	ddr_sys_bring_up();
+#endif //NO_DDR_CFG
+
+	return 0;
+}
diff --git a/firmware/plat/cv180x/ddr/ddr.mk b/firmware/plat/cv180x/ddr/ddr.mk
new file mode 100644
index 0000000..a5c70c2
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr.mk
@@ -0,0 +1,107 @@
+$(call print_var,DDR_CFG)
+
+# DDR_CFG = ddr3_2133_x16
+# DDR_CFG = ddr3_1866_x16
+# DDR_CFG = ddr2_1333_x16
+# DDR_CDF = ddr_auto_x16
+
+ifeq (${DDR_CFG},none)
+DDR_CFG =
+endif
+
+ifeq ($(DDR_CFG), )
+INCLUDES += \
+	-Iplat/${CHIP_ARCH}/include/ddr
+
+BL2_SOURCES += \
+	plat/${CHIP_ARCH}/ddr/ddr.c
+
+$(eval $(call add_define,NO_DDR_CFG))
+else
+INCLUDES += \
+	-Iplat/${CHIP_ARCH}/include/ddr \
+	-Iplat/${CHIP_ARCH}/include/ddr/ddr_config/${DDR_CFG}
+
+BL2_SOURCES += \
+	plat/${CHIP_ARCH}/ddr/ddr.c \
+	plat/${CHIP_ARCH}/ddr/ddr_pkg_info.c \
+	plat/${CHIP_ARCH}/ddr/ddr_sys_bring_up.c \
+	plat/${CHIP_ARCH}/ddr/ddr_sys.c \
+	plat/${CHIP_ARCH}/ddr/phy_pll_init.c \
+	plat/${CHIP_ARCH}/ddr/cvx16_pinmux.c \
+	plat/${CHIP_ARCH}/ddr/cvx16_dram_cap_check.c \
+	plat/${CHIP_ARCH}/ddr/ddr_config/${DDR_CFG}/ddrc_init.c \
+	plat/${CHIP_ARCH}/ddr/ddr_config/${DDR_CFG}/phy_init.c \
+	plat/${CHIP_ARCH}/ddr/ddr_config/${DDR_CFG}/ddr_patch_regs.c
+
+ifneq ($(findstring ddr3, ${DDR_CFG}),)
+    $(eval $(call add_define,DDR3))
+else ifneq ($(findstring ddr2, ${DDR_CFG}),)
+    $(eval $(call add_define,DDR2))
+else ifneq ($(findstring ddr_auto, ${DDR_CFG}),)
+    $(eval $(call add_define,DDR2_3))
+endif
+
+ifneq ($(findstring 2133, ${DDR_CFG}),)
+    $(eval $(call add_define,_mem_freq_2133))
+else ifneq ($(findstring 1866, ${DDR_CFG}),)
+    $(eval $(call add_define,_mem_freq_1866))
+else ifneq ($(findstring 1333, ${DDR_CFG}),)
+    $(eval $(call add_define,_mem_freq_1333))
+endif
+
+$(eval $(call add_define,REAL_DDRPHY))
+# $(eval $(call add_define,SSC_EN))
+$(eval $(call add_define,REAL_LOCK))
+$(eval $(call add_define,X16_MODE))
+
+# pinmux
+# ifneq ($(findstring ddr3, ${DDR_CFG}),)
+#     # $(eval $(call add_define,DDR3_4G))
+#     $(eval $(call add_define,DDR3_1G))
+# else ifneq ($(findstring ddr2, ${DDR_CFG}),)
+#     $(eval $(call add_define,N25_DDR2_512))
+# endif
+
+# full mem bist
+# $(eval $(call add_define,DBG_SHMOO))
+# $(eval $(call add_define,DBG_SHMOO_CA))
+# $(eval $(call add_define,DBG_SHMOO_CS))
+# $(eval $(call add_define,FULL_MEM_BIST))
+# $(eval $(call add_define,FULL_MEM_BIST_FOREVER))
+
+# overdrive clock setting
+ifeq ($(OD_CLK_SEL),y)
+$(eval $(call add_define,OD_CLK_SEL))
+endif
+
+# # for ddr simulation
+# $(eval $(call add_define,DDR_SIM))
+
+# # DDR_CFG = ddr3_2133_x16
+# # DDR_CFG = ddr3_1866_x16
+# # DDR_CFG = ddr2_1333_x16
+# ifeq ($(DDR_CFG), ddr2_1333_x16)
+# $(eval $(call add_define,N25_DDR2_512))
+# $(eval $(call add_define_val,SIM_CONF_INFO_VAL,0x70000000))
+# endif
+
+# ifeq ($(DDR_CFG), ddr3_1866_x16)
+#  $(eval $(call add_define,DDR3_1G))
+# # (BGA)
+# $(eval $(call add_define_val,SIM_CONF_INFO_VAL,0x20000000))
+# # (QFN)
+# # $(eval $(call add_define_val,SIM_CONF_INFO_VAL,0x60000000))
+# endif
+
+#  $(eval $(call add_define, DDR_BRINGUP))
+#  QFN68_7*7:1801B
+#  $(eval $(call add_define_val,BRINGUP_CONF_INFO_VAL,0x20000000))
+#  QFN68_7*7:1800B
+#  $(eval $(call add_define_val,BRINGUP_CONF_INFO_VAL,0x30000000))
+#  QFN88_9*9:1801C
+#  $(eval $(call add_define_val,BRINGUP_CONF_INFO_VAL,0x60000000))
+#  QFN88_9*9:1800C
+#  $(eval $(call add_define_val,BRINGUP_CONF_INFO_VAL,0x70000000))
+
+endif
\ No newline at end of file
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c b/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..0ebf587
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c
@@ -0,0 +1,114 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr2_1333_x16_qfn.c
+
+struct regpatch ddr_patch_regs[] = {
+#if 0
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+#endif
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000808},
+#if 0
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x04040404},
+#endif
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000808},
+#if 0
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x04040404},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06440644},
+	{0x08000a04, 0xFFFFFFFF, 0x06440644},
+	{0x08000a08, 0xFFFFFFFF, 0x06440644},
+	{0x08000a0c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a10, 0xFFFFFFFF, 0x00000644},
+	{0x08000a14, 0xFFFFFFFF, 0x0d000000},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06440644},
+	{0x08000a44, 0xFFFFFFFF, 0x06440644},
+	{0x08000a48, 0xFFFFFFFF, 0x06440644},
+	{0x08000a4c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a50, 0xFFFFFFFF, 0x00000644},
+	{0x08000a54, 0xFFFFFFFF, 0x0d000000},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+#endif
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x03010504},
+	{0x08000b04, 0xFFFFFFFF, 0x02030203},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x002a4204},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x08030803},
+	{0x08000b34, 0xFFFFFFFF, 0x02070205},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x002b4003},
+#if 0
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x0000081e},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x0000081e},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+#endif
+};
+
+uint32_t ddr_patch_regs_count = ARRAY_SIZE(ddr_patch_regs);
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c
new file mode 100644
index 0000000..525a14f
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c
@@ -0,0 +1,385 @@
+// for ESMT DDR2-1333 only
+
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+#include <bitwise_ops.h>
+
+uint32_t ddr_data_rate = 1333;
+
+void ddrc_init(void)
+{
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	// PATCH0.use_blk_ext}:0:2:=0x1
+	// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+	// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+	// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+	// PATCH0.starve_stall_at_abr:5:1:=0x1
+	// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+	// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+	// PATCH0.pagematch_limit_threshold:8:3=0x3
+	// PATCH0.qos_sel:12:2:=0x2
+	// PATCH0.burst_rdwr_xpi:16:4:=0x4
+	// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+	// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+	// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+	// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+	// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+	// PATCH0.derate_sys_en:29:1:=0x1
+	// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+	mmio_wr32(0x08004000 + 0x44, 0x14000000);
+	// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+	// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+	// PATCH1.ref_adv_max:16:7:=0x0
+	// PATCH1.burst_rdwr_wr_xpi:24:4:=0x4
+	// PATCH1.use_blk_extend:28:2:=0x1
+	mmio_wr32(0x08004000 + 0x6c, 0x00000003);
+	// PATCH5.vpr_fix:0:1:=0x1
+	// PATCH5.vpw_fix:1:1:=0x1
+	mmio_wr32(0x08004000 + 0x148, 0x979C0000);
+	// PATCH4.t_phyd_rden:16:6=0x0
+	// PATCH4.phyd_rd_clk_stop:23:1=0x0
+	// PATCH4.t_phyd_wren:24:6=0x0
+	// PATCH4.phyd_wr_clk_stop:31:1=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x0, 0x81041400);
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	mmio_wr32(0x08004000 + 0x34, 0x006A0001);
+	mmio_wr32(0x08004000 + 0x38, 0x00020000);
+	mmio_wr32(0x08004000 + 0x50, 0x00201070);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	mmio_wr32(0x08004000 + 0x64, 0x0051002C);
+#ifdef DDR_INIT_SPEED_UP
+	mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+	mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+#else
+	mmio_wr32(0x08004000 + 0xd0, 0x00010043);
+	mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+#endif
+	mmio_wr32(0x08004000 + 0xdc, 0x03730040);
+	mmio_wr32(0x08004000 + 0xe0, 0x00800000);
+	mmio_wr32(0x08004000 + 0x100, 0x0A011610);
+	mmio_wr32(0x08004000 + 0x104, 0x00030414);
+	mmio_wr32(0x08004000 + 0x108, 0x03040408);
+	mmio_wr32(0x08004000 + 0x10c, 0x00003004);
+	mmio_wr32(0x08004000 + 0x110, 0x05020406);
+	mmio_wr32(0x08004000 + 0x114, 0x01010303);
+	mmio_wr32(0x08004000 + 0x120, 0x00000503);
+	// phyd related
+	mmio_wr32(0x08004000 + 0x190, 0x04858302);
+	// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+	// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+	// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+	// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+	// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+	// DFITMG0.dfi_tphy_wrlat:0:6:=0x5
+	mmio_wr32(0x08004000 + 0x194, 0x00070102);
+	// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+	// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+	// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+	// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+	// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+	mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+	// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+	// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+	// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+	// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+	// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+	// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+	// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+	mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+	mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+	mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+	mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+	// address map, auto gen.
+	// support from 0.5Gb to 4Gb
+	// R[17:13]B[2]R[12:0]B[1:0]C[9:0]
+	mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x204, 0x00140707);
+	mmio_wr32(0x08004000 + 0x208, 0x00000000);
+	mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+	mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+	mmio_wr32(0x08004000 + 0x218, 0x06060605);
+	mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+	mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+	mmio_wr32(0x08004000 + 0x224, 0x05050505);
+	mmio_wr32(0x08004000 + 0x228, 0x05050505);
+	mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x240, 0x07010708);  //TBD
+	mmio_wr32(0x08004000 + 0x244, 0x00000000);
+	mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+	// SCHED.opt_vprw_sch:31:1:=0x0
+	// SCHED.rdwr_idle_gap:24:7:=0x0
+	// SCHED.go2critical_hysteresis:16:8:=0x0
+	// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+	// SCHED.lpr_num_entries:8:7:=0x1f
+	// SCHED.autopre_rmw:7:1:=0x1
+	// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+	// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+	// SCHED.opt_wrcam_fill_level:4:1:=0x0
+	// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+	// SCHED.pageclose:2:1:=0x1
+	// SCHED.prefer_write:1:1:=0x0
+	// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x254, 0x00000020);
+	// SCHED1.page_hit_limit_rd:28:3:=0x0
+	// SCHED1.page_hit_limit_wr:24:3:=0x0
+	// SCHED1.visible_window_limit_rd:20:3:=0x0
+	// SCHED1.visible_window_limit_wr:16:3:=0x0
+	// SCHED1.delay_switch_write:12:4:=0x0
+	// SCHED1.pageclose_timer:0:8:=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x25c, 0x100000A8);
+	// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+	// PERFHPR1.hpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x264, 0x100000A8);
+	// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+	// PERFLPR1.lpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x26c, 0x100000A8);
+	// PERFWR1.w_xact_run_length:24:8:=0x20
+	// PERFWR1.w_max_starve:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x300, 0x00000000);
+	// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+	// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+	// DBG0.dis_collision_page_opt:4:1:=0x0
+	// DBG0.dis_act_bypass:2:1:=0x0
+	// DBG0.dis_rd_bypass:1:1:=0x0
+	// DBG0.dis_wc:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x304, 0x00000000);
+	// DBG1.dis_hif:1:1:=0x0
+	// DBG1.dis_dq:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x320, 0x00000001);
+	// SWCTL.sw_done:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+	// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+	// POISONCFG.rd_poison_intr_en:20:1:=0x0
+	// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+	// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+	// POISONCFG.wr_poison_intr_en:4:1:=0x0
+	// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x400, 0x00000011);
+	// PCCFG.dch_density_ratio:12:2:=0x0
+	// PCCFG.bl_exp_mode:8:1:=0x0
+	// PCCFG.pagematch_limit:4:1:=0x1
+	// PCCFG.go2critical_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x404, 0x00006000);
+	// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_0.rd_port_aging_en:12:1:=0x0
+	// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_0.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x408, 0x00006000);
+	// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_0.wr_port_aging_en:12:1:=0x0
+	// PCFGW_0.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x490, 0x00000001);
+	// PCTRL_0.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x494, 0x00000007);
+	// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+	// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+	// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+	// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+	// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_1.rd_port_aging_en:12:1:=0x0
+	// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_1.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+	// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_1.wr_port_aging_en:12:1:=0x0
+	// PCFGW_1.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x540, 0x00000001);
+	// PCTRL_1.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x544, 0x00000007);
+	// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+	// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+	// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+	// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x564, 0x00006000);
+	// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_2.rd_port_aging_en:12:1:=0x0
+	// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_2.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x568, 0x00006000);
+	// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_2.wr_port_aging_en:12:1:=0x0
+	// PCFGW_2.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+	// PCTRL_2.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+	// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+	// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+	// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+	// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+}
+
+void ctrl_init_high_patch(void)
+{
+	// enable auto PD
+	mmio_wr32(0x08004000 + 0x30, 0x00000002);
+	// enable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+	// enable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+	// change xpi to multi DDR burst
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	mmio_wr32(0x08004000 + 0x44, 0x08000000);
+}
+
+void ctrl_init_low_patch(void)
+{
+	// disable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	// disable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	// disable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+	// change xpi to single DDR burst
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	mmio_wr32(0x08004000 + 0x44, 0x14000000);
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	rddata = mmio_rd32(0x08004000 + 0x0);
+	dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+	dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+	dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 5:
+		mmio_wr32(0x08004000 + 0x64, 0x00510019);
+		mmio_wr32(0x08004000 + 0x100, 0x0B011610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000502);
+		break;
+	case 6:
+		mmio_wr32(0x08004000 + 0x64, 0x0051002C);
+		mmio_wr32(0x08004000 + 0x100, 0x0A011610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000503);
+		break;
+	case 7:
+		mmio_wr32(0x08004000 + 0x64, 0x0051002B);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000503);
+		break;
+	case 8:
+		mmio_wr32(0x08004000 + 0x64, 0x00510041);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000504);
+		break;
+	case 9:
+		mmio_wr32(0x08004000 + 0x64, 0x0051006E);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000505);
+		break;
+	}
+
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 5:
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x003F0606);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F1F0000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x040F0404);
+		mmio_wr32(0x08004000 + 0x218, 0x04040404);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000404);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x04040404);
+		mmio_wr32(0x08004000 + 0x228, 0x04040404);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F04);
+		break;
+	case 6:
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x003F0707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+		mmio_wr32(0x08004000 + 0x218, 0x05050505);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000505);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x05050505);
+		mmio_wr32(0x08004000 + 0x228, 0x05050505);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+		break;
+	case 7:
+	case 8:
+	case 9:
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x00070707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+		mmio_wr32(0x08004000 + 0x218, 0x06060606);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x06060606);
+		mmio_wr32(0x08004000 + 0x228, 0x06060606);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+		break;
+	}
+	// toggle refresh_update_level
+	mmio_wr32(0x08004000 + 0x60, 0x00000002);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/phy_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/phy_init.c
new file mode 100644
index 0000000..a1e18db
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr2_1333_x16/phy_init.c
@@ -0,0 +1,271 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, DDR_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, DDR_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, DDR_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, DDR_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, DDR_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, DDR_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, DDR_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, DDR_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, DDR_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, DDR_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, DDR_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, DDR_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, DDR_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, DDR_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, DDR_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, DDR_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, DDR_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, DDR_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, DDR_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, DDR_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, DDR_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, DDR_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, DDR_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, DDR_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, DDR_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, DDR_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, DDR_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, DDR_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, DDR_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, DDR_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, DDR_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, DDR_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, DDR_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, DDR_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, DDR_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, DDR_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, DDR_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, DDR_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, DDR_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, DDR_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, DDR_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, DDR_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, DDR_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, DDR_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, DDR_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, DDR_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, DDR_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, DDR_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, DDR_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, DDR_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, DDR_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, DDR_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, DDR_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, DDR_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, DDR_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, DDR_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, DDR_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, DDR_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, DDR_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, DDR_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, DDR_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, DDR_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, DDR_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, DDR_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, DDR_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, DDR_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, DDR_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, DDR_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, DDR_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, DDR_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, DDR_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, DDR_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, DDR_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, DDR_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, DDR_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, DDR_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, DDR_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, DDR_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, DDR_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, DDR_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, DDR_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c b/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..55309a1
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c
@@ -0,0 +1,110 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr3_x16_bga.c for 1866
+
+struct regpatch ddr_patch_regs[] = {
+#if 0
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x06060606},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x06060606},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06430643},
+	{0x08000a04, 0xFFFFFFFF, 0x06430643},
+	{0x08000a08, 0xFFFFFFFF, 0x06430643},
+	{0x08000a0c, 0xFFFFFFFF, 0x06430643},
+	{0x08000a10, 0xFFFFFFFF, 0x00000643},
+	{0x08000a14, 0xFFFFFFFF, 0x0a7e007e},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06480648},
+	{0x08000a44, 0xFFFFFFFF, 0x06480648},
+	{0x08000a48, 0xFFFFFFFF, 0x06480648},
+	{0x08000a4c, 0xFFFFFFFF, 0x06480648},
+	{0x08000a50, 0xFFFFFFFF, 0x00000648},
+	{0x08000a54, 0xFFFFFFFF, 0x0a7e007e},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+#endif
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x05030703},
+	{0x08000b04, 0xFFFFFFFF, 0x03030403},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x002e3b03},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x07030204},
+	{0x08000b34, 0xFFFFFFFF, 0x03030403},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x002e3d04},
+#if 0
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x00000a14},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x00000a14},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+#endif
+};
+
+uint32_t ddr_patch_regs_count = ARRAY_SIZE(ddr_patch_regs);
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c
new file mode 100644
index 0000000..bfba362
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c
@@ -0,0 +1,343 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+#include <bitwise_ops.h>
+
+uint32_t ddr_data_rate = 1866;
+
+void ddrc_init(void)
+{
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	// PATCH0.use_blk_ext}:0:2:=0x1
+	// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+	// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+	// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+	// PATCH0.starve_stall_at_abr:5:1:=0x1
+	// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+	// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+	// PATCH0.pagematch_limit_threshold:8:3=0x3
+	// PATCH0.qos_sel:12:2:=0x2
+	// PATCH0.burst_rdwr_xpi:16:4:=0x4
+	// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+	// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+	// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+	// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+	// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+	// PATCH0.derate_sys_en:29:1:=0x1
+	// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+	mmio_wr32(0x08004000 + 0x44, 0x14000000);
+	// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+	// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+	// PATCH1.ref_adv_max:16:7:=0x0
+	// PATCH1.burst_rdwr_wr_xpi:24:4:=0x4
+	// PATCH1.use_blk_extend:28:2:=0x1
+	mmio_wr32(0x08004000 + 0x6c, 0x00000003);
+	// PATCH5.vpr_fix:0:1:=0x1
+	// PATCH5.vpw_fix:1:1:=0x1
+	mmio_wr32(0x08004000 + 0x148, 0x999F0000);
+	// PATCH4.t_phyd_rden:16:6=0x0
+	// PATCH4.phyd_rd_clk_stop:23:1=0x0
+	// PATCH4.t_phyd_wren:24:6=0x0
+	// PATCH4.phyd_wr_clk_stop:31:1=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x0, 0x81041401);
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	mmio_wr32(0x08004000 + 0x34, 0x00930001);
+	mmio_wr32(0x08004000 + 0x38, 0x00020000);
+	mmio_wr32(0x08004000 + 0x50, 0x00201070);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+	mmio_wr32(0x08004000 + 0xc0, 0x00000000);
+	mmio_wr32(0x08004000 + 0xc4, 0x00000000);
+#ifdef DDR_INIT_SPEED_UP
+	mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+	mmio_wr32(0x08004000 + 0xd4, 0x00020000);
+#else
+	mmio_wr32(0x08004000 + 0xd0, 0x000100E5);
+	mmio_wr32(0x08004000 + 0xd4, 0x006A0000);
+#endif
+	mmio_wr32(0x08004000 + 0xdc, 0x1F140040);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0xe0, 0x04600000);
+#else
+	mmio_wr32(0x08004000 + 0xe0, 0x00600000);
+#endif
+	mmio_wr32(0x08004000 + 0xe4, 0x000B03BF);
+	mmio_wr32(0x08004000 + 0x100, 0x0E111F10);
+	mmio_wr32(0x08004000 + 0x104, 0x00030417);
+	mmio_wr32(0x08004000 + 0x108, 0x0507060A);
+	mmio_wr32(0x08004000 + 0x10c, 0x00002007);
+	mmio_wr32(0x08004000 + 0x110, 0x07020307);
+	mmio_wr32(0x08004000 + 0x114, 0x05050303);
+	mmio_wr32(0x08004000 + 0x120, 0x00000907);
+	mmio_wr32(0x08004000 + 0x13c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x180, 0xC0960026);
+	mmio_wr32(0x08004000 + 0x184, 0x00000001);
+	// phyd related
+	mmio_wr32(0x08004000 + 0x190, 0x048a8305);
+	// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+	// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+	// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+	// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+	// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+	// DFITMG0.dfi_tphy_wrlat:0:6:=0x5
+	mmio_wr32(0x08004000 + 0x194, 0x00070202);
+	// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+	// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+	// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+	// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+	// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+	mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+	// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+	// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+	// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+	// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+	// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+	// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+	// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+	mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+	mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+	mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+	mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+	// address map, auto gen.
+	mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x204, 0x00070707);
+	mmio_wr32(0x08004000 + 0x208, 0x00000000);
+	mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+	mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+	mmio_wr32(0x08004000 + 0x218, 0x06060606);
+	mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+	mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+	mmio_wr32(0x08004000 + 0x224, 0x06060606);
+	mmio_wr32(0x08004000 + 0x228, 0x06060606);
+	mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x240, 0x08000610);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0x244, 0x00000001);
+#else
+	mmio_wr32(0x08004000 + 0x244, 0x00000000);
+#endif
+	mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+	// SCHED.opt_vprw_sch:31:1:=0x0
+	// SCHED.rdwr_idle_gap:24:7:=0x0
+	// SCHED.go2critical_hysteresis:16:8:=0x0
+	// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+	// SCHED.lpr_num_entries:8:7:=0x1f
+	// SCHED.autopre_rmw:7:1:=0x1
+	// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+	// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+	// SCHED.opt_wrcam_fill_level:4:1:=0x0
+	// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+	// SCHED.pageclose:2:1:=0x1
+	// SCHED.prefer_write:1:1:=0x0
+	// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x254, 0x00000000);
+	// SCHED1.page_hit_limit_rd:28:3:=0x0
+	// SCHED1.page_hit_limit_wr:24:3:=0x0
+	// SCHED1.visible_window_limit_rd:20:3:=0x0
+	// SCHED1.visible_window_limit_wr:16:3:=0x0
+	// SCHED1.delay_switch_write:12:4:=0x0
+	// SCHED1.pageclose_timer:0:8:=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x25c, 0x100000F0);
+	// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+	// PERFHPR1.hpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x264, 0x100000F0);
+	// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+	// PERFLPR1.lpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x26c, 0x100000F0);
+	// PERFWR1.w_xact_run_length:24:8:=0x20
+	// PERFWR1.w_max_starve:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x300, 0x00000000);
+	// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+	// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+	// DBG0.dis_collision_page_opt:4:1:=0x0
+	// DBG0.dis_act_bypass:2:1:=0x0
+	// DBG0.dis_rd_bypass:1:1:=0x0
+	// DBG0.dis_wc:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x304, 0x00000000);
+	// DBG1.dis_hif:1:1:=0x0
+	// DBG1.dis_dq:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x320, 0x00000001);
+	// SWCTL.sw_done:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+	// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+	// POISONCFG.rd_poison_intr_en:20:1:=0x0
+	// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+	// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+	// POISONCFG.wr_poison_intr_en:4:1:=0x0
+	// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x400, 0x00000011);
+	// PCCFG.dch_density_ratio:12:2:=0x0
+	// PCCFG.bl_exp_mode:8:1:=0x0
+	// PCCFG.pagematch_limit:4:1:=0x1
+	// PCCFG.go2critical_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x404, 0x00006000);
+	// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_0.rd_port_aging_en:12:1:=0x0
+	// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_0.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x408, 0x00006000);
+	// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_0.wr_port_aging_en:12:1:=0x0
+	// PCFGW_0.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x490, 0x00000001);
+	// PCTRL_0.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x494, 0x00000007);
+	// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+	// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+	// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+	// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+	// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_1.rd_port_aging_en:12:1:=0x0
+	// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_1.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+	// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_1.wr_port_aging_en:12:1:=0x0
+	// PCFGW_1.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x540, 0x00000001);
+	// PCTRL_1.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x544, 0x00000007);
+	// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+	// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+	// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+	// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x564, 0x00006000);
+	// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_2.rd_port_aging_en:12:1:=0x0
+	// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_2.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x568, 0x00006000);
+	// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_2.wr_port_aging_en:12:1:=0x0
+	// PCFGW_2.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+	// PCTRL_2.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+	// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+	// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+	// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+	// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+}
+
+void ctrl_init_high_patch(void)
+{
+	// enable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000002);
+	// enable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+	// enable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+	// change xpi to multi DDR burst
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	mmio_wr32(0x08004000 + 0x44, 0x08000000);
+}
+
+void ctrl_init_low_patch(void)
+{
+	// disable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	// disable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	// disable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+	// change xpi to single DDR burst
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	mmio_wr32(0x08004000 + 0x44, 0x14000000);
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	rddata = mmio_rd32(0x08004000 + 0x0);
+	dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+	dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+	dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 6:
+		mmio_wr32(0x08004000 + 0x64, 0x0071002A);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 7:
+		mmio_wr32(0x08004000 + 0x64, 0x00710034);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 8:
+		mmio_wr32(0x08004000 + 0x64, 0x0071004B);
+		mmio_wr32(0x08004000 + 0x120, 0x00000904);
+		break;
+	case 9:
+		mmio_wr32(0x08004000 + 0x64, 0x0071007A);
+		mmio_wr32(0x08004000 + 0x120, 0x00000905);
+		break;
+	case 10:
+		mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+		mmio_wr32(0x08004000 + 0x120, 0x00000907);
+		break;
+	}
+	// toggle refresh_update_level
+	mmio_wr32(0x08004000 + 0x60, 0x00000002);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/phy_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/phy_init.c
new file mode 100644
index 0000000..a1e18db
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr3_1866_x16/phy_init.c
@@ -0,0 +1,271 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, DDR_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, DDR_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, DDR_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, DDR_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, DDR_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, DDR_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, DDR_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, DDR_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, DDR_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, DDR_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, DDR_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, DDR_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, DDR_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, DDR_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, DDR_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, DDR_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, DDR_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, DDR_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, DDR_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, DDR_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, DDR_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, DDR_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, DDR_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, DDR_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, DDR_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, DDR_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, DDR_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, DDR_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, DDR_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, DDR_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, DDR_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, DDR_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, DDR_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, DDR_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, DDR_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, DDR_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, DDR_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, DDR_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, DDR_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, DDR_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, DDR_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, DDR_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, DDR_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, DDR_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, DDR_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, DDR_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, DDR_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, DDR_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, DDR_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, DDR_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, DDR_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, DDR_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, DDR_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, DDR_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, DDR_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, DDR_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, DDR_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, DDR_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, DDR_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, DDR_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, DDR_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, DDR_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, DDR_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, DDR_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, DDR_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, DDR_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, DDR_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, DDR_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, DDR_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, DDR_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, DDR_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, DDR_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, DDR_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, DDR_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, DDR_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, DDR_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, DDR_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, DDR_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, DDR_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, DDR_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, DDR_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c b/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..366868a
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c
@@ -0,0 +1,108 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr3_x16_bga.c for 2133
+
+struct regpatch ddr_patch_regs[] = {
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x06060606},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x06060606},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06430643},
+	{0x08000a04, 0xFFFFFFFF, 0x06430643},
+	{0x08000a08, 0xFFFFFFFF, 0x06430643},
+	{0x08000a0c, 0xFFFFFFFF, 0x06430643},
+	{0x08000a10, 0xFFFFFFFF, 0x00000643},
+	{0x08000a14, 0xFFFFFFFF, 0x0a7e007e},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06480648},
+	{0x08000a44, 0xFFFFFFFF, 0x06480648},
+	{0x08000a48, 0xFFFFFFFF, 0x06480648},
+	{0x08000a4c, 0xFFFFFFFF, 0x06480648},
+	{0x08000a50, 0xFFFFFFFF, 0x00000648},
+	{0x08000a54, 0xFFFFFFFF, 0x0a7e007e},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x00020402},
+	{0x08000b04, 0xFFFFFFFF, 0x05020401},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x00313902},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x06000100},
+	{0x08000b34, 0xFFFFFFFF, 0x02010303},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x00323900},
+
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x00000c28},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x00000c2a},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+};
+
+uint32_t ddr_patch_regs_count = ARRAY_SIZE(ddr_patch_regs);
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c
new file mode 100644
index 0000000..eec899e
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c
@@ -0,0 +1,350 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+#include <bitwise_ops.h>
+
+uint32_t ddr_data_rate = 2133;
+
+void ddrc_init(void)
+{
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	// PATCH0.use_blk_extend:0:2:=0x1
+	// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+	// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+	// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+	// PATCH0.starve_stall_at_abr:5:1:=0x1
+	// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+	// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+	// PATCH0.pagematch_limit_threshold:8:3=0x3
+	// PATCH0.qos_sel:12:2:=0x2
+	// PATCH0.timeout_wait_wr_mode:14:1:=0x1
+	// PATCH0.burst_rdwr_xpi:16:4:=0x4
+	// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+	// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+	// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+	// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+	// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+	// PATCH0.derate_sys_en:29:1:=0x1
+	// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+	mmio_wr32(0x08004000 + 0x44, 0x14000000);
+	// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+	// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+	// PATCH1.ref_adv_max:16:7:=0x0
+	// PATCH1.burst_rdwr_wr_xpi:24:4:=0x4
+	// PATCH1.use_blk_extend:28:2:=0x1
+	mmio_wr32(0x08004000 + 0x148, 0x999F0000);
+	// PATCH4.t_phyd_rden:16:6=0x0
+	// PATCH4.phyd_rd_clk_stop:23:1=0x0
+	// PATCH4.t_phyd_wren:24:6=0x0
+	// PATCH4.phyd_wr_clk_stop:31:1=0x0
+
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x0, 0x81041401);
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	mmio_wr32(0x08004000 + 0x34, 0x00A80001);
+	mmio_wr32(0x08004000 + 0x38, 0x00020000);
+	mmio_wr32(0x08004000 + 0x50, 0x00201070);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	mmio_wr32(0x08004000 + 0x64, 0x008200BB);
+	mmio_wr32(0x08004000 + 0xc0, 0x00000000);
+	mmio_wr32(0x08004000 + 0xc4, 0x00000000);
+#ifdef DDR_INIT_SPEED_UP
+	mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+	mmio_wr32(0x08004000 + 0xd4, 0x00030000);
+#else
+	mmio_wr32(0x08004000 + 0xd0, 0x00010106);
+	mmio_wr32(0x08004000 + 0xd4, 0x00790000);
+#endif
+	mmio_wr32(0x08004000 + 0xdc, 0x11240040);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0xe0, 0x04680000);
+#else
+	mmio_wr32(0x08004000 + 0xe0, 0x00680000);
+#endif
+	mmio_wr32(0x08004000 + 0xe4, 0x000C03BF);
+	mmio_wr32(0x08004000 + 0x100, 0x0F132412);
+	mmio_wr32(0x08004000 + 0x104, 0x00040419);
+	mmio_wr32(0x08004000 + 0x108, 0x0507060B);
+	mmio_wr32(0x08004000 + 0x10c, 0x00002008);
+	mmio_wr32(0x08004000 + 0x110, 0x07020408);
+	mmio_wr32(0x08004000 + 0x114, 0x06060403);
+	mmio_wr32(0x08004000 + 0x120, 0x00000907);
+	mmio_wr32(0x08004000 + 0x13c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x180, 0xC0AB002B);
+	mmio_wr32(0x08004000 + 0x184, 0x00000001);
+
+	// phyd related
+	mmio_wr32(0x08004000 + 0x190, 0x048a8306);
+	// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+	// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+	// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+	// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+	// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+	// DFITMG0.dfi_tphy_wrlat:0:6:=0x6
+	mmio_wr32(0x08004000 + 0x194, 0x00070202);
+	// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+	// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+	// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+	// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+	// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+	mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+	// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+	// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+	// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+	// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+	// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+	// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+	// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+	mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+	mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+	mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+	mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+
+	// address map, auto gen.
+	mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x204, 0x00070707);
+	mmio_wr32(0x08004000 + 0x208, 0x00000000);
+	mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+	mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+	mmio_wr32(0x08004000 + 0x218, 0x06060606);
+	mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+	mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+	mmio_wr32(0x08004000 + 0x224, 0x06060606);
+	mmio_wr32(0x08004000 + 0x228, 0x06060606);
+	mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x240, 0x08000610);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0x244, 0x00000001);
+#else
+	mmio_wr32(0x08004000 + 0x244, 0x00000000);
+#endif
+	mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+	// SCHED.opt_vprw_sch:31:1:=0x0
+	// SCHED.rdwr_idle_gap:24:7:=0x0
+	// SCHED.go2critical_hysteresis:16:8:=0x0
+	// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+	// SCHED.lpr_num_entries:8:7:=0x1f
+	// SCHED.autopre_rmw:7:1:=0x1
+	// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+	// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+	// SCHED.opt_wrcam_fill_level:4:1:=0x0
+	// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+	// SCHED.pageclose:2:1:=0x1
+	// SCHED.prefer_write:1:1:=0x0
+	// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+
+	mmio_wr32(0x08004000 + 0x254, 0x00000000);
+	// SCHED1.page_hit_limit_rd:28:3:=0x0
+	// SCHED1.page_hit_limit_wr:24:3:=0x0
+	// SCHED1.visible_window_limit_rd:20:3:=0x0
+	// SCHED1.visible_window_limit_wr:16:3:=0x0
+	// SCHED1.delay_switch_write:12:4:=0x0
+	// SCHED1.pageclose_timer:0:8:=0x0
+
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x25c, 0x10000110);
+	// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+	// PERFHPR1.hpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x264, 0x10000110);
+	// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+	// PERFLPR1.lpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x26c, 0x10000110);
+	// PERFWR1.w_xact_run_length:24:8:=0x20
+	// PERFWR1.w_max_starve:0:16:=0x1a8
+
+	mmio_wr32(0x08004000 + 0x300, 0x00000000);
+	// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+	// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+	// DBG0.dis_collision_page_opt:4:1:=0x0
+	// DBG0.dis_act_bypass:2:1:=0x0
+	// DBG0.dis_rd_bypass:1:1:=0x0
+	// DBG0.dis_wc:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x304, 0x00000000);
+	// DBG1.dis_hif:1:1:=0x0
+	// DBG1.dis_dq:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x320, 0x00000001);
+	// SWCTL.sw_done:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+	// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+	// POISONCFG.rd_poison_intr_en:20:1:=0x0
+	// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+	// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+	// POISONCFG.wr_poison_intr_en:4:1:=0x0
+	// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x400, 0x00000011);
+	// PCCFG.dch_density_ratio:12:2:=0x0
+	// PCCFG.bl_exp_mode:8:1:=0x0
+	// PCCFG.pagematch_limit:4:1:=0x1
+	// PCCFG.go2critical_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x404, 0x00006000);
+	// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_0.rd_port_aging_en:12:1:=0x0
+	// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_0.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x408, 0x00006000);
+	// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_0.wr_port_aging_en:12:1:=0x0
+	// PCFGW_0.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x490, 0x00000001);
+	// PCTRL_0.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x494, 0x00000007);
+	// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+	// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+	// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+	// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+	// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_1.rd_port_aging_en:12:1:=0x0
+	// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_1.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+	// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_1.wr_port_aging_en:12:1:=0x0
+	// PCFGW_1.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x540, 0x00000001);
+	// PCTRL_1.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x544, 0x00000007);
+	// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+	// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+	// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+	// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x564, 0x00006000);
+	// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_2.rd_port_aging_en:12:1:=0x0
+	// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_2.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x568, 0x00006000);
+	// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_2.wr_port_aging_en:12:1:=0x0
+	// PCFGW_2.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+	// PCTRL_2.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+	// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+	// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+	// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+	// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+}
+
+void ctrl_init_high_patch(void)
+{
+	// enable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000002);
+	// enable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+	// enable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+	// change xpi to multi DDR burst
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	mmio_wr32(0x08004000 + 0x44, 0x08000000);
+}
+
+void ctrl_init_low_patch(void)
+{
+	// disable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	// disable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	// disable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+	// change xpi to single DDR burst
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	mmio_wr32(0x08004000 + 0x44, 0x14000000);
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	rddata = mmio_rd32(0x08004000 + 0x0);
+	dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+	dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+	dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+	uartlog("dram_cap_in_mbyte_per_dev=%d\n", dram_cap_in_mbyte_per_dev);
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 6:
+		mmio_wr32(0x08004000 + 0x64, 0x00820030);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 7:
+		mmio_wr32(0x08004000 + 0x64, 0x0082003B);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 8:
+		mmio_wr32(0x08004000 + 0x64, 0x00820056);
+		mmio_wr32(0x08004000 + 0x120, 0x00000904);
+		break;
+	case 9:
+		mmio_wr32(0x08004000 + 0x64, 0x0082008B);
+		mmio_wr32(0x08004000 + 0x120, 0x00000906);
+		break;
+	case 10:
+		mmio_wr32(0x08004000 + 0x64, 0x008200BB);
+		mmio_wr32(0x08004000 + 0x120, 0x00000907);
+		break;
+	}
+	// toggle refresh_update_level
+	mmio_wr32(0x08004000 + 0x60, 0x00000002);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/phy_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/phy_init.c
new file mode 100644
index 0000000..a1e18db
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr3_2133_x16/phy_init.c
@@ -0,0 +1,271 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, DDR_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, DDR_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, DDR_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, DDR_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, DDR_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, DDR_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, DDR_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, DDR_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, DDR_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, DDR_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, DDR_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, DDR_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, DDR_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, DDR_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, DDR_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, DDR_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, DDR_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, DDR_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, DDR_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, DDR_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, DDR_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, DDR_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, DDR_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, DDR_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, DDR_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, DDR_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, DDR_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, DDR_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, DDR_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, DDR_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, DDR_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, DDR_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, DDR_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, DDR_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, DDR_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, DDR_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, DDR_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, DDR_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, DDR_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, DDR_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, DDR_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, DDR_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, DDR_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, DDR_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, DDR_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, DDR_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, DDR_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, DDR_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, DDR_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, DDR_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, DDR_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, DDR_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, DDR_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, DDR_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, DDR_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, DDR_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, DDR_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, DDR_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, DDR_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, DDR_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, DDR_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, DDR_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, DDR_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, DDR_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, DDR_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, DDR_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, DDR_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, DDR_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, DDR_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, DDR_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, DDR_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, DDR_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, DDR_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, DDR_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, DDR_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, DDR_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, DDR_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, DDR_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, DDR_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, DDR_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, DDR_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c b/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..603c1d8
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c
@@ -0,0 +1,218 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr3_x16_bga.c for 1866
+
+struct regpatch ddr3_1866_patch_regs[] = {
+#if 0
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x06060606},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x06060606},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06430643},
+	{0x08000a04, 0xFFFFFFFF, 0x06430643},
+	{0x08000a08, 0xFFFFFFFF, 0x06430643},
+	{0x08000a0c, 0xFFFFFFFF, 0x06430643},
+	{0x08000a10, 0xFFFFFFFF, 0x00000643},
+	{0x08000a14, 0xFFFFFFFF, 0x0a7e007e},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06480648},
+	{0x08000a44, 0xFFFFFFFF, 0x06480648},
+	{0x08000a48, 0xFFFFFFFF, 0x06480648},
+	{0x08000a4c, 0xFFFFFFFF, 0x06480648},
+	{0x08000a50, 0xFFFFFFFF, 0x00000648},
+	{0x08000a54, 0xFFFFFFFF, 0x0a7e007e},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+#endif
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x05030703},
+	{0x08000b04, 0xFFFFFFFF, 0x03030403},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x002e3b03},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x07030204},
+	{0x08000b34, 0xFFFFFFFF, 0x03030403},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x002e3d04},
+#if 0
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x00000a14},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x00000a14},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+#endif
+};
+
+uint32_t ddr3_1866_patch_regs_count = ARRAY_SIZE(ddr3_1866_patch_regs);
+
+//regpatch_ddr2_1333_x16_qfn.c
+
+struct regpatch ddr2_1333_patch_regs[] = {
+#if 0
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+#endif
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000808},
+#if 0
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x04040404},
+#endif
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000808},
+#if 0
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x04040404},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06440644},
+	{0x08000a04, 0xFFFFFFFF, 0x06440644},
+	{0x08000a08, 0xFFFFFFFF, 0x06440644},
+	{0x08000a0c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a10, 0xFFFFFFFF, 0x00000644},
+	{0x08000a14, 0xFFFFFFFF, 0x0d000000},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06440644},
+	{0x08000a44, 0xFFFFFFFF, 0x06440644},
+	{0x08000a48, 0xFFFFFFFF, 0x06440644},
+	{0x08000a4c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a50, 0xFFFFFFFF, 0x00000644},
+	{0x08000a54, 0xFFFFFFFF, 0x0d000000},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+#endif
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x03010504},
+	{0x08000b04, 0xFFFFFFFF, 0x02030203},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x002a4204},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x08030803},
+	{0x08000b34, 0xFFFFFFFF, 0x02070205},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x002b4003},
+#if 0
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x0000081e},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x0000081e},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+#endif
+};
+
+uint32_t ddr2_1333_patch_regs_count = ARRAY_SIZE(ddr2_1333_patch_regs);
\ No newline at end of file
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c
new file mode 100644
index 0000000..78cc1e8
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c
@@ -0,0 +1,720 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+#include <bitwise_ops.h>
+#include <ddr_pkg_info.h>
+
+uint32_t ddr_data_rate = 1866;
+
+void ddrc_init(void)
+{
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		NOTICE("DDR3 1866 ddrc_init\n");
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		// PATCH0.use_blk_ext}:0:2:=0x1
+		// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+		// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+		// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+		// PATCH0.starve_stall_at_abr:5:1:=0x1
+		// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+		// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+		// PATCH0.pagematch_limit_threshold:8:3=0x3
+		// PATCH0.qos_sel:12:2:=0x2
+		// PATCH0.burst_rdwr_xpi:16:4:=0x4
+		// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+		// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+		// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+		// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+		// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+		// PATCH0.derate_sys_en:29:1:=0x1
+		// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+		mmio_wr32(0x08004000 + 0x44, 0x14000000);
+		// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+		// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+		// PATCH1.ref_adv_max:16:7:=0x0
+		// PATCH1.burst_rdwr_wr_xpi:24:4:=0x4
+		// PATCH1.use_blk_extend:28:2:=0x1
+		mmio_wr32(0x08004000 + 0x6c, 0x00000003);
+		// PATCH5.vpr_fix:0:1:=0x1
+		// PATCH5.vpw_fix:1:1:=0x1
+		mmio_wr32(0x08004000 + 0x148, 0x999F0000);
+		// PATCH4.t_phyd_rden:16:6=0x0
+		// PATCH4.phyd_rd_clk_stop:23:1=0x0
+		// PATCH4.t_phyd_wren:24:6=0x0
+		// PATCH4.phyd_wr_clk_stop:31:1=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x0, 0x81041401);
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		mmio_wr32(0x08004000 + 0x34, 0x00930001);
+		mmio_wr32(0x08004000 + 0x38, 0x00020000);
+		mmio_wr32(0x08004000 + 0x50, 0x00201070);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+		mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+		mmio_wr32(0x08004000 + 0xc0, 0x00000000);
+		mmio_wr32(0x08004000 + 0xc4, 0x00000000);
+	#ifdef DDR_INIT_SPEED_UP
+		mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+		mmio_wr32(0x08004000 + 0xd4, 0x00020000);
+	#else
+		mmio_wr32(0x08004000 + 0xd0, 0x000100E5);
+		mmio_wr32(0x08004000 + 0xd4, 0x006A0000);
+	#endif
+		mmio_wr32(0x08004000 + 0xdc, 0x1F140040);
+	#ifdef DDR_DODT
+		mmio_wr32(0x08004000 + 0xe0, 0x04600000);
+	#else
+		mmio_wr32(0x08004000 + 0xe0, 0x00600000);
+	#endif
+		mmio_wr32(0x08004000 + 0xe4, 0x000B03BF);
+		mmio_wr32(0x08004000 + 0x100, 0x0E111F10);
+		mmio_wr32(0x08004000 + 0x104, 0x00030417);
+		mmio_wr32(0x08004000 + 0x108, 0x0507060A);
+		mmio_wr32(0x08004000 + 0x10c, 0x00002007);
+		mmio_wr32(0x08004000 + 0x110, 0x07020307);
+		mmio_wr32(0x08004000 + 0x114, 0x05050303);
+		mmio_wr32(0x08004000 + 0x120, 0x00000907);
+		mmio_wr32(0x08004000 + 0x13c, 0x00000000);
+		mmio_wr32(0x08004000 + 0x180, 0xC0960026);
+		mmio_wr32(0x08004000 + 0x184, 0x00000001);
+		// phyd related
+		mmio_wr32(0x08004000 + 0x190, 0x048a8305);
+		// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+		// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+		// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+		// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+		// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+		// DFITMG0.dfi_tphy_wrlat:0:6:=0x5
+		mmio_wr32(0x08004000 + 0x194, 0x00070202);
+		// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+		// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+		// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+		// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+		// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+		mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+		// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+		// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+		// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+		// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+		// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+		// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+		// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+		mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+		mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+		mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+		mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+		// address map, auto gen.
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x00070707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+		mmio_wr32(0x08004000 + 0x218, 0x06060606);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x06060606);
+		mmio_wr32(0x08004000 + 0x228, 0x06060606);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x240, 0x08000610);
+	#ifdef DDR_DODT
+		mmio_wr32(0x08004000 + 0x244, 0x00000001);
+	#else
+		mmio_wr32(0x08004000 + 0x244, 0x00000000);
+	#endif
+		mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+		// SCHED.opt_vprw_sch:31:1:=0x0
+		// SCHED.rdwr_idle_gap:24:7:=0x0
+		// SCHED.go2critical_hysteresis:16:8:=0x0
+		// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+		// SCHED.lpr_num_entries:8:7:=0x1f
+		// SCHED.autopre_rmw:7:1:=0x1
+		// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+		// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+		// SCHED.opt_wrcam_fill_level:4:1:=0x0
+		// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+		// SCHED.pageclose:2:1:=0x1
+		// SCHED.prefer_write:1:1:=0x0
+		// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x254, 0x00000000);
+		// SCHED1.page_hit_limit_rd:28:3:=0x0
+		// SCHED1.page_hit_limit_wr:24:3:=0x0
+		// SCHED1.visible_window_limit_rd:20:3:=0x0
+		// SCHED1.visible_window_limit_wr:16:3:=0x0
+		// SCHED1.delay_switch_write:12:4:=0x0
+		// SCHED1.pageclose_timer:0:8:=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x25c, 0x100000F0);
+		// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+		// PERFHPR1.hpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x264, 0x100000F0);
+		// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+		// PERFLPR1.lpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x26c, 0x100000F0);
+		// PERFWR1.w_xact_run_length:24:8:=0x20
+		// PERFWR1.w_max_starve:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x300, 0x00000000);
+		// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+		// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+		// DBG0.dis_collision_page_opt:4:1:=0x0
+		// DBG0.dis_act_bypass:2:1:=0x0
+		// DBG0.dis_rd_bypass:1:1:=0x0
+		// DBG0.dis_wc:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x304, 0x00000000);
+		// DBG1.dis_hif:1:1:=0x0
+		// DBG1.dis_dq:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+		mmio_wr32(0x08004000 + 0x320, 0x00000001);
+		// SWCTL.sw_done:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+		// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+		// POISONCFG.rd_poison_intr_en:20:1:=0x0
+		// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+		// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+		// POISONCFG.wr_poison_intr_en:4:1:=0x0
+		// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x400, 0x00000011);
+		// PCCFG.dch_density_ratio:12:2:=0x0
+		// PCCFG.bl_exp_mode:8:1:=0x0
+		// PCCFG.pagematch_limit:4:1:=0x1
+		// PCCFG.go2critical_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x404, 0x00006000);
+		// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_0.rd_port_aging_en:12:1:=0x0
+		// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_0.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x408, 0x00006000);
+		// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_0.wr_port_aging_en:12:1:=0x0
+		// PCFGW_0.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x490, 0x00000001);
+		// PCTRL_0.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x494, 0x00000007);
+		// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+		// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+		// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+		// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+		// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_1.rd_port_aging_en:12:1:=0x0
+		// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_1.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+		// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_1.wr_port_aging_en:12:1:=0x0
+		// PCFGW_1.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x540, 0x00000001);
+		// PCTRL_1.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x544, 0x00000007);
+		// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+		// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+		// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+		// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x564, 0x00006000);
+		// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_2.rd_port_aging_en:12:1:=0x0
+		// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_2.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x568, 0x00006000);
+		// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_2.wr_port_aging_en:12:1:=0x0
+		// PCFGW_2.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+		// PCTRL_2.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+		// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+		// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+		// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+		// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+	} else {
+		NOTICE("DDR2 1333 ddrc_init\n");
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		// PATCH0.use_blk_ext}:0:2:=0x1
+		// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+		// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+		// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+		// PATCH0.starve_stall_at_abr:5:1:=0x1
+		// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+		// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+		// PATCH0.pagematch_limit_threshold:8:3=0x3
+		// PATCH0.qos_sel:12:2:=0x2
+		// PATCH0.burst_rdwr_xpi:16:4:=0x4
+		// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+		// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+		// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+		// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+		// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+		// PATCH0.derate_sys_en:29:1:=0x1
+		// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+		mmio_wr32(0x08004000 + 0x44, 0x14000000);
+		// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+		// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+		// PATCH1.ref_adv_max:16:7:=0x0
+		// PATCH1.burst_rdwr_wr_xpi:24:4:=0x4
+		// PATCH1.use_blk_extend:28:2:=0x1
+		mmio_wr32(0x08004000 + 0x6c, 0x00000003);
+		// PATCH5.vpr_fix:0:1:=0x1
+		// PATCH5.vpw_fix:1:1:=0x1
+		mmio_wr32(0x08004000 + 0x148, 0x979C0000);
+		// PATCH4.t_phyd_rden:16:6=0x0
+		// PATCH4.phyd_rd_clk_stop:23:1=0x0
+		// PATCH4.t_phyd_wren:24:6=0x0
+		// PATCH4.phyd_wr_clk_stop:31:1=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x0, 0x81041400);
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		mmio_wr32(0x08004000 + 0x34, 0x006A0001);
+		mmio_wr32(0x08004000 + 0x38, 0x00020000);
+		mmio_wr32(0x08004000 + 0x50, 0x00201070);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+		mmio_wr32(0x08004000 + 0x64, 0x0051002C);
+	#ifdef DDR_INIT_SPEED_UP
+		mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+		mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+	#else
+		mmio_wr32(0x08004000 + 0xd0, 0x00010043);
+		mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+	#endif
+		mmio_wr32(0x08004000 + 0xdc, 0x03730040);
+		mmio_wr32(0x08004000 + 0xe0, 0x00800000);
+		mmio_wr32(0x08004000 + 0x100, 0x0A011610);
+		mmio_wr32(0x08004000 + 0x104, 0x00030414);
+		mmio_wr32(0x08004000 + 0x108, 0x03040408);
+		mmio_wr32(0x08004000 + 0x10c, 0x00003004);
+		mmio_wr32(0x08004000 + 0x110, 0x05020406);
+		mmio_wr32(0x08004000 + 0x114, 0x01010303);
+		mmio_wr32(0x08004000 + 0x120, 0x00000503);
+		// phyd related
+		mmio_wr32(0x08004000 + 0x190, 0x04858302);
+		// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+		// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+		// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+		// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+		// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+		// DFITMG0.dfi_tphy_wrlat:0:6:=0x5
+		mmio_wr32(0x08004000 + 0x194, 0x00070102);
+		// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+		// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+		// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+		// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+		// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+		mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+		// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+		// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+		// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+		// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+		// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+		// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+		// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+		mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+		mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+		mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+		mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+		// address map, auto gen.
+		// support from 0.5Gb to 4Gb
+		// R[17:13]B[2]R[12:0]B[1:0]C[9:0]
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x00140707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+		mmio_wr32(0x08004000 + 0x218, 0x06060605);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x05050505);
+		mmio_wr32(0x08004000 + 0x228, 0x05050505);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x240, 0x07010708);  //TBD
+		mmio_wr32(0x08004000 + 0x244, 0x00000000);
+		mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+		// SCHED.opt_vprw_sch:31:1:=0x0
+		// SCHED.rdwr_idle_gap:24:7:=0x0
+		// SCHED.go2critical_hysteresis:16:8:=0x0
+		// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+		// SCHED.lpr_num_entries:8:7:=0x1f
+		// SCHED.autopre_rmw:7:1:=0x1
+		// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+		// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+		// SCHED.opt_wrcam_fill_level:4:1:=0x0
+		// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+		// SCHED.pageclose:2:1:=0x1
+		// SCHED.prefer_write:1:1:=0x0
+		// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x254, 0x00000020);
+		// SCHED1.page_hit_limit_rd:28:3:=0x0
+		// SCHED1.page_hit_limit_wr:24:3:=0x0
+		// SCHED1.visible_window_limit_rd:20:3:=0x0
+		// SCHED1.visible_window_limit_wr:16:3:=0x0
+		// SCHED1.delay_switch_write:12:4:=0x0
+		// SCHED1.pageclose_timer:0:8:=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x25c, 0x100000A8);
+		// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+		// PERFHPR1.hpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x264, 0x100000A8);
+		// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+		// PERFLPR1.lpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x26c, 0x100000A8);
+		// PERFWR1.w_xact_run_length:24:8:=0x20
+		// PERFWR1.w_max_starve:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x300, 0x00000000);
+		// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+		// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+		// DBG0.dis_collision_page_opt:4:1:=0x0
+		// DBG0.dis_act_bypass:2:1:=0x0
+		// DBG0.dis_rd_bypass:1:1:=0x0
+		// DBG0.dis_wc:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x304, 0x00000000);
+		// DBG1.dis_hif:1:1:=0x0
+		// DBG1.dis_dq:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+		mmio_wr32(0x08004000 + 0x320, 0x00000001);
+		// SWCTL.sw_done:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+		// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+		// POISONCFG.rd_poison_intr_en:20:1:=0x0
+		// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+		// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+		// POISONCFG.wr_poison_intr_en:4:1:=0x0
+		// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x400, 0x00000011);
+		// PCCFG.dch_density_ratio:12:2:=0x0
+		// PCCFG.bl_exp_mode:8:1:=0x0
+		// PCCFG.pagematch_limit:4:1:=0x1
+		// PCCFG.go2critical_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x404, 0x00006000);
+		// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_0.rd_port_aging_en:12:1:=0x0
+		// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_0.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x408, 0x00006000);
+		// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_0.wr_port_aging_en:12:1:=0x0
+		// PCFGW_0.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x490, 0x00000001);
+		// PCTRL_0.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x494, 0x00000007);
+		// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+		// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+		// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+		// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+		// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_1.rd_port_aging_en:12:1:=0x0
+		// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_1.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+		// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_1.wr_port_aging_en:12:1:=0x0
+		// PCFGW_1.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x540, 0x00000001);
+		// PCTRL_1.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x544, 0x00000007);
+		// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+		// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+		// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+		// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x564, 0x00006000);
+		// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_2.rd_port_aging_en:12:1:=0x0
+		// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_2.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x568, 0x00006000);
+		// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_2.wr_port_aging_en:12:1:=0x0
+		// PCFGW_2.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+		// PCTRL_2.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+		// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+		// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+		// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+		// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+	}
+}
+
+void ctrl_init_high_patch(void)
+{
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// enable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000002);
+		// enable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+		// enable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+		// change xpi to multi DDR burst
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		mmio_wr32(0x08004000 + 0x44, 0x08000000);
+	} else {
+		// enable auto PD
+		mmio_wr32(0x08004000 + 0x30, 0x00000002);
+		// enable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+		// enable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+		// change xpi to multi DDR burst
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		mmio_wr32(0x08004000 + 0x44, 0x08000000);
+	}
+}
+
+void ctrl_init_low_patch(void)
+{
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// disable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		// disable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		// disable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+		// change xpi to single DDR burst
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		mmio_wr32(0x08004000 + 0x44, 0x14000000);
+	} else {
+		// disable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		// disable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		// disable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+		// change xpi to single DDR burst
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		mmio_wr32(0x08004000 + 0x44, 0x14000000);
+	}
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = mmio_rd32(0x08004000 + 0x0);
+		dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+		dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+		dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+		switch (dram_cap_in_mbyte_per_dev) {
+		case 6:
+			mmio_wr32(0x08004000 + 0x64, 0x0071002A);
+			mmio_wr32(0x08004000 + 0x120, 0x00000903);
+			break;
+		case 7:
+			mmio_wr32(0x08004000 + 0x64, 0x00710034);
+			mmio_wr32(0x08004000 + 0x120, 0x00000903);
+			break;
+		case 8:
+			mmio_wr32(0x08004000 + 0x64, 0x0071004B);
+			mmio_wr32(0x08004000 + 0x120, 0x00000904);
+			break;
+		case 9:
+			mmio_wr32(0x08004000 + 0x64, 0x0071007A);
+			mmio_wr32(0x08004000 + 0x120, 0x00000905);
+			break;
+		case 10:
+			mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+			mmio_wr32(0x08004000 + 0x120, 0x00000907);
+			break;
+		}
+		// toggle refresh_update_level
+		mmio_wr32(0x08004000 + 0x60, 0x00000002);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	} else {
+		rddata = mmio_rd32(0x08004000 + 0x0);
+		dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+		dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+		dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+		switch (dram_cap_in_mbyte_per_dev) {
+		case 5:
+			mmio_wr32(0x08004000 + 0x64, 0x00510019);
+			mmio_wr32(0x08004000 + 0x100, 0x0B011610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000502);
+			break;
+		case 6:
+			mmio_wr32(0x08004000 + 0x64, 0x0051002C);
+			mmio_wr32(0x08004000 + 0x100, 0x0A011610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000503);
+			break;
+		case 7:
+			mmio_wr32(0x08004000 + 0x64, 0x0051002B);
+			mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000503);
+			break;
+		case 8:
+			mmio_wr32(0x08004000 + 0x64, 0x00510041);
+			mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000504);
+			break;
+		case 9:
+			mmio_wr32(0x08004000 + 0x64, 0x0051006E);
+			mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000505);
+			break;
+		}
+
+		switch (dram_cap_in_mbyte_per_dev) {
+		case 5:
+			mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x204, 0x003F0606);
+			mmio_wr32(0x08004000 + 0x208, 0x00000000);
+			mmio_wr32(0x08004000 + 0x20c, 0x1F1F0000);
+			mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x214, 0x040F0404);
+			mmio_wr32(0x08004000 + 0x218, 0x04040404);
+			mmio_wr32(0x08004000 + 0x21c, 0x00000404);
+			mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+			mmio_wr32(0x08004000 + 0x224, 0x04040404);
+			mmio_wr32(0x08004000 + 0x228, 0x04040404);
+			mmio_wr32(0x08004000 + 0x22c, 0x001F1F04);
+			break;
+		case 6:
+			mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x204, 0x003F0707);
+			mmio_wr32(0x08004000 + 0x208, 0x00000000);
+			mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+			mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+			mmio_wr32(0x08004000 + 0x218, 0x05050505);
+			mmio_wr32(0x08004000 + 0x21c, 0x00000505);
+			mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+			mmio_wr32(0x08004000 + 0x224, 0x05050505);
+			mmio_wr32(0x08004000 + 0x228, 0x05050505);
+			mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+			break;
+		case 7:
+		case 8:
+		case 9:
+			mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x204, 0x00070707);
+			mmio_wr32(0x08004000 + 0x208, 0x00000000);
+			mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+			mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+			mmio_wr32(0x08004000 + 0x218, 0x06060606);
+			mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+			mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+			mmio_wr32(0x08004000 + 0x224, 0x06060606);
+			mmio_wr32(0x08004000 + 0x228, 0x06060606);
+			mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+			break;
+		}
+		// toggle refresh_update_level
+		mmio_wr32(0x08004000 + 0x60, 0x00000002);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	}
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/phy_init.c b/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/phy_init.c
new file mode 100644
index 0000000..581f2b8
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_config/ddr_auto_x16/phy_init.c
@@ -0,0 +1,280 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr2_1333_init.h>
+#include <ddr3_1866_init.h>
+#include <ddr_pkg_info.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	uint8_t ISDDR3 = 0;
+
+	if (get_ddr_type() == DDR_TYPE_DDR3)
+		ISDDR3 = 1;
+	else
+		ISDDR3 = 0;
+	NOTICE("ISDDR3=%d.\n", ISDDR3);
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_0_DATA : DDR2_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_1_DATA : DDR2_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_2_DATA : DDR2_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_3_DATA : DDR2_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_4_DATA : DDR2_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_5_DATA : DDR2_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_6_DATA : DDR2_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_7_DATA : DDR2_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_8_DATA : DDR2_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_9_DATA : DDR2_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_10_DATA : DDR2_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_11_DATA : DDR2_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_16_DATA : DDR2_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_17_DATA : DDR2_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_18_DATA : DDR2_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_19_DATA : DDR2_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_20_DATA : DDR2_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_21_DATA : DDR2_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_22_DATA : DDR2_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_23_DATA : DDR2_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_24_DATA : DDR2_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_25_DATA : DDR2_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_26_DATA : DDR2_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_28_DATA : DDR2_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_29_DATA : DDR2_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_32_DATA : DDR2_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_33_DATA : DDR2_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_34_DATA : DDR2_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_35_DATA : DDR2_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_36_DATA : DDR2_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_37_DATA : DDR2_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_40_DATA : DDR2_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_41_DATA : DDR2_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_42_DATA : DDR2_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_43_DATA : DDR2_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_44_DATA : DDR2_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_45_DATA : DDR2_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_46_DATA : DDR2_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_47_DATA : DDR2_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_60_DATA : DDR2_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_61_DATA : DDR2_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_62_DATA : DDR2_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_63_DATA : DDR2_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_64_DATA : DDR2_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_65_DATA : DDR2_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_67_DATA : DDR2_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_68_DATA : DDR2_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_69_DATA : DDR2_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_70_DATA : DDR2_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_71_DATA : DDR2_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_72_DATA : DDR2_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_73_DATA : DDR2_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_74_DATA : DDR2_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_75_DATA : DDR2_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_76_DATA : DDR2_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_77_DATA : DDR2_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_78_DATA : DDR2_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_80_DATA : DDR2_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_81_DATA : DDR2_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_82_DATA : DDR2_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_83_DATA : DDR2_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_84_DATA : DDR2_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_85_DATA : DDR2_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_86_DATA : DDR2_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_87_DATA : DDR2_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_89_DATA : DDR2_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_90_DATA : DDR2_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_91_DATA : DDR2_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_92_DATA : DDR2_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_93_DATA : DDR2_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_96_DATA : DDR2_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_97_DATA : DDR2_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_98_DATA : DDR2_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_99_DATA : DDR2_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_100_DATA : DDR2_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_128_DATA : DDR2_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_129_DATA : DDR2_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_130_DATA : DDR2_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_136_DATA : DDR2_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_137_DATA : DDR2_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_138_DATA : DDR2_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_0_F0_DATA : DDR2_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_1_F0_DATA : DDR2_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_2_F0_DATA : DDR2_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_3_F0_DATA : DDR2_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_4_F0_DATA : DDR2_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_5_F0_DATA : DDR2_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_6_F0_DATA : DDR2_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_7_F0_DATA : DDR2_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_64_F0_DATA : DDR2_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_65_F0_DATA : DDR2_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_66_F0_DATA : DDR2_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_67_F0_DATA : DDR2_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_68_F0_DATA : DDR2_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_69_F0_DATA : DDR2_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_70_F0_DATA : DDR2_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_71_F0_DATA : DDR2_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_72_F0_DATA : DDR2_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_80_F0_DATA : DDR2_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_81_F0_DATA : DDR2_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_82_F0_DATA : DDR2_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_83_F0_DATA : DDR2_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_84_F0_DATA : DDR2_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_85_F0_DATA : DDR2_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_86_F0_DATA : DDR2_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_87_F0_DATA : DDR2_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_88_F0_DATA : DDR2_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_320_F0_DATA : DDR2_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_331_F0_DATA : DDR2_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_332_F0_DATA : DDR2_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_333_F0_DATA : DDR2_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_334_F0_DATA : DDR2_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_336_F0_DATA : DDR2_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_348_F0_DATA : DDR2_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_349_F0_DATA : DDR2_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_350_F0_DATA : DDR2_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_351_F0_DATA : DDR2_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_352_F0_DATA : DDR2_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_384_F0_DATA : DDR2_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_385_F0_DATA : DDR2_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_386_F0_DATA : DDR2_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_387_F0_DATA : DDR2_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_388_F0_DATA : DDR2_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_389_F0_DATA : DDR2_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_390_F0_DATA : DDR2_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_391_F0_DATA : DDR2_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_392_F0_DATA : DDR2_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_393_F0_DATA : DDR2_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_394_F0_DATA : DDR2_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_395_F0_DATA : DDR2_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_396_F0_DATA : DDR2_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_397_F0_DATA : DDR2_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_398_F0_DATA : DDR2_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_399_F0_DATA : DDR2_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_400_F0_DATA : DDR2_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_401_F0_DATA : DDR2_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_402_F0_DATA : DDR2_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_403_F0_DATA : DDR2_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_404_F0_DATA : DDR2_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_405_F0_DATA : DDR2_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_406_F0_DATA : DDR2_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_407_F0_DATA : DDR2_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_408_F0_DATA : DDR2_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_409_F0_DATA : DDR2_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_410_F0_DATA : DDR2_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_411_F0_DATA : DDR2_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_412_F0_DATA : DDR2_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_413_F0_DATA : DDR2_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_414_F0_DATA : DDR2_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_415_F0_DATA : DDR2_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_448_F0_DATA : DDR2_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_449_F0_DATA : DDR2_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_450_F0_DATA : DDR2_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_451_F0_DATA : DDR2_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_452_F0_DATA : DDR2_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_453_F0_DATA : DDR2_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_454_F0_DATA : DDR2_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_455_F0_DATA : DDR2_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_456_F0_DATA : DDR2_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_457_F0_DATA : DDR2_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_460_F0_DATA : DDR2_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_461_F0_DATA : DDR2_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_462_F0_DATA : DDR2_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_463_F0_DATA : DDR2_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_464_F0_DATA : DDR2_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_465_F0_DATA : DDR2_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_466_F0_DATA : DDR2_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_467_F0_DATA : DDR2_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_468_F0_DATA : DDR2_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_469_F0_DATA : DDR2_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_0_F1_DATA : DDR2_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_1_F1_DATA : DDR2_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_2_F1_DATA : DDR2_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_3_F1_DATA : DDR2_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_4_F1_DATA : DDR2_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_5_F1_DATA : DDR2_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_6_F1_DATA : DDR2_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_7_F1_DATA : DDR2_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_64_F1_DATA : DDR2_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_65_F1_DATA : DDR2_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_66_F1_DATA : DDR2_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_67_F1_DATA : DDR2_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_68_F1_DATA : DDR2_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_69_F1_DATA : DDR2_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_70_F1_DATA : DDR2_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_71_F1_DATA : DDR2_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_72_F1_DATA : DDR2_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_80_F1_DATA : DDR2_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_81_F1_DATA : DDR2_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_82_F1_DATA : DDR2_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_83_F1_DATA : DDR2_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_84_F1_DATA : DDR2_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_85_F1_DATA : DDR2_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_86_F1_DATA : DDR2_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_87_F1_DATA : DDR2_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_88_F1_DATA : DDR2_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_320_F1_DATA : DDR2_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_331_F1_DATA : DDR2_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_332_F1_DATA : DDR2_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_333_F1_DATA : DDR2_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_334_F1_DATA : DDR2_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_336_F1_DATA : DDR2_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_348_F1_DATA : DDR2_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_349_F1_DATA : DDR2_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_350_F1_DATA : DDR2_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_351_F1_DATA : DDR2_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_352_F1_DATA : DDR2_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_384_F1_DATA : DDR2_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_385_F1_DATA : DDR2_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_386_F1_DATA : DDR2_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_387_F1_DATA : DDR2_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_388_F1_DATA : DDR2_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_389_F1_DATA : DDR2_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_390_F1_DATA : DDR2_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_391_F1_DATA : DDR2_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_392_F1_DATA : DDR2_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_393_F1_DATA : DDR2_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_394_F1_DATA : DDR2_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_395_F1_DATA : DDR2_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_396_F1_DATA : DDR2_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_397_F1_DATA : DDR2_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_398_F1_DATA : DDR2_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_399_F1_DATA : DDR2_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_400_F1_DATA : DDR2_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_401_F1_DATA : DDR2_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_402_F1_DATA : DDR2_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_403_F1_DATA : DDR2_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_404_F1_DATA : DDR2_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_405_F1_DATA : DDR2_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_406_F1_DATA : DDR2_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_407_F1_DATA : DDR2_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_408_F1_DATA : DDR2_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_409_F1_DATA : DDR2_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_410_F1_DATA : DDR2_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_411_F1_DATA : DDR2_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_412_F1_DATA : DDR2_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_413_F1_DATA : DDR2_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_414_F1_DATA : DDR2_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_415_F1_DATA : DDR2_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_448_F1_DATA : DDR2_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_449_F1_DATA : DDR2_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_450_F1_DATA : DDR2_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_451_F1_DATA : DDR2_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_452_F1_DATA : DDR2_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_453_F1_DATA : DDR2_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_454_F1_DATA : DDR2_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_455_F1_DATA : DDR2_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_456_F1_DATA : DDR2_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_457_F1_DATA : DDR2_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_460_F1_DATA : DDR2_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_461_F1_DATA : DDR2_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_462_F1_DATA : DDR2_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_463_F1_DATA : DDR2_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_464_F1_DATA : DDR2_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_465_F1_DATA : DDR2_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_466_F1_DATA : DDR2_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_467_F1_DATA : DDR2_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_468_F1_DATA : DDR2_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_469_F1_DATA : DDR2_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_pkg_info.c b/firmware/plat/cv180x/ddr/ddr_pkg_info.c
new file mode 100644
index 0000000..1ea2dba
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_pkg_info.c
@@ -0,0 +1,161 @@
+#include <platform_def.h>
+#include <ddr_pkg_info.h>
+#include <mmio.h>
+#include <bitwise_ops.h>
+#include <debug.h>
+
+uint8_t ddr_vendor;
+uint8_t ddr_capacity;
+uint8_t pkg;
+uint8_t ddr_type;
+
+void read_ddr_pkg_info(void)
+{
+#if defined(DDR_SIM)
+	uint32_t conf_info = SIM_CONF_INFO_VAL;
+	uint32_t efuse_leakage = 0;
+#elif defined(DDR_BRINGUP)
+	uint32_t conf_info = BRINGUP_CONF_INFO_VAL;
+	uint32_t efuse_leakage = 0;
+#else
+	uint32_t conf_info = mmio_read_32(0x03000004);
+	uint32_t efuse_leakage = mmio_read_32(0x03050108);
+#endif
+	uint32_t pkg_type;
+	uint32_t chip_id;
+
+#ifdef DDR_SIM
+	NOTICE("conf_info(0x03000004)=0x%08x\n", conf_info);
+#endif
+
+#if defined(DBG_SHMOO) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+	NOTICE("conf_info(0x03000004)=0x%08x\n", conf_info);
+	NOTICE("efuse_leakage(0x03050108)=0x%08x\n", efuse_leakage);
+	NOTICE("FTSN3=0x%08x\n", mmio_read_32(0x0305010C));
+	NOTICE("FTSN4=0x%08x\n", mmio_read_32(0x03050110));
+#endif // DBG_SHMOO || DBG_SHMOO_CA || DBG_SHMOO_CS
+
+	pkg_type = FIELD_GET(conf_info, 30, 28);
+	NOTICE("pkg_type=%x\n", pkg_type);
+
+	switch (pkg_type) {
+	case 0x0: //2nd src need to read from efuse
+		NOTICE("2nd\n");
+		ddr_vendor = FIELD_GET(efuse_leakage, 25, 21);
+		ddr_capacity = FIELD_GET(efuse_leakage, 28, 26);
+		pkg = FIELD_GET(efuse_leakage, 31, 29);
+		break;
+	case 0x2: //QFN68 7x7, SIP 1Gb DDR3
+		ddr_vendor = DDR_VENDOR_ESMT_1G;
+		ddr_capacity = DDR_CAPACITY_1G;
+		pkg = PKG_QFN68;
+		break;
+	case 0x3: //QFN68 7x7, SIP 512Mb DDR2(25nm)
+		ddr_vendor = DDR_VENDOR_ESMT_512M_DDR2;
+		ddr_capacity = DDR_CAPACITY_512M;
+		pkg = PKG_QFN68;
+		break;
+	case 0x4: //2nd src need to read from efuse
+		NOTICE("2nd\n");
+		ddr_vendor = FIELD_GET(efuse_leakage, 25, 21);
+		ddr_capacity = FIELD_GET(efuse_leakage, 28, 26);
+		pkg = FIELD_GET(efuse_leakage, 31, 29);
+		break;
+	case 0x6: //QFN9x9, SIP 1Gb DDR3
+		ddr_vendor = DDR_VENDOR_ESMT_1G;
+		ddr_capacity = DDR_CAPACITY_1G;
+		pkg = PKG_QFN88;
+		break;
+	case 0x7: //QFN9x9, SIP 512Mb DDR2(25nm)
+		ddr_vendor = DDR_VENDOR_ESMT_512M_DDR2;
+		ddr_capacity = DDR_CAPACITY_512M;
+		pkg = PKG_QFN88;
+		break;
+	default:
+		NOTICE("unknown pkg_type=0x%x\n", pkg_type);
+	}
+
+	NOTICE("D%x_%x_%x\n", pkg, ddr_capacity, ddr_vendor);
+
+	// assign ddr_type
+	switch (ddr_vendor) {
+	case DDR_VENDOR_ESMT_512M_DDR2:
+	case DDR_VENDOR_ETRON_512M_DDR2:
+		NOTICE("DDR2");
+		ddr_type = DDR_TYPE_DDR2;
+		ddr_data_rate = 1333;
+		break;
+	case DDR_VENDOR_NY_4G:
+	case DDR_VENDOR_NY_2G:
+	case DDR_VENDOR_ESMT_1G:
+	case DDR_VENDOR_ETRON_1G:
+	case DDR_VENDOR_ESMT_2G:
+	case DDR_VENDOR_PM_2G:
+	case DDR_VENDOR_PM_1G:
+	case DDR_VENDOR_ESMT_N25_1G:
+		NOTICE("DDR3");
+		ddr_type = DDR_TYPE_DDR3;
+		ddr_data_rate = 1866;
+		break;
+	default:
+		NOTICE("unknown vendor=%d", ddr_vendor);
+		ddr_type = DDR_TYPE_UNKNOWN;
+	}
+
+	switch (ddr_capacity) {
+	case DDR_CAPACITY_512M:
+		NOTICE("-512M");
+		chip_id = (pkg == PKG_QFN88 ? 0x1800c : 0x1800b);   //cv180x
+		break;
+	case DDR_CAPACITY_1G:
+		NOTICE("-1G");
+		chip_id = (pkg == PKG_QFN88 ? 0x1801c : 0x1801b);   //cv180x
+		break;
+	case DDR_CAPACITY_2G:
+		NOTICE("-2G");
+		chip_id = 0x0;//cv180x unknow chip id
+		break;
+	case DDR_CAPACITY_4G:
+		NOTICE("-4G");
+		chip_id = 0x0;//cv180x unknow chip id
+		break;
+	default:
+		NOTICE("-unknown capacity=%d", ddr_capacity);
+		chip_id = 0x0;
+	}
+	mmio_write_32(REG_GP_REG3, chip_id);
+
+	switch (pkg) {
+	case PKG_QFN88:
+		NOTICE("-QFN88\n");
+		break;
+	case PKG_QFN68:
+		NOTICE("-QFN68\n");
+		break;
+	case PKG_BGA:
+		NOTICE("-BGA\n");
+		break;
+	default:
+		NOTICE("-unknown pkg=%d", pkg);
+	}
+}
+
+uint8_t get_ddr_vendor(void)
+{
+	return ddr_vendor;
+}
+
+uint8_t get_ddr_capacity(void)
+{
+	return ddr_capacity;
+}
+
+uint8_t get_pkg(void)
+{
+	return pkg;
+}
+
+uint8_t get_ddr_type(void)
+{
+	return ddr_type;
+}
diff --git a/firmware/plat/cv180x/ddr/ddr_sys.c b/firmware/plat/cv180x/ddr/ddr_sys.c
new file mode 100644
index 0000000..c8f4f36
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_sys.c
@@ -0,0 +1,10834 @@
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+#include <bitwise_ops.h>
+#include <delay_timer.h>
+#include <cvx16_dram_cap_check.h>
+#include <cvx16_pinmux.h>
+#include <ddr_pkg_info.h>
+#include <regconfig.h>
+
+#define opdelay(_x) udelay((_x)/1000)
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
+// #pragma GCC diagnostic ignored "-Wunused-variable"
+
+uint32_t rddata;
+
+/*
+ * unused
+void check_rd32(uintptr_t addr, uint32_t expected)
+{
+	// uint32_t rdata;
+	// rdata = mmio_rd32(addr);
+	// if (rdata != expected)
+	//	mmio_wr32(TERM_SIM_ADDR, 0x0B0B0B0B); // fail
+}
+*/
+
+void ddr_debug_num_write(void)
+{
+	// debug_seqnum = debug_seqnum+1 ;
+	// mmio_wr32(4*(186 + PHY_BASE_ADDR)+CADENCE_PHYD,(debug_seqnum<<8));
+	// if (debug_seqnum ==255){ ;
+	// debug_seqnum1 = debug_seqnum1+1 ;
+	// mmio_wr32(4*(186 + PHY_BASE_ADDR)+CADENCE_PHYD,(debug_seqnum1<<8));
+	// debug_seqnum = 0 ;
+	// } ;
+}
+
+void load_ddr_patch_set_data(void)
+{
+#ifdef DDR_SIM
+	return;
+#endif
+	// NOTICE("ddr_patch_regs_count=%d\n", ddr_patch_regs_count);
+#ifndef DDR2_3
+	for (int i = 0; i < ddr_patch_regs_count; i++) {
+		uint32_t addr = ddr_patch_regs[i].addr;
+		uint32_t mask = ddr_patch_regs[i].mask;
+		uint32_t val = ddr_patch_regs[i].val;
+		uint32_t orig;
+
+		orig = mmio_rd32(addr);
+		orig &= ~mask;
+		mmio_wr32(addr, orig | (val & mask));
+	}
+#else
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		for (int i = 0; i < ddr3_1866_patch_regs_count; i++) {
+			uint32_t addr = ddr3_1866_patch_regs[i].addr;
+			uint32_t mask = ddr3_1866_patch_regs[i].mask;
+			uint32_t val = ddr3_1866_patch_regs[i].val;
+
+			uint32_t orig;
+
+			orig = mmio_rd32(addr);
+			orig &= ~mask;
+			mmio_wr32(addr, orig | (val & mask));
+		}
+	} else if (get_ddr_type() == DDR_TYPE_DDR2) {
+		for (int i = 0; i < ddr2_1333_patch_regs_count; i++) {
+			uint32_t addr = ddr2_1333_patch_regs[i].addr;
+			uint32_t mask = ddr2_1333_patch_regs[i].mask;
+			uint32_t val = ddr2_1333_patch_regs[i].val;
+
+			uint32_t orig;
+
+			orig = mmio_rd32(addr);
+			orig &= ~mask;
+			mmio_wr32(addr, orig | (val & mask));
+		}
+	} else {
+		NOTICE("error ddr type.\n");
+	}
+#endif
+}
+
+void ddr_patch_set(void)
+{
+	load_ddr_patch_set_data();
+
+#ifdef DDR3_DBG
+	mmio_wr32(0x005C + PHYD_BASE_ADDR, 0x00FE0000);//wrlvl response only DQ0
+#endif//DDR3_DBG
+}
+
+void cvx16_rdvld_train(void)
+{
+	uint32_t byte0_vld;
+	uint32_t byte1_vld;
+	uint32_t rdvld_offset;
+	uint32_t bist_result;
+	uint64_t err_data_odd;
+	uint64_t err_data_even;
+
+	cvx16_bist_wr_prbs_init();
+	// cvx16_bist_wr_sram_init();
+
+	byte0_vld = mmio_rd32(0x0B14 + PHYD_BASE_ADDR);
+	byte1_vld = mmio_rd32(0x0B44 + PHYD_BASE_ADDR);
+	rdvld_offset = mmio_rd32(0x0094 + PHYD_BASE_ADDR);
+	rdvld_offset = get_bits_from_value(rdvld_offset, 3, 0);
+
+	for (int i = 9; i > 1; i--) {
+		byte0_vld = modified_bits_by_value(byte0_vld, i, 20, 16);
+		mmio_wr32(0x0B14 + PHYD_BASE_ADDR, byte0_vld);
+		byte1_vld = modified_bits_by_value(byte1_vld, i, 20, 16);
+		mmio_wr32(0x0B44 + PHYD_BASE_ADDR, byte0_vld);
+		cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+
+		// KC_MSG(", bist_result = %x, err_data_odd = %x, err_data_even = %x\n",
+		//         bist_result,err_data_odd,err_data_even);
+		if (bist_result == 0) {
+			KC_MSG("vld end = %x, sel = %x", i, i + 1 + rdvld_offset);
+			i = i + 1 + rdvld_offset;
+			byte0_vld = modified_bits_by_value(byte0_vld, i, 20, 16);
+			mmio_wr32(0x0B14 + PHYD_BASE_ADDR, byte0_vld);
+			byte1_vld = modified_bits_by_value(byte1_vld, i, 20, 16);
+			mmio_wr32(0x0B44 + PHYD_BASE_ADDR, byte0_vld);
+			break;
+		}
+	}
+}
+
+void ddr_sys_suspend(void)
+{
+	uartlog("cvx16_ddr_sub_suspend\n");
+	// ddr_debug_wr32(0x3c);
+	// ddr_debug_num_write();
+	TJ_MSG("DDRC suspend start\n");
+
+	cvx16_ddrc_suspend();
+	TJ_MSG("DDRC suspend complete\n");
+
+	// save phyd setting to sram
+	cvx16_ddr_phyd_save(0x05026800);
+	// cvx16_ddr_phya_pd
+	cvx16_ddr_phya_pd();
+	// virtual_pwr_off();
+}
+
+void ddr_sys_resume(void)
+{
+	uint8_t dram_cap_in_mbyte;
+	// ddr_sub_resume1
+	// cvx16_ddr_sub_resume1();
+	// KC_MSG("ddr_sub_resume1\n");
+
+	// pll_init
+	cvx16_pll_init();
+	KC_MSG("pll_init_h finish\n");
+
+	// ctrl_init
+	ddrc_init();
+	KC_MSG("2nd ctrl_init_h finish\n");
+
+	// ddr_sub_resume2
+	cvx16_ddr_sub_resume2();
+	KC_MSG("ddr_sub_resume2\n");
+
+	// pinmux
+	//     cvx16_pinmux();
+	//     KC_MSG("cvx16_pinmux finish\n");
+
+	// ddr_sub_resume3
+	cvx16_ddr_sub_resume3();
+	KC_MSG("ddr_sub_resume3\n");
+
+	// ctrl_init_h.ctrl_high_patch=1;
+	//`uvm_send(ctrl_init_h);
+	ctrl_init_high_patch();
+
+	//    ctrl_init_detect_dram_size(&dram_cap_in_mbyte);
+	//    KC_MSG("ctrl_init_detect_dram_size finish\n");
+
+	// restory dram_cap_in_mbyte
+	rddata = mmio_rd32(0x0208 + PHYD_BASE_ADDR);
+	dram_cap_in_mbyte = rddata;
+
+	ctrl_init_update_by_dram_size(dram_cap_in_mbyte);
+	KC_MSG("ctrl_init_update_by_dram_size finish\n");
+
+	KC_MSG("dram_cap_in_mbyte = %x\n", dram_cap_in_mbyte);
+	cvx16_dram_cap_check(dram_cap_in_mbyte);
+	KC_MSG("cvx16_dram_cap_check finish\n");
+
+	// Write PCTRL.port_en = 1
+	for (int i = 0; i < 4; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+
+	//    ctrl_init_h.ctrl_high_patch=1;
+	//    `uvm_send(ctrl_init_h);
+
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_ddr_sub_resume2(void)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x44);
+	// ddr_debug_num_write();
+	//  Program INIT0.skip_dram_init = 0b11
+	rddata = mmio_rd32(cfg_base + 0xd0);
+	rddata = modified_bits_by_value(rddata, 0x3, 31, 30);
+	// rddata[31:30] = 0x3;
+	mmio_wr32(cfg_base + 0xd0, rddata);
+	// Program PWRCTL.selfref_sw = 0b1
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0x1, 5, 5);
+	// rddata[5:5] = 0x1;
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Program DFIMISC.dfi_init_complete_en to 1b0
+	rddata = mmio_rd32(cfg_base + 0x1b0);
+	rddata = modified_bits_by_value(rddata, 0x0, 0, 0);
+	// rddata[0:0] = 0x0;
+	mmio_wr32(cfg_base + 0x1b0, rddata);
+	// Remove the controller reset core_ddrc_rstn = 1b1 aresetn_n = 1b1
+	rddata = mmio_rd32(0x0800a020);
+	rddata = modified_bits_by_value(rddata, 0x0, 0, 0);
+	// rddata[0] = 0;
+	mmio_wr32(0x0800a020, rddata);
+}
+
+void cvx16_ddr_sub_resume3(void)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x45);
+	// ddr_debug_num_write();
+	// ddr_phyd_restore
+	cvx16_ddr_phyd_restore(0x05026800);
+	// setting_check
+	cvx16_setting_check();
+	KC_MSG("cvx16_setting_check  finish\n");
+
+	// ddr_phy_power_on_seq1
+	cvx16_ddr_phy_power_on_seq1();
+	// ddr_phy_power_on_seq2
+	cvx16_ddr_phy_power_on_seq2();
+	// set_dfi_init_start
+	cvx16_set_dfi_init_start();
+	// set_dfi_init_complete
+	cvx16_set_dfi_init_complete();
+	// synp setting
+	// deassert dfi_init_start, and enable the act on dfi_init_complete
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001b0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	// rddata[5] = 0b0;
+	mmio_wr32(cfg_base + 0x000001b0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	KC_MSG("dfi_init_complete finish\n");
+
+	// ddr_phy_power_on_seq3
+	cvx16_ddr_phy_power_on_seq3();
+	// Program SWCTL.sw_done = 0b0
+	rddata = mmio_rd32(cfg_base + 0x320);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	// rddata[0:0] = 0x0;
+	mmio_wr32(cfg_base + 0x320, rddata);
+	// Program DFIMISC.dfi_init_complete_en to 1b1
+	rddata = mmio_rd32(cfg_base + 0x1b0);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	// rddata[0:0] = 0x1;
+	mmio_wr32(cfg_base + 0x1b0, rddata);
+	// Program SWCTL.sw_done = 0b1
+	rddata = mmio_rd32(cfg_base + 0x320);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	// rddata[0:0] = 0x1;
+	mmio_wr32(cfg_base + 0x320, rddata);
+	// Program PWRCTL.selfref_sw = 1b0
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	// rddata[5:5] = 0x0;
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Poll STAT.selfref_type = 2b00
+	// do {
+	//    rddata = mmio_rd32(cfg_base + 0x4);
+	//} while (get_bits_from_value(rddata, 5, 4) != 0x0);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		if (get_bits_from_value(rddata, 5, 4) == 0x0) {
+			break;
+		}
+	}
+	// Poll STAT.operating_mode for Normal Mode entry
+	cvx16_polling_synp_normal_mode();
+}
+
+void cvx16_ddrc_suspend(void)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x40);
+	// ddr_debug_num_write();
+	//  Write 0 to PCTRL_n.port_en
+	for (int i = 0; i < 4; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	// do {
+	//    rddata = mmio_rd32(cfg_base+0x3fc);
+	//} while (rddata != 0);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// Write 1 to PWRCTL.selfref_sw
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x1;
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	mmio_wr32(cfg_base + 0x30, rddata);
+// Poll STAT.selfref_type= 2b10
+// Poll STAT.selfref_state = 0b10 (LPDDR4 only)
+#ifndef LP4
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		if (get_bits_from_value(rddata, 5, 4) == 0x2) {
+			break;
+		}
+	}
+#else
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		if (get_bits_from_value(rddata, 9, 8) == 0x2) {
+			break;
+		}
+	}
+#endif
+}
+
+void cvx16_bist_wr_prbs_init(void)
+{
+	// reg [31:0] cmd[5:0];
+	// reg [31:0] sram_st;
+	// reg [31:0] sram_sp;
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x23);
+	ddr_debug_num_write();
+	KC_MSG("bist_wr_prbs_init\n");
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	sram_sp = 511;
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // W  1~17  prbs  repeat0
+	cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // R  1~17  prbs  repeat0
+	cmd[2] = 0; // NOP
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("bist_wr_prbs_init done\n");
+	KC_MSG("bist_wr_prbs_init done\n");
+}
+
+void cvx16_bist_wr_sram_init(void)
+{
+	const int byte_per_page = 256;
+	int axi_per_page = byte_per_page / 64;
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x23);
+	ddr_debug_num_write();
+	KC_MSG("bist_wr_sram_init\n");
+
+	// bist clock enable, axi_len 8
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x000C000C);
+	sram_st = 0;
+	fmax = 15;
+	fmin = 5;
+	sram_st = 0;
+	sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+	KC_MSG("sram_sp = %x\n", sram_sp);
+
+	// bist sso_period
+	mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (15 << 0); // W  1~17  sram  repeat0
+	cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (15 << 0); // R  1~17  sram  repeat0
+	//       NOP idle
+	cmd[2] = 0; // NOP
+	//       GOTO      addr_not_reset loop_cnt
+	cmd[3] = (3 << 30) | (0 << 20) | (1 << 0); // GOTO
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step to 2KB
+	mmio_wr32(DDR_BIST_BASE + 0x18, 2048 / axi_per_page / 16);
+#else
+	// TBD
+#endif
+	uartlog("bist_wr_sram_init done\n");
+	KC_MSG("bist_wr_sram_init done\n");
+}
+
+void cvx16_bist_wrlvl_init(void)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x23);
+	ddr_debug_num_write();
+	KC_MSG_TR("%s\n", __func__);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	// sram_sp = 511;
+	sram_sp = 0;
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // W  1~17  prbs  repeat0
+	// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+	//          (0 << 0); // R  1~17  prbs  repeat0
+	cmd[1] = 0; // NOP
+	cmd[2] = 0; // NOP
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("bist_wr_prbs_init done\n");
+	KC_MSG_TR("bist_wr_prbs_init done\n");
+}
+
+void cvx16_bist_rdglvl_init(void)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x231);
+	ddr_debug_num_write();
+	KC_MSG("%s\n", __func__);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	// sram_sp = 511;
+	sram_sp = 3;
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	// cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+	//          (0 << 0);  // W  1~17  prbs  repeat0
+	cmd[0] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // R  1~17  prbs  repeat0
+	// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+	//          (0 << 0);  // R  1~17  prbs  repeat0
+	cmd[1] = 0; // NOP
+	cmd[2] = 0; // NOP
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s done\n", __func__);
+	KC_MSG("%s done\n", __func__);
+}
+
+void cvx16_bist_rdlvl_init(uint32_t mode)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	// uint32_t sram_dq[1024];
+	int i;
+
+	// mode = 0x0  : MPR mode, DDR3 only.
+	// mode = 0x1  : sram write/read continuous goto
+	// mode = 0x2  : multi- bist write/read
+	// mode = 0x12 : with Error enject,  multi- bist write/read
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x232);
+	ddr_debug_num_write();
+	KC_MSG("%s mode = %x\n", __func__, mode);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	if (mode == 0x0) { // MPR mode
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		// cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // W  1~17  prbs  repeat0
+		cmd[0] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // R  1~17  prbs  repeat0
+		cmd[1] = 0; // NOP
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x1) { // sram write/read continuous goto
+		fmax = 15;
+		fmin = 5;
+		sram_st = 0;
+		sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+		KC_MSG("sram_sp = %x\n", sram_sp);
+
+		// bist sso_period
+		mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+	#ifdef DDR_SIM
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0);  // W  1~17  sram  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0);  // R  1~17  sram  repeat0
+		//       NOP idle
+		cmd[2] = 1;
+		//       GOTO      addr_not_reset loop_cnt
+		cmd[3] = (3 << 30) | (0 << 20) | (1 << 0); //GOTO
+		cmd[4] = 0;  // NOP
+		cmd[5] = 0;  // NOP
+	#else
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  sram  repeat0
+		cmd[3] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  sram  repeat0
+		//       GOTO      addr_not_reset loop_cnt
+		cmd[4] = (3 << 30) | (0 << 20) | (1 << 0); // GOTO
+		cmd[5] = 0; // NOP
+	#endif
+	} else if (mode == 0x2) { // multi- bist write/read
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 7;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x12) { // with Error enject,  multi- bist write/read
+		//----for Error enject simulation only
+		rddata = mmio_rd32(0x0084 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x1d, 4, 0); // param_phyd_pirdlvl_trig_lvl_start
+		rddata = modified_bits_by_value(rddata, 0x1f, 12, 8); // param_phyd_pirdlvl_trig_lvl_end
+		mmio_wr32(0x0084 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 7;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x10) { // with Error enject,  multi- bist write/read
+		//----for Error enject simulation only
+		rddata = mmio_rd32(0x0084 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 4, 0); // param_phyd_pirdlvl_trig_lvl_start
+		rddata = modified_bits_by_value(rddata, 3, 12, 8); // param_phyd_pirdlvl_trig_lvl_end
+		mmio_wr32(0x0084 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		// cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // W  1~17  prbs  repeat0
+		cmd[0] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // R  1~17  prbs  repeat0
+		cmd[1] = 0; //NOP
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	}
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s\n", __func__);
+	KC_MSG("%s\n", __func__);
+}
+
+void cvx16_bist_wdqlvl_init(uint32_t mode)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	// uint32_t wdqlvl_vref_start; //unused
+	// uint32_t wdqlvl_vref_end; //unused
+	// uint32_t wdqlvl_vref_step; //unused
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x233);
+	ddr_debug_num_write();
+	KC_MSG("%s mode = %x\n", __func__, mode);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	if (mode == 0x0) { // phyd pattern
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x1) { // bist write/read
+		sram_st = 0;
+		fmax = 15;
+		fmin = 5;
+		sram_st = 0;
+		sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+		KC_MSG("sram_sp = %x\n", sram_sp);
+
+		// bist sso_period
+		mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+	#ifdef DDR_SIM
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0);  // W  1~17  sram  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0);  // R  1~17  sram  repeat0
+		//       NOP idle
+		cmd[2] = 0;  // NOP
+		//       GOTO      addr_not_reset loop_cnt
+		cmd[3] = (3 << 30) | (0 << 20) | (1 << 0); //GOTO
+		cmd[4] = 0;  // NOP
+		cmd[5] = 0;  // NOP
+	#else
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  sram  repeat0
+		cmd[3] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  sram  repeat0
+		//       GOTO      addr_not_reset loop_cnt
+		cmd[4] = (3 << 30) | (0 << 20) | (1 << 0); // GOTO
+		cmd[5] = 0; // NOP
+	#endif
+	} else if (mode == 0x11) { // bist write/read
+		//----for Error enject simulation only
+		rddata = 0x00000000;
+		rddata = modified_bits_by_value(rddata, 0x1, 6, 0); // param_phyd_dfi_wdqlvl_vref_start
+		rddata = modified_bits_by_value(rddata, 0x3, 14, 8); // param_phyd_dfi_wdqlvl_vref_end
+		rddata = modified_bits_by_value(rddata, 0x1, 19, 16); // param_phyd_dfi_wdqlvl_vref_step
+		mmio_wr32(0x0190 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x12) { // bist write/read
+		//----for Error enject simulation only
+		rddata = 0x00000000;
+		rddata = modified_bits_by_value(rddata, 0x1d, 6, 0); // param_phyd_dfi_wdqlvl_vref_start
+		rddata = modified_bits_by_value(rddata, 0x1f, 14, 8); // param_phyd_dfi_wdqlvl_vref_end
+		rddata = modified_bits_by_value(rddata, 0x1, 19, 16); // param_phyd_dfi_wdqlvl_vref_step
+		mmio_wr32(0x0190 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else {
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	}
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s done\n", __func__);
+	KC_MSG("%s done\n", __func__);
+}
+
+void cvx16_bist_wdmlvl_init(void)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x233);
+	ddr_debug_num_write();
+	KC_MSG("%s\n", __func__);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	fmax = 15;
+	fmin = 5;
+	sram_st = 0;
+	sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+	KC_MSG("sram_sp = %x\n", sram_sp);
+
+	// bist sso_period
+	mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (3 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // bist write pat 3 = 0x0f
+	cmd[1] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (7 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // bist write pat 7 = sso_8x1 DM toggle verison
+	cmd[2] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (7 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // bist read pat 7
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s done\n", __func__);
+	KC_MSG("%s done\n", __func__);
+}
+
+void cvx16_bist_start_check(uint32_t *bist_result, uint64_t *err_data_odd, uint64_t *err_data_even)
+{
+	uint64_t err_data_even_l;
+	uint64_t err_data_even_h;
+	uint64_t err_data_odd_l;
+	uint64_t err_data_odd_h;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x25);
+	ddr_debug_num_write();
+#ifdef X16_MODE
+	// bist enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00030003);
+	uartlog("bist start\n");
+	KC_MSG("bist start\n");
+
+#else
+	// bist enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+	uartlog("bist start\n");
+	KC_MSG("bist start\n");
+
+#endif
+	// polling bist done
+	//    while (get_bits_from_value(2)  == 0x0 = mmio_rd32(DDR_BIST_BASE + 0x80),2);
+	while (1) {
+		rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		if (get_bits_from_value(rddata, 2, 2) == 1) {
+			break;
+		}
+	}
+	uartlog("bist done\n");
+	KC_MSG("Read bist done %x ...\n", rddata);
+
+	if (get_bits_from_value(rddata, 3, 3) == 1) {
+		// opdelay(10);
+		*bist_result = 0;
+		uartlog("bist fail\n");
+		uartlog("err data\n");
+		// read err_data
+		err_data_odd_l = mmio_rd32(DDR_BIST_BASE + 0x88);
+		err_data_odd_h = mmio_rd32(DDR_BIST_BASE + 0x8c);
+		err_data_even_l = mmio_rd32(DDR_BIST_BASE + 0x90);
+		err_data_even_h = mmio_rd32(DDR_BIST_BASE + 0x94);
+		*err_data_odd = err_data_odd_h << 32 | err_data_odd_l;
+		*err_data_even = err_data_even_h << 32 | err_data_even_l;
+	} else {
+		// opdelay(10);
+		*bist_result = 1;
+		uartlog("bist pass\n");
+		*err_data_odd = 0;
+		*err_data_even = 0;
+	}
+	// bist disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00050000);
+}
+
+void cvx16_bist_tx_shift_delay(uint32_t shift_delay)
+{
+	uint32_t shift_tmp;
+	uint32_t delay_tmp;
+	// uint32_t oenz_shift_tmp; //unused
+	uint32_t oenz_lead;
+	uint32_t tdfi_phy_wrdata;
+	// uint32_t dlie_sum_great; //unused
+	uint32_t dlie_sub;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x26);
+	ddr_debug_num_write();
+	shift_tmp = get_bits_from_value(shift_delay, 13, 8);
+	delay_tmp = get_bits_from_value(shift_delay, 6, 0);
+	// tdfi_phy_wrdata
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	tdfi_phy_wrdata = get_bits_from_value(rddata, 2, 0);
+	oenz_lead = get_bits_from_value(rddata, 6, 3);
+	KC_MSG("shift_delay = %x, oenz_lead = %x, tdfi_phy_wrdata = %x\n", shift_delay, oenz_lead,
+	       tdfi_phy_wrdata);
+
+	if ((shift_tmp + (tdfi_phy_wrdata << 1)) > oenz_lead) {
+		dlie_sub = shift_tmp + (tdfi_phy_wrdata << 1) - oenz_lead;
+	} else {
+		dlie_sub = 0;
+	}
+	KC_MSG("dlie_sub = %x\n", dlie_sub);
+
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = (shift_tmp << 24) + (delay_tmp << 16) + (shift_tmp << 8) + delay_tmp;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(0x0A18 + i * 0x40 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, dlie_sub, 29, 24);
+		mmio_wr32(0x0A18 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_bist_rx_delay(uint32_t delay)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x27);
+	ddr_debug_num_write();
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, delay, 15, 8);
+		rddata = modified_bits_by_value(rddata, delay, 23, 16);
+		mmio_wr32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_bist_rx_deskew_delay(uint32_t delay)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x28);
+	ddr_debug_num_write();
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = (delay << 24) + (delay << 16) + (delay << 8) + delay;
+		mmio_wr32(0x0B00 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B04 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, delay, 6, 0);
+		mmio_wr32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_ca_shift_delay(uint32_t shift_delay)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x57);
+	ddr_debug_num_write();
+	rddata = (shift_delay << 16) + shift_delay;
+	mmio_wr32(0x0900 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0904  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0908  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x090C  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0910  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0914  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0918  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x091C  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0920  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0924  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0928  + PHYD_BASE_ADDR,  rddata);
+	mmio_wr32(0x092C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0930  + PHYD_BASE_ADDR,  rddata);//CKE
+	// mmio_wr32(0x0934  + PHYD_BASE_ADDR,  rddata);//cs
+	// mmio_wr32(0x0938  + PHYD_BASE_ADDR,  rddata);//reset_n
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_cs_shift_delay(uint32_t shift_delay)
+{
+	uartlog("cvx16_cs_shift_delay\n");
+	ddr_debug_wr32(0x57);
+	ddr_debug_num_write();
+	rddata = (shift_delay << 16) + shift_delay;
+	// mmio_wr32(0x0900 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0904 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0908 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x090C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0910 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0914 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0918 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x091C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0920 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0924 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0928 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x092C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0930 + PHYD_BASE_ADDR, rddata); //cke
+	mmio_wr32(0x0934 + PHYD_BASE_ADDR, rddata); //cs
+	// mmio_wr32(0x0938 + PHYD_BASE_ADDR, rddata); //reset_n
+	cvx16_dll_sw_clr();
+	KC_MSG("cvx16_cs_shift_delay Fisish\n");
+}
+
+void cvx16_synp_mrw(uint32_t addr, uint32_t data)
+{
+	uint32_t init_dis_auto_zq;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x21);
+	ddr_debug_num_write();
+	// ZQCTL0.dis_auto_zq to 1.
+	rddata = mmio_rd32(cfg_base + 0x180);
+	// if (rddata[31] == 0b0) {
+	if (get_bits_from_value(rddata, 31, 31) == 0) {
+		init_dis_auto_zq = 0;
+		// rddata[31] = 1;
+		rddata = modified_bits_by_value(rddata, 1, 31, 31);
+		mmio_wr32(cfg_base + 0x180, rddata);
+		uartlog("non-lp4 Write ZQCTL0.dis_auto_zq to 1\n");
+		// opdelay(256);
+		uartlog("Wait tzqcs = 128 cycles\n");
+	} else {
+		init_dis_auto_zq = 1;
+	}
+	// Poll MRSTAT.mr_wr_busy until it is 0
+	uartlog("Poll MRSTAT.mr_wr_busy until it is 0\n");
+	rddata = 0;
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x18);
+		if (get_bits_from_value(rddata, 0, 0) == 0) {
+			break;
+		}
+	}
+	uartlog("non-lp4 Poll MRSTAT.mr_wr_busy finish\n");
+	// Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs) MRCTRL1.mr_data
+	// rddata[31:0]  = 0;
+	// rddata[0]     = 0;       // mr_type  0:write   1:read
+	// rddata[5:4]   = 1;       // mr_rank
+	// rddata[15:12] = addr;    // mr_addr
+	rddata = modified_bits_by_value(rddata, 0, 31, 0);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 5, 4);
+	rddata = modified_bits_by_value(rddata, addr, 15, 12);
+	mmio_wr32(cfg_base + 0x10, rddata);
+	uartlog("non-lp4 Write the MRCTRL0\n");
+	// rddata[31:0] = 0;
+	// rddata[15:0] = data;     // mr_data
+	rddata = modified_bits_by_value(rddata, 0, 31, 0);
+	rddata = modified_bits_by_value(rddata, data, 31, 0);
+	mmio_wr32(cfg_base + 0x14, rddata);
+	uartlog("non-lp4 Write the MRCTRL1\n");
+	// Write MRCTRL0.mr_wr to 1
+	rddata = mmio_rd32(cfg_base + 0x10);
+	// rddata[31] = 1;
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x10, rddata);
+	uartlog("non-lp4 Write MRCTRL0.mr_wr to 1\n");
+	if (init_dis_auto_zq == 0) {
+		// ZQCTL0.dis_auto_zq to 0.
+		rddata = mmio_rd32(cfg_base + 0x180);
+		// rddata[31] = 0;
+		rddata = modified_bits_by_value(rddata, 0, 31, 31);
+		mmio_wr32(cfg_base + 0x180, rddata);
+		uartlog("non-lp4 Write ZQCTL0.dis_auto_zq to 0\n");
+	}
+}
+
+void cvx16_chg_pll_freq(void)
+{
+	uint32_t EN_PLL_SPEED_CHG;
+	uint32_t CUR_PLL_SPEED;
+	uint32_t NEXT_PLL_SPEED;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x04);
+	ddr_debug_num_write();
+	// Change PLL frequency
+	// TOP_REG_RESETZ_DIV =0
+	rddata = 0x00000000;
+	mmio_wr32(0x04 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_RESETZ_DQS =0
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_DDRPLL_MAS_RSTZ_DIV  =0
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 7, 7);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	uartlog("RSTZ_DIV=0\n");
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	EN_PLL_SPEED_CHG = get_bits_from_value(rddata, 0, 0);
+	CUR_PLL_SPEED = get_bits_from_value(rddata, 5, 4);
+	NEXT_PLL_SPEED = get_bits_from_value(rddata, 9, 8);
+	KC_MSG("CUR_PLL_SPEED = %x, NEXT_PLL_SPEED = %x, EN_PLL_SPEED_CHG=%x\n", CUR_PLL_SPEED, NEXT_PLL_SPEED,
+	       EN_PLL_SPEED_CHG);
+
+	if (EN_PLL_SPEED_CHG) {
+		if (NEXT_PLL_SPEED == 0) { // next clk_div40
+			rddata = modified_bits_by_value(rddata, NEXT_PLL_SPEED, 5, 4);
+			rddata = modified_bits_by_value(rddata, CUR_PLL_SPEED, 9, 8);
+			mmio_wr32(0x4c + CV_DDR_PHYD_APB, rddata);
+			cvx16_clk_div40();
+			uartlog("clk_div40\n");
+			KC_MSG("clk_div40\n");
+		} else {
+			if (NEXT_PLL_SPEED == 0x2) { // next clk normal
+				rddata = modified_bits_by_value(rddata, NEXT_PLL_SPEED, 5, 4);
+				rddata = modified_bits_by_value(rddata, CUR_PLL_SPEED, 9, 8);
+				mmio_wr32(0x4c + CV_DDR_PHYD_APB, rddata);
+				cvx16_clk_normal();
+				uartlog("clk_normal\n");
+				KC_MSG("clk_normal\n");
+			} else {
+				if (NEXT_PLL_SPEED == 0x1) { // next clk normal div_2
+					rddata = modified_bits_by_value(rddata, NEXT_PLL_SPEED, 5, 4);
+					rddata = modified_bits_by_value(rddata, CUR_PLL_SPEED, 9, 8);
+					mmio_wr32(0x4c + CV_DDR_PHYD_APB, rddata);
+					cvx16_clk_div2();
+					uartlog("clk_div2\n");
+					KC_MSG("clk_div2\n");
+				}
+			}
+		}
+		//         opdelay(100000);  //  1000ns
+	}
+	// TOP_REG_RESETZ_DIV  =1
+	rddata = 0x00000001;
+	mmio_wr32(0x04 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	// rddata[7]   = 1;    //TOP_REG_DDRPLL_MAS_RSTZ_DIV
+	rddata = modified_bits_by_value(rddata, 1, 7, 7);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	uartlog("RSTZ_DIV=1\n");
+	// rddata[0]   = 1;    //TOP_REG_RESETZ_DQS
+	rddata = 0x00000001;
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, rddata);
+	uartlog("TOP_REG_RESETZ_DQS\n");
+	KC_MSG("Wait for DRRPLL_SLV_LOCK=1...\n");
+
+#ifdef REAL_LOCK
+	rddata = modified_bits_by_value(rddata, 0, 15, 15);
+	while (get_bits_from_value(rddata, 15, 15) == 0) {
+		rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+		KC_MSG("REAL_LOCK.\n");
+
+		opdelay(200);
+	}
+#else
+	KC_MSG("check PLL lock...  pll init\n");
+
+#endif
+	//} Change PLL frequency
+}
+
+void cvx16_dll_cal(void)
+{
+	uint32_t EN_PLL_SPEED_CHG;
+	uint32_t CUR_PLL_SPEED;
+	uint32_t NEXT_PLL_SPEED;
+
+	KC_MSG("Do DLLCAL ...\n");
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2b);
+	ddr_debug_num_write();
+	// TOP_REG_EN_PLL_SPEED_CHG
+	//     <= #RD (~pwstrb_mask[0] & TOP_REG_EN_PLL_SPEED_CHG) |  pwstrb_mask_pwdata[0];
+	// TOP_REG_CUR_PLL_SPEED   [1:0]
+	//     <= #RD (~pwstrb_mask[5:4] & TOP_REG_CUR_PLL_SPEED[1:0]) |  pwstrb_mask_pwdata[5:4];
+	// TOP_REG_NEXT_PLL_SPEED  [1:0]
+	//     <= #RD (~pwstrb_mask[9:8] & TOP_REG_NEXT_PLL_SPEED[1:0]) |  pwstrb_mask_pwdata[9:8];
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	EN_PLL_SPEED_CHG = get_bits_from_value(rddata, 0, 0);
+	CUR_PLL_SPEED = get_bits_from_value(rddata, 5, 4);
+	NEXT_PLL_SPEED = get_bits_from_value(rddata, 9, 8);
+	KC_MSG("CUR_PLL_SPEED = %x, NEXT_PLL_SPEED = %x, EN_PLL_SPEED_CHG=%x\n", CUR_PLL_SPEED, NEXT_PLL_SPEED,
+	       EN_PLL_SPEED_CHG);
+
+	if (CUR_PLL_SPEED != 0) { // only do calibration and update when high speed
+		// param_phyd_dll_rx_start_cal <= int_regin[1];
+		// param_phyd_dll_tx_start_cal <= int_regin[17];
+		rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 17, 17);
+		mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+		// param_phyd_dll_rx_start_cal <= int_regin[1];
+		// param_phyd_dll_tx_start_cal <= int_regin[17];
+		rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 1, 1);
+		rddata = modified_bits_by_value(rddata, 1, 17, 17);
+		mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+		rddata = 0x00000000;
+		while (get_bits_from_value(rddata, 16, 16) == 0) {
+			rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		}
+		KC_MSG("DLL lock !\n");
+
+		uartlog("DLL lock\n");
+		// opdelay(1000);
+		uartlog("Do DLLUPD\n");
+		// cvx16_dll_cal_status();
+	} else { // stop calibration and update when low speed
+		// param_phyd_dll_rx_start_cal <= int_regin[1];
+		// param_phyd_dll_tx_start_cal <= int_regin[17];
+		rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 17, 17);
+		mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	}
+	KC_MSG("Do DLLCAL Finish\n");
+
+	uartlog("Do DLLCAL Finish\n");
+}
+
+void cvx16_dll_cal_phyd_hw(void)
+{
+	KC_MSG("Do DLLCAL phyd_hw ...\n");
+
+	uartlog("cvx16_dll_cal phyd_hw\n");
+	ddr_debug_wr32(0x2b);
+	ddr_debug_num_write();
+	KC_MSG("DLLCAL HW mode cntr_mode 0\n");
+
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0010, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0010, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("Do DLLCAL cntr_mode 0 Finish\n");
+
+	uartlog("Do DLLCAL cntr_mode 0 Finish\n");
+	// opdelay(1000);
+	KC_MSG("DLLCAL HW mode cntr_mode 1\n");
+
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0110, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0110, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("Do DLLCAL cntr_mode 1 Finish\n");
+
+	uartlog("Do DLLCAL cntr_mode 1 Finish\n");
+	// opdelay(1000);
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b1110, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b1110, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	uartlog("Do DLLCAL cntr_mode hwrst_time 1 Finish\n");
+}
+
+void cvx16_dll_cal_phya_enautok(void)
+{
+	KC_MSG("Do DLLCAL enautok ...\n");
+
+	uartlog("cvx16_dll_cal enautok\n");
+	ddr_debug_wr32(0x2b);
+	ddr_debug_num_write();
+	KC_MSG("DLLCAL enautok\n");
+
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_ddrdll_enautok [0]
+	// param_phya_reg_tx_ddrdll_enautok [16]
+	rddata = mmio_rd32(0x0140 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 16, 16);
+	mmio_wr32(0x0140 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("Do DLLCAL enautok\n");
+
+	uartlog("Do DLLCAL enautok Finish\n");
+}
+
+void cvx16_ddr_zqcal_isr8(void)
+{
+	uint32_t KP40_GOLDEN;
+	uint32_t KN40_GOLDEN;
+	uint32_t dram_class;
+	// uint32_t wr_odt_en; //unused
+	// uint32_t rtt_wr; //unused
+	int i;
+	// VDDQ_TXr       = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// ZQ clock on
+	rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 12, 12); // TOP_REG_CG_EN_ZQ
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	// param_phyd_zqcal_hw_mode       <= `PI_SD int_regin[24];
+	// sw mode
+	// param_phyd_zqcal_hw_mode = 0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_zqcal_done  <= `PI_SD int_regin[3];
+	rddata = mmio_rd32(0x0158 + PHYD_BASE_ADDR);
+	KC_MSG("Check ZQ Calibration param_phya_reg_zqcal_done = %x\n", get_bits_from_value(rddata, 14, 14));
+
+	if (get_bits_from_value(rddata, 0, 0) == 0) { // initial ZQCAL
+		rddata = mmio_rd32(0x0050 + PHYD_BASE_ADDR);
+		// dram_class = rddata[11:8];  //DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		dram_class = get_bits_from_value(
+			rddata, 3, 0); // DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		KC_MSG("dram_class = %x...\n", dram_class);
+
+		KC_MSG("DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011\n");
+
+		//    ->ydh_zq_event;
+		// a.
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+		// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 5, 5);
+		mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// b.
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+		rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+		// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+		rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// c.
+		// param_phya_reg_vref_pd  <= `PI_SD int_regin[9];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[9] = 0;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		// param_phya_reg_vref_sel[4:0] <= `PI_SD int_regin[14:10];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[14:10] = 0b01111;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		//    ->ydh_zq_event;
+		// d.
+		// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 0);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_SEL_GPIO
+		//      <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+		// TOP_REG_TX_GPIO_OENZ
+		//      <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+		rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 7, 6);
+		mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+		//------------------------------
+		// CMP offset Cal.
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x3, 4, 0);
+		rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+		rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		for (i = 0; i < 32; i = i + 1) {
+			// opdelay(128);
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 24, 24)) { // param_phya_to_reg_zq_cmp_out
+				rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 12, 8) < 0x1f) { // param_phya_reg_tx_zq_cmp_offset
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 12, 8) + 1), 12, 8);
+					mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration overflow - param_phya_reg_tx_zq_cmp_offset[4:0]: %x\n",
+					       get_bits_from_value(rddata, 12, 8));
+				}
+			} else {
+				rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 12, 8) > 0) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 12, 8) - 1), 12, 8);
+					mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration underflow - param_phya_reg_tx_zq_cmp_offset[4:0]: %x\n",
+					       get_bits_from_value(rddata, 12, 8));
+				}
+			}
+		}
+		//------------------------------
+		// ZQ PL
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		////param_phya_reg_tx_zq_drvn
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		for (i = 0; i < 32; i = i + 1) {
+			//        repeat(128) @(posedge clk);
+			// opdelay(128);
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 24, 24)) { // param_phya_to_reg_zq_cmp_out
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 20, 16) < 0x1f) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 20, 16) + 1), 20, 16);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration overflow - param_phya_reg_tx_zq_drvn[4:0]: %x\n",
+					       get_bits_from_value(rddata, 20, 16));
+				}
+			} else {
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 20, 16) > 0) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 20, 16) - 1), 20, 16);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration underflow - param_phya_reg_tx_zq_drvn[4:0]: %x\n",
+					       get_bits_from_value(rddata, 20, 16));
+				}
+			}
+		}
+		KN40_GOLDEN = get_bits_from_value(rddata, 20, 16);
+		//------------------------------
+		// ZQ PH
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x11, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		////param_phya_reg_tx_zq_drvp
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		for (i = 0; i < 32; i = i + 1) {
+			// opdelay(128);
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 24, 24)) { // param_phya_to_reg_zq_cmp_out
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 28, 24) > 0) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 28, 24) - 1), 28, 24);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration underflow - param_phya_reg_tx_zq_drvp[4:0]: %x\n",
+					       get_bits_from_value(rddata, 28, 24));
+				}
+			} else {
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 28, 24) < 0x1f) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 28, 24) + 1), 28, 24);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+				}
+			}
+		}
+		KP40_GOLDEN = get_bits_from_value(rddata, 28, 24);
+		//------------------------------
+		// ZQ Complete
+		//------------------------------
+		uartlog("hw_done\n");
+		// param_phya_reg_zqcal_done  <= `PI_SD int_regin[0];
+		rddata = 0x00000001;
+		mmio_wr32(0x0158 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+		// ZQ clock off
+		rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // TOP_REG_CG_EN_ZQ
+		mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("ZQ Complete ...\n");
+
+		cvx16_zqcal_status();
+	} //} initial ZQCAL
+	else {
+		KC_MSG("Not need ZQCAL\n");
+	}
+}
+
+void cvx16_ddr_zqcal_hw_isr8(uint32_t hw_mode)
+{
+	uint32_t dram_class;
+	// uint32_t wr_odt_en; //unused
+	// uint32_t rtt_wr; //unused
+	// int i; //unused
+
+	uartlog("ddr_zqcal_hw_isr8\n");
+	ddr_debug_wr32(0x2c);
+	ddr_debug_num_write();
+	// VDDQ_TXr        = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// ZQ clock on
+	rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 12, 12); // TOP_REG_CG_EN_ZQ
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	// param_phyd_zqcal_hw_mode =1
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, hw_mode, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_zqcal_done  <= `PI_SD int_regin[3];
+	rddata = mmio_rd32(0x0158 + PHYD_BASE_ADDR);
+	KC_MSG("Check ZQ Calibration param_phya_reg_zqcal_done = %x\n", get_bits_from_value(rddata, 0, 0));
+
+	if (get_bits_from_value(rddata, 0, 0) == 0) { // initial ZQCAL
+		rddata = mmio_rd32(0x0050 + PHYD_BASE_ADDR);
+		// dram_class = rddata[11:8];  //DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		dram_class = get_bits_from_value(
+			rddata, 3, 0); // DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		KC_MSG("dram_class = %x...\n", dram_class);
+
+		KC_MSG("DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011\n");
+
+		//    ->ydh_zq_event;
+		// a.
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+		// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 5, 5);
+		mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// b.
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+		rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+		// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+		rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// c.
+		// param_phya_reg_vref_pd  <= `PI_SD int_regin[9];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[9] = 0;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		// param_phya_reg_vref_sel[4:0] <= `PI_SD int_regin[14:10];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[14:10] = 0b01111;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		//    ->ydh_zq_event;
+		// d.
+		// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 0);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_SEL_GPIO
+		//     <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+		// TOP_REG_TX_GPIO_OENZ
+		//     <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+		rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 7, 6);
+		mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+		//------------------------------
+		// CMP offset Cal.
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("zq_cmp_en\n");
+
+		//------------------------------
+		// ZQ Complete
+		//------------------------------
+		uartlog("wait hw_done\n");
+		// param_phyd_to_reg_zqcal_hw_done
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		while (get_bits_from_value(rddata, 16, 16) == 0) {
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			KC_MSG("wait param_phyd_to_reg_zqcal_hw_done ...\n");
+
+			// opdelay(100);
+		}
+		uartlog("hw_done\n");
+		// param_phya_reg_zqcal_done  <= `PI_SD int_regin[0];
+		rddata = 0x00000001;
+		mmio_wr32(0x0158 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+		// param_phyd_zqcal_hw_mode =0
+		rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 18, 16);
+		mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+		// ZQ clock off
+		rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // TOP_REG_CG_EN_ZQ
+		mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("ZQ Complete ...\n");
+
+		cvx16_zqcal_status();
+	} else {
+		KC_MSG("Not need ZQCAL\n");
+	}
+}
+
+void cvx16_clk_normal(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x03);
+	ddr_debug_num_write();
+	KC_MSG("back to original frequency !!!\n\n");
+
+	rddata = mmio_rd32(0x0c + CV_DDR_PHYD_APB);
+	// rddata[13] TOP_REG_DDRPLL_SEL_LOW_SPEED 0
+	// rddata[14] TOP_REG_DDRPLL_MAS_DIV_OUT_SEL 0
+	rddata = modified_bits_by_value(rddata, 0, 13, 13);
+	rddata = modified_bits_by_value(rddata, 0, 14, 14);
+	mmio_wr32(0x0c + CV_DDR_PHYD_APB, rddata);
+#ifdef SSC_EN
+	//==============================================================
+	// Enable SSC
+	//==============================================================
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 1, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // extpulse
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_EN\n");
+#else
+#ifdef SSC_BYPASS
+	rddata = (reg_set & 0xfc000000) + 0x04000000; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 1, 6, 6); // ssc_syn_fix_div
+	uartlog("SSC_BYPASS\n");
+#else
+	//==============================================================
+	// SSC_EN =0
+	//==============================================================
+	uartlog("SSC_EN =0\n");
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_OFF\n");
+#endif // SSC_BYPASS
+#endif // SSC_EN
+	uartlog("back to original frequency\n");
+}
+
+void cvx16_clk_div2(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x01);
+	ddr_debug_num_write();
+	KC_MSG("div2 original frequency !!!\n\n");
+
+	rddata = mmio_rd32(0x0c + CV_DDR_PHYD_APB);
+	// rddata[14] = 1  ;  // TOP_REG_DDRPLL_MAS_DIV_OUT_SEL 1
+	rddata = modified_bits_by_value(rddata, 1, 14, 14);
+	mmio_wr32(0x0c + CV_DDR_PHYD_APB, rddata);
+	uartlog("div2 original frequency\n");
+}
+
+void cvx16_INT_ISR_08(void)
+{
+	uint32_t EN_PLL_SPEED_CHG;
+	uint32_t CUR_PLL_SPEED;
+	uint32_t NEXT_PLL_SPEED;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x1c);
+	ddr_debug_num_write();
+	// param_phyd_clkctrl_init_complete   <= int_regin[0];
+	rddata = 0x00000000;
+	mmio_wr32(0x0118 + PHYD_BASE_ADDR, rddata);
+	//----------------------------------------------------
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	EN_PLL_SPEED_CHG = get_bits_from_value(rddata, 0, 0);
+	CUR_PLL_SPEED = get_bits_from_value(rddata, 5, 4);
+	NEXT_PLL_SPEED = get_bits_from_value(rddata, 9, 8);
+	KC_MSG("CUR_PLL_SPEED = %x, NEXT_PLL_SPEED = %x, EN_PLL_SPEED_CHG=%x\n", CUR_PLL_SPEED, NEXT_PLL_SPEED,
+	       EN_PLL_SPEED_CHG);
+
+	//----------------------------------------------------
+	cvx16_ddr_phy_power_on_seq2();
+	cvx16_set_dfi_init_complete();
+}
+
+void cvx16_clk_div40(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x02);
+	ddr_debug_num_write();
+	KC_MSG("Enter low D40 frequency !!!\n\n");
+
+	rddata = mmio_rd32(0x0c + CV_DDR_PHYD_APB);
+	// TOP_REG_DDRPLL_SEL_LOW_SPEED =1
+	rddata = modified_bits_by_value(rddata, 1, 13, 13);
+	mmio_wr32(0x0c + CV_DDR_PHYD_APB, rddata);
+	uartlog("Enter low D40 frequency\n");
+}
+
+void cvx16_ddr_phy_power_on_seq1(void)
+{
+	// power_seq_1
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x0e);
+	ddr_debug_num_write();
+	// RESETZ/CKE PD=0
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	// TOP_REG_TX_CA_PD_CKE0
+	rddata = modified_bits_by_value(rddata, 0, 24, 24);
+	// TOP_REG_TX_CA_PD_RESETZ
+	rddata = modified_bits_by_value(rddata, 0, 30, 30);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("RESET PD !!!\n");
+
+	// CA PD=0
+	// All PHYA CA PD=0
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 0);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("All PHYA CA PD=0 ...\n");
+
+	// TOP_REG_TX_SEL_GPIO = 1 (DQ)
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 7, 7);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_SEL_GPIO = 1\n");
+
+	// DQ PD=0
+	// TOP_REG_TX_BYTE0_PD
+	// TOP_REG_TX_BYTE1_PD
+	rddata = 0x00000000;
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TX_BYTE PD=0 ...\n");
+
+	// TOP_REG_TX_SEL_GPIO = 0 (DQ)
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 7, 7);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_SEL_GPIO = 0\n");
+
+	// power_seq_1
+}
+
+void cvx16_ddr_phy_power_on_seq2(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x0f);
+	ddr_debug_num_write();
+	// Change PLL frequency
+	KC_MSG("Change PLL frequency if necessary ...\n");
+
+	cvx16_chg_pll_freq();
+	// OEN
+	// param_phyd_sel_cke_oenz        <= `PI_SD int_regin[0];
+	rddata = mmio_rd32(0x0154 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_tx_ca_oenz          <= `PI_SD int_regin[0];
+	// param_phyd_tx_ca_clk0_oenz     <= `PI_SD int_regin[8];
+	// param_phyd_tx_ca_clk1_oenz     <= `PI_SD int_regin[16];
+	rddata = 0x00000000;
+	mmio_wr32(0x0130 + PHYD_BASE_ADDR, rddata);
+	// Do DLLCAL if necessary
+	KC_MSG("Do DLLCAL if necessary ...\n");
+
+	cvx16_dll_cal();
+	KC_MSG("Do DLLCAL done\n");
+
+	//    KC_MSG("Do ZQCAL if necessary ...\n");
+
+	// cvx16_ddr_zqcal_hw_isr8(0x7);//zqcal hw mode, bit0: offset_cal, bit1:pl_en, bit2:step2_en
+	// KC_MSG("Do ZQCAL done\n");
+
+	KC_MSG("cv181x without ZQ Calibration ...\n");
+
+	// cvx16_ddr_zq240_cal();//zq240_cal
+	// KC_MSG("Do cvx16_ddr_zq240_cal done\n");
+
+	KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	// zq calculate variation
+	//  zq_cal_var();
+	KC_MSG("zq calculate variation not run\n");
+
+	// CA PD =0
+	// All PHYA CA PD=0
+	rddata = 0x80000000;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("All PHYA CA PD=0 ...\n");
+
+	// BYTE PD =0
+	rddata = 0x00000000;
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TX_BYTE PD=0 ...\n");
+
+	// power_on_2
+}
+
+void cvx16_ddr_phy_power_on_seq3(void)
+{
+	// power on 3
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x10);
+	ddr_debug_num_write();
+	// RESETYZ/CKE OENZ
+	// param_phyd_sel_cke_oenz        <= `PI_SD int_regin[0];
+	rddata = mmio_rd32(0x0154 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_tx_ca_oenz          <= `PI_SD int_regin[0];
+	// param_phyd_tx_ca_clk0_oenz     <= `PI_SD int_regin[8];
+	// param_phyd_tx_ca_clk1_oenz     <= `PI_SD int_regin[16];
+	rddata = 0x00000000;
+	mmio_wr32(0x0130 + PHYD_BASE_ADDR, rddata);
+	uartlog("[KC Info] --> ca_oenz  ca_clk_oenz !!!\n");
+
+	// clock gated for power save
+	// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_byte1_en_extend_oenz_gated_dline <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_byte2_en_extend_oenz_gated_dline <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_byte3_en_extend_oenz_gated_dline <= `PI_SD int_regin[3];
+	rddata = mmio_rd32(0x0204 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 18);
+	mmio_wr32(0x0204 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0224 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 18);
+	mmio_wr32(0x0224 + PHYD_BASE_ADDR, rddata);
+	uartlog("[KC Info] --> en clock gated for power save !!!\n");
+
+	// power on 3
+}
+
+void cvx16_wait_for_dfi_init_complete(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x13);
+	ddr_debug_num_write();
+	// synp setting
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x000001bc);
+		//} while ((rddata & 0x00000001) != 1);
+		if (get_bits_from_value(rddata, 0, 0) == 1) {
+			break;
+		}
+	}
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001b0);
+	rddata = modified_bits_by_value(rddata, 5, 5, 0);
+	mmio_wr32(cfg_base + 0x000001b0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	KC_MSG("dfi_init_complete finish\n");
+}
+
+void cvx16_ctrlupd_short(void)
+{
+	// ctrlupd short
+	uartlog("cvx16ctrlupd_short\n");
+	ddr_debug_wr32(0x2a);
+	ddr_debug_num_write();
+	// for gate track
+	// dis_auto_ctrlupd [31] =0, dis_auto_ctrlupd_srx [30] =0, ctrlupd_pre_srx [29] =1 @ 0x1a0
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	// original        rddata[31:29] = 0b001;
+	rddata = modified_bits_by_value(rddata, 1, 31, 29);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	// dfi_t_ctrlupd_interval_min_x1024 [23:16] = 4, dfi_t_ctrlupd_interval_max_x1024 [7:0] = 8 @ 0x1a4
+	rddata = mmio_rd32(cfg_base + 0x000001a4);
+	// original        rddata[23:16] = 0x04;
+	rddata = modified_bits_by_value(rddata, 4, 23, 16);
+	// original        rddata[7:0] = 0x08;
+	rddata = modified_bits_by_value(rddata, 8, 7, 0);
+	mmio_wr32(cfg_base + 0x000001a4, rddata);
+}
+
+void cvx16_polling_dfi_init_start(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x11);
+	ddr_debug_num_write();
+	while (1) {
+		rddata = mmio_rd32(0x3028 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 8, 8) == 1)) {
+			break;
+		}
+	}
+}
+
+void cvx16_set_dfi_init_complete(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x48);
+	ddr_debug_num_write();
+#ifdef REAL_LOCK
+	opdelay(20000);
+#endif
+	// rddata[8] = 1;
+	rddata = 0x00000010;
+	mmio_wr32(0x0120 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("set init_complete = 1 ...\n");
+
+	// param_phyd_clkctrl_init_complete   <= int_regin[0];
+	rddata = 0x00000001;
+	mmio_wr32(0x0118 + PHYD_BASE_ADDR, rddata);
+}
+
+void cvx16_polling_synp_normal_mode(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x14);
+	ddr_debug_num_write();
+	// synp ctrl operating_mode
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x00000004);
+		KC_MSG("operating_mode = %x\n", get_bits_from_value(rddata, 2, 0));
+
+		if (get_bits_from_value(rddata, 2, 0) == 1) {
+			break;
+		}
+	}
+}
+
+void cvx16_dfi_ca_park_prbs(uint32_t cap_enable)
+{
+	uint32_t dfi_ca_park_misc;
+	uint32_t dfi_ca_park_retain_cycle;
+	uint32_t dfi_ca_park_ca_ref;
+	uint32_t dfi_ca_park_ca_park;
+
+	// param_phyd_sw_dfi_phyupd_req =1
+	rddata = 0x00000001;
+	mmio_wr32(0x0174 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		// param_phyd_to_reg_dfi_phyupd_req  8   8
+		// param_phyd_to_reg_dfi_phyupd_ack  9   9
+		rddata = mmio_rd32(0x3030 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 9, 8) == 3) {
+			break;
+		}
+	}
+	// DDR3
+	//   cfg_det_en = 0b1;
+	//   cfg_cs_det_en = 0b1;
+	//   cap_prbs_en = 0b1;
+	//   cfg_cs_polarity = 0b1;
+	//   cap_prbs_1t = 0b0;
+	//   cfg_ca_reference = {0b0,0x0_ffff,0x7,0x0,0b1,0b0,0b1,0b1};
+	//   cfg_cs_retain_cycle = 0b0000_0001;
+	//   cfg_ca_retain_cycle = 0b0000_0000;
+	//   cfg_ca_park_value = 0x3fff_ffff;
+	if (cap_enable == 1) {
+		dfi_ca_park_misc = 0x1B;
+		mmio_wr32(DDR_TOP_BASE + 0x00, dfi_ca_park_misc);
+		KC_MSG("dfi_ca_park_prbs enable = 1\n");
+	} else {
+		dfi_ca_park_misc = 0x0;
+		mmio_wr32(DDR_TOP_BASE + 0x00, dfi_ca_park_misc);
+		KC_MSG("dfi_ca_park_prbs enable = 0\n");
+	}
+	dfi_ca_park_retain_cycle = 0x01;
+	mmio_wr32(DDR_TOP_BASE + 0x04, dfi_ca_park_retain_cycle);
+	dfi_ca_park_ca_ref = 0x1ffffcb;
+	mmio_wr32(DDR_TOP_BASE + 0x08, dfi_ca_park_ca_ref);
+	dfi_ca_park_ca_park = 0x3fffffff;
+	mmio_wr32(DDR_TOP_BASE + 0x0c, dfi_ca_park_ca_park);
+
+	// param_phyd_sw_dfi_phyupd_req_clr =1
+	rddata = 0x00000010;
+	mmio_wr32(0x0174 + PHYD_BASE_ADDR, rddata);
+}
+
+void cvx16_wrlvl_req(void)
+{
+#ifndef DDR2
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	uint32_t wr_odt_en;
+	uint32_t rtt_wr;
+	uint32_t rtt_nom;
+	uint32_t port_num;
+
+	// Note: training need ctrl_low_patch first
+	mmio_wr32(0x005C + PHYD_BASE_ADDR, 0x00FE0000); //wrlvl response only DQ0
+	// Write 0 to PCTRL_n.port_en, without port 0
+	// port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2e);
+	ddr_debug_num_write();
+	KC_MSG_TR("%s\n", __func__);
+
+	// save ctrl wr_odt_en
+	rddata = mmio_rd32(cfg_base + 0x244);
+	wr_odt_en = get_bits_from_value(rddata, 0, 0);
+	// bist setting for dfi wrlvl
+	cvx16_bist_wrlvl_init();
+	// // RFSHCTL3.dis_auto_refresh =1
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+#ifdef DDR3
+	rtt_nom = 0;
+	if (wr_odt_en == 1) {
+		KC_MSG_TR("wr_odt_en =1 ...\n");
+
+		// save rtt_wr
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rtt_wr = get_bits_from_value(rddata, 26, 25);
+		if (rtt_wr != 0x0) {
+			// disable rtt_wr
+			rddata = modified_bits_by_value(rddata, 0, 26, 25);
+			cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+			// set rtt_nom
+			rddata = mmio_rd32(cfg_base + 0xdc);
+			rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+			rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 1, 1), 6,
+							 6); // rtt_nom[1]=rtt_wr[1]
+			rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 0, 0), 2,
+							 2); // rtt_nom[1]=rtt_wr[0]
+			uartlog("dodt for wrlvl setting\n");
+		}
+	} else {
+		uartlog("rtt_nom for wrlvl setting\n");
+		KC_MSG_TR("wr_odt_en =0 ...\n");
+
+		// set rtt_nom = 120ohm
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+		rtt_nom = modified_bits_by_value(rtt_nom, 1, 6, 6); // rtt_nom[1]=1
+		rtt_nom = modified_bits_by_value(rtt_nom, 0, 2, 2); // rtt_nom[1]=0
+		cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+	}
+	rtt_nom = modified_bits_by_value(rtt_nom, 1, 7, 7); // Write leveling enable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+	KC_MSG_TR("DDR3 MRS rtt_nom ...\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rtt_nom = 0;
+		if (wr_odt_en == 1) {
+			KC_MSG_TR("wr_odt_en =1 ...\n");
+
+			// save rtt_wr
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rtt_wr = get_bits_from_value(rddata, 26, 25);
+			if (rtt_wr != 0x0) {
+				// disable rtt_wr
+				rddata = modified_bits_by_value(rddata, 0, 26, 25);
+				cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+				// set rtt_nom
+				rddata = mmio_rd32(cfg_base + 0xdc);
+				rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+				rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 1, 1), 6,
+								6); // rtt_nom[1]=rtt_wr[1]
+				rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 0, 0), 2,
+								2); // rtt_nom[1]=rtt_wr[0]
+				uartlog("dodt for wrlvl setting\n");
+			}
+		} else {
+			uartlog("rtt_nom for wrlvl setting\n");
+			KC_MSG_TR("wr_odt_en =0 ...\n");
+
+			// set rtt_nom = 120ohm
+			rddata = mmio_rd32(cfg_base + 0xdc);
+			rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+			rtt_nom = modified_bits_by_value(rtt_nom, 1, 6, 6); // rtt_nom[1]=1
+			rtt_nom = modified_bits_by_value(rtt_nom, 0, 2, 2); // rtt_nom[1]=0
+			cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+		}
+		rtt_nom = modified_bits_by_value(rtt_nom, 1, 7, 7); // Write leveling enable
+		cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+		KC_MSG_TR("DDR3 MRS rtt_nom ...\n");
+	}
+#endif
+#ifdef DDR4
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	rddata = modified_bits_by_value(rddata, 1, 7, 7); // Write leveling enable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+#endif
+	rddata = mmio_rd32(0x0180 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_wrlvl_req
+	rddata = modified_bits_by_value(rddata, wr_odt_en, 4, 4); // param_phyd_dfi_wrlvl_odt_en
+	mmio_wr32(0x0180 + PHYD_BASE_ADDR, rddata);
+	KC_MSG_TR("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 0, 0) == 0x1) {
+			// bist clock disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+			break;
+		}
+	}
+
+	// RFSHCTL3.dis_auto_refresh =0
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+	mmio_wr32(cfg_base + 0x60, rddata);
+
+#ifdef DDR3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rddata=modified_bits_by_value(rddata, 0, 7, 7); //Write leveling disable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2e);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// rddata=modified_bits_by_value(rddata, 0, 7, 7); //Write leveling disable
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+		uartlog("%s\n", __func__);
+		ddr_debug_wr32(0x2e);
+		ddr_debug_num_write();
+	}
+#endif
+#ifdef DDR4
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rddata=modified_bits_by_value(rddata, 0, 7, 7); //Write leveling disable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2e);
+	ddr_debug_num_write();
+#endif
+	// // RFSHCTL3.dis_auto_refresh =0
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_wrlvl_status();
+	cvx16_clk_gating_enable();
+#endif // not DDR2
+}
+
+void cvx16_rdglvl_req(void)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#ifdef DDR3
+	uint32_t ddr3_mpr_mode;
+#endif //DDR3
+#ifdef DDR2_3
+		uint32_t ddr3_mpr_mode;
+#endif
+	uint32_t port_num;
+	// Note: training need ctrl_low_patch first
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   // this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	// RFSHCTL3.dis_auto_refresh =1
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata=modified_bits_by_value(rddata, 1, 0, 0); //RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2f);
+	ddr_debug_num_write();
+	KC_MSG_TR("%s\n", __func__);
+
+#ifdef DDR3
+	rddata = mmio_rd32(0x0184 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (ddr3_mpr_mode) {
+		// RFSHCTL3.dis_auto_refresh =1
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+	}
+#endif
+#ifdef DDR2_3
+
+	rddata = mmio_rd32(0x0184 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// RFSHCTL3.dis_auto_refresh =1
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		}
+	}
+#endif
+	// bist setting for dfi rdglvl
+	cvx16_bist_rdglvl_init();
+	rddata = mmio_rd32(0x0184 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdglvl_req
+	mmio_wr32(0x0184 + PHYD_BASE_ADDR, rddata);
+	KC_MSG_TR("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 1, 1) == 0x1) {
+			// bist clock disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+			break;
+		}
+	}
+#ifdef DDR3
+	if (ddr3_mpr_mode) {
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		// RFSHCTL3.dis_auto_refresh =0
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+	}
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2f);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+			// RFSHCTL3.dis_auto_refresh =0
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+		}
+		uartlog("%s\n", __func__);
+		ddr_debug_wr32(0x2f);
+		ddr_debug_num_write();
+	}
+#endif
+	// RFSHCTL3.dis_auto_refresh =0
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata=modified_bits_by_value(rddata, 0, 0, 0); //RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_rdglvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_rdlvl_req(uint32_t mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#ifdef DDR3
+	uint32_t ddr3_mpr_mode;
+#endif //DDR3
+#ifdef DDR2_3
+	uint32_t ddr3_mpr_mode;
+#endif
+	uint32_t port_num;
+	uint32_t vref_training_en;
+	// uint32_t code_neg; //unused
+	// uint32_t code_pos; //unused
+	// Note: training need ctrl_low_patch first
+	// mode = 0x0  : MPR mode, DDR3 only.
+	// mode = 0x1  : sram write/read continuous goto
+	// mode = 0x2  : multi- bist write/read
+	// mode = 0x10 : with Error enject,  multi- bist write/read
+	// mode = 0x12 : with Error enject,  multi- bist write/read
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	//    //RFSHCTL3.dis_auto_refresh =1
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 1, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("%s\n", __func__);
+
+	//deskew start from 0x20
+	rddata = mmio_rd32(0x0080 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x20, 22, 16); //param_phyd_pirdlvl_deskew_start
+	rddata = modified_bits_by_value(rddata, 0x1F, 30, 24); //param_phyd_pirdlvl_deskew_end
+	mmio_wr32(0x0080 + PHYD_BASE_ADDR,  rddata);
+
+	// save param_phyd_pirdlvl_vref_training_en
+	rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+	vref_training_en = get_bits_from_value(rddata, 2, 2);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_pirdlvl_rx_init_deskew_en
+	rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // param_phyd_pirdlvl_rdvld_training_en = 0
+	mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+#ifdef DDR3
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (ddr3_mpr_mode) {
+		// RFSHCTL3.dis_auto_refresh =1
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+	}
+#endif
+#ifdef DDR2_3
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// RFSHCTL3.dis_auto_refresh =1
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		}
+	}
+#endif
+	// bist setting for dfi rdglvl
+	cvx16_bist_rdlvl_init(mode);
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+	mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dfi_rdlvl_req 1\n");
+
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+			break;
+		}
+	}
+	if (vref_training_en == 0x1) {
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+		// final training, keep rx trig_lvl
+		KC_MSG("final training, keep rx trig_lvl\n");
+
+		rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+		mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("dfi_rdlvl_req 2\n");
+
+		KC_MSG("wait retraining finish ...\n");
+
+		while (1) {
+			//[0] param_phyd_dfi_wrlvl_done
+			//[1] param_phyd_dfi_rdglvl_done
+			//[2] param_phyd_dfi_rdlvl_done
+			//[3] param_phyd_dfi_wdqlvl_done
+			rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+				break;
+			}
+		}
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref_training_en, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+	}
+
+#ifdef DDR3
+	if (ddr3_mpr_mode) {
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		// RFSHCTL3.dis_auto_refresh =0
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+	}
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+			// RFSHCTL3.dis_auto_refresh =0
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+		}
+		uartlog("%s\n", __func__);
+		ddr_debug_wr32(0x30);
+		ddr_debug_num_write();
+	}
+#endif
+
+	cvx16_rdvld_train();
+
+	//    //RFSHCTL3.dis_auto_refresh =0
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 0, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_rdlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_rdlvl_sw_req(uint32_t mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#ifdef DDR3
+	uint32_t ddr3_mpr_mode;
+#endif //DDR3
+#ifdef DDR2_3
+	uint32_t ddr3_mpr_mode;
+#endif
+	uint32_t port_num;
+	uint32_t vref_training_en;
+	uint32_t byte0_pirdlvl_sw_upd_ack;
+	uint32_t byte1_pirdlvl_sw_upd_ack;
+	uint32_t rx_vref_sel;
+	uint32_t byte0_data_rise_fail;
+	uint32_t byte0_data_fall_fail;
+	uint32_t byte1_data_rise_fail;
+	uint32_t byte1_data_fall_fail;
+	uint32_t dlie_code;
+	uint32_t byte0_all_le_found;
+	uint32_t byte0_all_te_found;
+	uint32_t byte1_all_le_found;
+	uint32_t byte1_all_te_found;
+	// uint32_t code_neg; //unused
+	// uint32_t code_pos; //unused
+	uint32_t byte0_cur_pirdlvl_st;
+	uint32_t byte1_cur_pirdlvl_st;
+	uint32_t sw_upd_req_start;
+
+	sw_upd_req_start = 0;
+	// mode = 0x0  : MPR mode, DDR3 only.
+	// mode = 0x1  : sram write/read continuous goto
+	// mode = 0x2  : multi- bist write/read
+	// mode = 0x10 : with Error enject,  multi- bist write/read
+	// mode = 0x12 : with Error enject,  multi- bist write/read
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	//    //RFSHCTL3.dis_auto_refresh =1
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 1, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("%s\n", __func__);
+
+	//deskew start from 0x20
+	rddata = mmio_rd32(0x0080 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x20, 22, 16); //param_phyd_pirdlvl_deskew_start
+	rddata = modified_bits_by_value(rddata, 0x1F, 30, 24); //param_phyd_pirdlvl_deskew_end
+	mmio_wr32(0x0080 + PHYD_BASE_ADDR,  rddata);
+
+	// save param_phyd_pirdlvl_vref_training_en
+	rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+	vref_training_en = get_bits_from_value(rddata, 2, 2);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_pirdlvl_rx_init_deskew_en
+	rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // param_phyd_pirdlvl_rdvld_training_en = 0
+	mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+
+#ifdef DDR3
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (ddr3_mpr_mode) {
+		// RFSHCTL3.dis_auto_refresh =1
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+	}
+#endif
+#ifdef DDR2_3
+
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// RFSHCTL3.dis_auto_refresh =1
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		}
+	}
+#endif
+
+	// bist setting for dfi rdglvl
+	cvx16_bist_rdlvl_init(mode);
+	// SW mode
+	rddata = mmio_rd32(0x0090 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 9, 9); // param_phyd_pirdlvl_sw
+	mmio_wr32(0x0090 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+	mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dfi_rdlvl_req 1\n");
+
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+			break;
+		}
+		while (1) {
+			rddata = mmio_rd32(0x31B0 + PHYD_BASE_ADDR);
+			byte0_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte0_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte0_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte0_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			rddata = mmio_rd32(0x31B0 + 0x40 + PHYD_BASE_ADDR);
+			byte1_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte1_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte1_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte1_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			KC_MSG("=1 byte0_pirdlvl_sw_upd_ack = %x, byte1_pirdlvl_sw_upd_ack = %x\n",
+			       byte0_pirdlvl_sw_upd_ack, byte1_pirdlvl_sw_upd_ack);
+
+			if ((byte0_all_le_found == 0) && (byte0_all_te_found == 0) && (byte1_all_le_found == 0) &&
+			    (byte1_all_te_found == 0)) {
+				sw_upd_req_start = 0x1;
+			} else {
+				if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+				    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1) &&
+				    ((byte0_cur_pirdlvl_st == 0x0) && (byte1_cur_pirdlvl_st == 0x0))) {
+					sw_upd_req_start = 0x0;
+				}
+			}
+			// KC_MSG("sw_upd_req_start = %x\n", sw_upd_req_start);
+
+			if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte0_all_le_found & byte0_all_te_found)) &&
+			    ((byte1_pirdlvl_sw_upd_ack == 0x1) || (byte1_all_le_found & byte1_all_te_found))) {
+				rddata = mmio_rd32(0x0B24 + PHYD_BASE_ADDR);
+				rx_vref_sel = get_bits_from_value(rddata, 4, 0);
+				rddata = mmio_rd32(0x0B08 + PHYD_BASE_ADDR);
+				dlie_code = get_bits_from_value(rddata, 15, 8);
+				rddata = mmio_rd32(0x31B4 + PHYD_BASE_ADDR);
+				if (byte0_all_te_found) {
+					byte0_data_rise_fail = 0xff;
+					byte0_data_fall_fail = 0xff;
+				} else {
+					byte0_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+					byte0_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				rddata = mmio_rd32(0x31B4 + 0x40 + PHYD_BASE_ADDR);
+				if (byte1_all_te_found) {
+					byte1_data_rise_fail = 0xff;
+					byte1_data_fall_fail = 0xff;
+				} else {
+					byte1_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+					byte1_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+				    ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+					SHMOO_MSG("vref = %02x, sw_rdq_training_start = %08x , ",
+						  rx_vref_sel, dlie_code);
+					SHMOO_MSG("err_data_rise/err_data_fall = %08x, %08x\n",
+						  ((byte0_data_rise_fail & 0x000000FF) |
+						   ((byte1_data_rise_fail & 0x000000FF) << 8)),
+						   ((byte0_data_fall_fail & 0x000000FF) |
+						   ((byte1_data_fall_fail & 0x000000FF) << 8)));
+				}
+				//if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1))
+				//    || ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+				if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+				    (sw_upd_req_start == 0x1)) {
+					rddata = mmio_rd32(0x0090 + PHYD_BASE_ADDR);
+					rddata = modified_bits_by_value(rddata, 1, 10,
+									10); // param_phyd_pirdlvl_sw_upd_req
+					mmio_wr32(0x0090 + PHYD_BASE_ADDR, rddata);
+				}
+				KC_MSG("byte0_all_le_found, byte0_all_te_found, ");
+				KC_MSG("byte1_all_le_found, byte1_all_te_found");
+				KC_MSG(" =%x %x %x %x\n",
+				       byte0_all_le_found, byte0_all_te_found,
+				       byte1_all_le_found, byte1_all_te_found);
+
+				break;
+			}
+			if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+			    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1)) {
+				break;
+			}
+
+			rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+				break;
+			}
+		}
+	}
+	if (vref_training_en == 0x1) {
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+		// final training, keep rx trig_lvl
+		KC_MSG("final training, keep rx trig_lvl\n");
+
+		rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+		mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("dfi_rdlvl_req 2\n");
+
+		KC_MSG("wait retraining finish ...\n");
+
+		while (1) {
+			rddata = mmio_rd32(0x31B0 + PHYD_BASE_ADDR);
+			byte0_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte0_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte0_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte0_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			rddata = mmio_rd32(0x31B0 + 0x40 + PHYD_BASE_ADDR);
+			byte1_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte1_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte1_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte1_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			KC_MSG("Wait all_found clear  ");
+			KC_MSG("byte0_all_le_found | byte0_all_te_found = %x, ",
+			       (byte0_all_le_found | byte0_all_te_found));
+			KC_MSG("byte1_all_le_found | byte1_all_te_found = %x\n",
+			       (byte1_all_le_found | byte1_all_te_found));
+
+			if ((byte0_all_le_found == 0) && (byte0_all_te_found == 0) &&
+			    (byte1_all_le_found == 0) && (byte1_all_te_found == 0)) {
+				break;
+			}
+		}
+		while (1) {
+			//[0] param_phyd_dfi_wrlvl_done
+			//[1] param_phyd_dfi_rdglvl_done
+			//[2] param_phyd_dfi_rdlvl_done
+			//[3] param_phyd_dfi_wdqlvl_done
+			rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+				break;
+			}
+			while (1) {
+				rddata = mmio_rd32(0x31B0 + PHYD_BASE_ADDR);
+				byte0_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+				byte0_all_le_found =
+					get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+				byte0_all_te_found =
+					get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+				byte0_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+				rddata = mmio_rd32(0x31B0 + 0x40 + PHYD_BASE_ADDR);
+				byte1_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+				byte1_all_le_found =
+					get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+				byte1_all_te_found =
+					get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+				byte1_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+				KC_MSG("=1 byte0_pirdlvl_sw_upd_ack = %x, byte1_pirdlvl_sw_upd_ack = %x\n",
+				       byte0_pirdlvl_sw_upd_ack, byte1_pirdlvl_sw_upd_ack);
+
+				if ((byte0_all_le_found == 0) && (byte0_all_te_found == 0) &&
+				    (byte1_all_le_found == 0) && (byte1_all_te_found == 0)) {
+					sw_upd_req_start = 0x1;
+				} else {
+					if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+					    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1) &&
+					    ((byte0_cur_pirdlvl_st == 0x0) && (byte1_cur_pirdlvl_st == 0x0))) {
+						sw_upd_req_start = 0x0;
+					}
+				}
+				// KC_MSG("sw_upd_req_start = %x\n", sw_upd_req_start);
+
+				if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte0_all_le_found & byte0_all_te_found)) &&
+				    ((byte1_pirdlvl_sw_upd_ack == 0x1) || (byte1_all_le_found & byte1_all_te_found))) {
+					//if ((byte0_pirdlvl_sw_upd_ack == 0x1) && (byte1_pirdlvl_sw_upd_ack == 0x1)) {
+					rddata = mmio_rd32(0x0B24 + PHYD_BASE_ADDR);
+					rx_vref_sel = get_bits_from_value(rddata, 4, 0);
+					rddata = mmio_rd32(0x0B08 + PHYD_BASE_ADDR);
+					dlie_code = get_bits_from_value(rddata, 15, 8);
+					rddata = mmio_rd32(0x31B4 + PHYD_BASE_ADDR);
+					if (byte0_all_te_found) {
+						byte0_data_rise_fail = 0xff;
+						byte0_data_fall_fail = 0xff;
+					} else {
+						byte0_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+						byte0_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+					}
+					rddata = mmio_rd32(0x31B4 + 0x40 + PHYD_BASE_ADDR);
+					if (byte1_all_te_found) {
+						byte1_data_rise_fail = 0xff;
+						byte1_data_fall_fail = 0xff;
+					} else {
+						byte1_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+						byte1_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+					}
+					if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+					    ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+						SHMOO_MSG("vref = %02x, sw_rdq_training_start = %08x , ",
+							  rx_vref_sel, dlie_code);
+						SHMOO_MSG("err_data_rise/err_data_fall = %08x, %08x\n",
+						       ((byte0_data_rise_fail & 0x000000FF) |
+							((byte1_data_rise_fail & 0x000000FF) << 8)),
+						       ((byte0_data_fall_fail & 0x000000FF) |
+							((byte1_data_fall_fail & 0x000000FF) << 8)));
+					}
+					// if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1))
+					//     || ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+					if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+					    (sw_upd_req_start == 0x1)) {
+						rddata = mmio_rd32(0x0090 + PHYD_BASE_ADDR);
+						rddata = modified_bits_by_value(rddata, 1, 10,
+										10); // param_phyd_pirdlvl_sw_upd_req
+						mmio_wr32(0x0090 + PHYD_BASE_ADDR, rddata);
+					}
+					KC_MSG("byte0_all_le_found, byte0_all_te_found, ");
+					KC_MSG("byte1_all_le_found, byte1_all_te_found");
+					KC_MSG(" =%x %x %x %x\n",
+					       byte0_all_le_found, byte0_all_te_found,
+					       byte1_all_le_found, byte1_all_te_found);
+
+					break;
+				}
+				if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+				    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1)) {
+					break;
+				}
+
+				rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+					break;
+				}
+			}
+		}
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref_training_en, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+	}
+
+#ifdef DDR3
+	if (ddr3_mpr_mode) {
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		// RFSHCTL3.dis_auto_refresh =0
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+	}
+	uartlog("cvx16_rdlvl_req\n");
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+			// RFSHCTL3.dis_auto_refresh =0
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+		}
+		uartlog("cvx16_rdlvl_req\n");
+		ddr_debug_wr32(0x30);
+		ddr_debug_num_write();
+	}
+#endif
+
+	cvx16_rdvld_train();
+
+	//    //RFSHCTL3.dis_auto_refresh =0
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 0, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_rdlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_wdqlvl_req(uint32_t data_mode, uint32_t lvl_mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	// uint32_t bist_data_mode; //unused
+	uint32_t port_num;
+	// Note: training need ctrl_low_patch first
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	uartlog("cvx16_wdqlvl_req\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("cvx16_wdqlvl_req\n");
+
+	// param_phyd_piwdqlvl_dq_mode
+	//     <= #RD (~pwstrb_mask[12] & param_phyd_piwdqlvl_dq_mode) |  pwstrb_mask_pwdata[12];
+	// param_phyd_piwdqlvl_dm_mode
+	//     <= #RD (~pwstrb_mask[13] & param_phyd_piwdqlvl_dm_mode) |  pwstrb_mask_pwdata[13];
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	// lvl_mode =0x0, wdmlvl
+	// lvl_mode =0x1, wdqlvl
+	// lvl_mode =0x2, wdqlvl and wdmlvl
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x1) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 0, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x2) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	}
+	mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+	if (lvl_mode == 0x0) {
+		rddata = mmio_rd32(cfg_base + 0xC);
+		rddata = modified_bits_by_value(rddata, 1, 7, 7);
+		mmio_wr32(cfg_base + 0xC, rddata);
+		//        cvx16_bist_wdmlvl_init(sram_sp);
+		cvx16_bist_wdmlvl_init();
+	} else {
+		// bist setting for dfi rdglvl
+		// data_mode = 0x0 : phyd pattern
+		// data_mode = 0x1 : bist read/write
+		// data_mode = 0x11: with Error enject,  multi- bist write/read
+		// data_mode = 0x12: with Error enject,  multi- bist write/read
+		//         cvx16_bist_wdqlvl_init(data_mode, sram_sp);
+		cvx16_bist_wdqlvl_init(data_mode);
+	}
+	uartlog("cvx16_wdqlvl_req\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x018C + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_wdqlvl_req
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 1, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	}
+	if ((data_mode == 0x1) || (data_mode == 0x11) || (data_mode == 0x12)) {
+		rddata = modified_bits_by_value(rddata, 1, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 0, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	}
+	mmio_wr32(0x018C + PHYD_BASE_ADDR, rddata);
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 3, 3) == 0x1) {
+			break;
+		}
+	}
+	rddata = mmio_rd32(cfg_base + 0xC);
+	rddata = modified_bits_by_value(rddata, 0, 7, 7);
+	mmio_wr32(cfg_base + 0xC, rddata);
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_wdqlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_wdqlvl_sw_req(uint32_t data_mode, uint32_t lvl_mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	// uint32_t bist_data_mode; //unused
+	uint32_t port_num;
+	uint32_t byte0_piwdqlvl_sw_upd_ack;
+	uint32_t byte1_piwdqlvl_sw_upd_ack;
+	uint32_t tx_vref_sel;
+	uint32_t byte0_data_rise_fail;
+	uint32_t byte0_data_fall_fail;
+	uint32_t byte1_data_rise_fail;
+	uint32_t byte1_data_fall_fail;
+	uint32_t dlie_code;
+	uint32_t byte0_all_le_found;
+	uint32_t byte0_all_te_found;
+	uint32_t byte1_all_le_found;
+	uint32_t byte1_all_te_found;
+	// uint32_t sram_sp;
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	uartlog("cvx16_wdqlvl_sw_req\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("cvx16_wdqlvl_sw_req\n");
+
+	// param_phyd_piwdqlvl_dq_mode
+	//     <= #RD (~pwstrb_mask[12] & param_phyd_piwdqlvl_dq_mode) |  pwstrb_mask_pwdata[12];
+	// param_phyd_piwdqlvl_dm_mode
+	//     <= #RD (~pwstrb_mask[13] & param_phyd_piwdqlvl_dm_mode) |  pwstrb_mask_pwdata[13];
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	// lvl_mode =0x0, wdmlvl
+	// lvl_mode =0x1, wdqlvl
+	// lvl_mode =0x2, wdqlvl and wdmlvl
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x1) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 0, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x2) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	}
+	mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+	if (lvl_mode == 0x0) {
+		//        cvx16_bist_wdmlvl_init(sram_sp);
+		cvx16_bist_wdmlvl_init();
+	} else {
+		// bist setting for dfi rdglvl
+		// data_mode = 0x0 : phyd pattern
+		// data_mode = 0x1 : bist read/write
+		// data_mode = 0x11: with Error enject,  multi- bist write/read
+		// data_mode = 0x12: with Error enject,  multi- bist write/read
+		//         cvx16_bist_wdqlvl_init(data_mode, sram_sp);
+		cvx16_bist_wdqlvl_init(data_mode);
+	}
+	uartlog("cvx16_wdqlvl_req sw\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	// SW mode
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 7, 7); // param_phyd_piwdqlvl_sw
+	mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x018C + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_wdqlvl_req
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 1, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	}
+	if ((data_mode == 0x1) || (data_mode == 0x11) || (data_mode == 0x12)) {
+		rddata = modified_bits_by_value(rddata, 1, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 0, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	}
+	mmio_wr32(0x018C + PHYD_BASE_ADDR, rddata);
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 3, 3) == 0x1) {
+			break;
+		}
+		while (1) {
+			rddata = mmio_rd32(0x32A4 + PHYD_BASE_ADDR);
+			byte0_piwdqlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte0_all_le_found = get_bits_from_value(rddata, 18, 18);
+			byte0_all_te_found = get_bits_from_value(rddata, 17, 17);
+			rddata = mmio_rd32(0x32E4 + PHYD_BASE_ADDR);
+			byte1_piwdqlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte1_all_le_found = get_bits_from_value(rddata, 18, 18);
+			byte1_all_te_found = get_bits_from_value(rddata, 17, 17);
+			KC_MSG("=1 byte0_piwdqlvl_sw_upd_ack = %x, byte1_piwdqlvl_sw_upd_ack = %x ",
+			       byte0_piwdqlvl_sw_upd_ack, byte1_piwdqlvl_sw_upd_ack);
+			KC_MSG("byte0_all_found = %x, byte1_all_found = %x\n",
+			       (byte0_all_le_found & byte0_all_te_found),
+			       (byte1_all_le_found & byte1_all_te_found));
+
+			if (((byte0_piwdqlvl_sw_upd_ack == 0x1) || (byte0_all_le_found & byte0_all_te_found)) &&
+			    ((byte1_piwdqlvl_sw_upd_ack == 0x1) || (byte1_all_le_found & byte1_all_te_found))) {
+				rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+				tx_vref_sel = get_bits_from_value(rddata, 20, 16);
+				rddata = mmio_rd32(0x32A8 + PHYD_BASE_ADDR);
+				dlie_code = get_bits_from_value(rddata, 30, 18);
+				if (byte0_all_te_found) {
+					byte0_data_rise_fail = 0xff;
+					byte0_data_fall_fail = 0xff;
+				} else {
+					byte0_data_rise_fail = get_bits_from_value(rddata, 17, 9);
+					byte0_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				rddata = mmio_rd32(0x32E8 + PHYD_BASE_ADDR);
+				if (byte1_all_te_found) {
+					byte1_data_rise_fail = 0xff;
+					byte1_data_fall_fail = 0xff;
+				} else {
+					byte1_data_rise_fail = get_bits_from_value(rddata, 17, 9);
+					byte1_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				if ((byte0_piwdqlvl_sw_upd_ack == 0x1) || (byte1_piwdqlvl_sw_upd_ack == 0x1)) {
+					SHMOO_MSG("vref = %02x, sw_wdq_training_start = %08x , ",
+					       tx_vref_sel, dlie_code);
+
+					SHMOO_MSG("err_data_rise/err_data_fall = %08x, %08x\n",
+					       ((byte0_data_rise_fail & 0x000000FF) |
+						((byte1_data_rise_fail & 0x000000FF) << 8)),
+					       ((byte0_data_fall_fail & 0x000000FF) |
+						((byte1_data_fall_fail & 0x000000FF) << 8)));
+				}
+				rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+				rddata = modified_bits_by_value(rddata, 1, 8, 8); // param_phyd_piwdqlvl_sw_upd_req
+				mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+				KC_MSG("param_phyd_piwdqlvl_sw_upd_req = %x\n",
+				       get_bits_from_value(rddata, 8, 8));
+
+				KC_MSG("byte0_all_le_found, byte0_all_te_found, ");
+				KC_MSG("byte1_all_le_found, byte1_all_te_found");
+				KC_MSG("= %x %x %x %x\n",
+				       byte0_all_le_found, byte0_all_te_found,
+				       byte1_all_le_found, byte1_all_te_found);
+
+				break;
+			}
+			if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) && (byte1_all_le_found == 0x1) &&
+			    (byte1_all_te_found == 0x1)) {
+				break;
+			}
+		}
+	}
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_wdqlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_wrlvl_status(void)
+{
+#if defined(DBG_SHMOO) || defined(DDR_SIM)
+	NOTICE("cvx16_wrlvl_status\n");
+	ddr_debug_wr32(0x32);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x3100 + PHYD_BASE_ADDR);
+	NOTICE("wrlvl_byte0_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("wrlvl_byte0_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3104 + PHYD_BASE_ADDR);
+	NOTICE("wrlvl_byte1_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("wrlvl_byte1_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x3108 + PHYD_BASE_ADDR);
+	// NOTICE("wrlvl_byte2_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("wrlvl_byte2_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x310C + PHYD_BASE_ADDR);
+	// NOTICE("wrlvl_byte3_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("wrlvl_byte3_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3110 + PHYD_BASE_ADDR);
+	NOTICE("wrlvl_byte0_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	NOTICE("wrlvl_byte1_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	// rddata = mmio_rd32(0x3114 + PHYD_BASE_ADDR);
+	// NOTICE("wrlvl_byte2_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	// NOTICE("wrlvl_byte3_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	rddata = mmio_rd32(0x0A14 + PHYD_BASE_ADDR);
+	NOTICE("byte0 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A34 + PHYD_BASE_ADDR);
+	NOTICE("byte0 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A54 + PHYD_BASE_ADDR);
+	NOTICE("byte1 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A74 + PHYD_BASE_ADDR);
+	NOTICE("byte1 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0A94 + PHYD_BASE_ADDR);
+	// NOTICE("byte2 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0AB4 + PHYD_BASE_ADDR);
+	// NOTICE("byte2 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0AD4 + PHYD_BASE_ADDR);
+	// NOTICE("byte3 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0AE4 + PHYD_BASE_ADDR);
+	// NOTICE("byte3 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+#endif //DBG_SHMOO || DDR_SIM
+}
+
+void cvx16_rdglvl_status(void)
+{
+#if defined(DBG_SHMOO) || defined(DDR_SIM)
+	NOTICE("cvx16_rdglvl_status\n");
+	ddr_debug_wr32(0x33);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x3140 + PHYD_BASE_ADDR);
+	NOTICE("rdglvl_byte0_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("rdglvl_byte0_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3144 + PHYD_BASE_ADDR);
+	NOTICE("rdglvl_byte1_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("rdglvl_byte1_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x3148 + PHYD_BASE_ADDR);
+	// NOTICE("rdglvl_byte2_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("rdglvl_byte2_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x314C + PHYD_BASE_ADDR);
+	// NOTICE("rdglvl_byte3_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("rdglvl_byte3_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3150 + PHYD_BASE_ADDR);
+	NOTICE("rdglvl_byte0_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	NOTICE("rdglvl_byte1_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	// rddata = mmio_rd32(0x3154 + PHYD_BASE_ADDR);
+	// NOTICE("rdglvl_byte2_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	// NOTICE("rdglvl_byte3_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	rddata = mmio_rd32(0x0B0C + PHYD_BASE_ADDR);
+	NOTICE("byte0 mask shift/delay = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0B3C + PHYD_BASE_ADDR);
+	NOTICE("byte1 mask shift/delay = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0B6C + PHYD_BASE_ADDR);
+	// NOTICE("byte2 mask shift/delay = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0B9C + PHYD_BASE_ADDR);
+	// NOTICE("byte3 mask shift/delay = %x\n", rddata);
+
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	// raw
+	rddata = mmio_rd32(0x0B20 + PHYD_BASE_ADDR);
+	NOTICE("raw byte0 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+
+	rddata = mmio_rd32(0x0B50 + PHYD_BASE_ADDR);
+	NOTICE("raw byte1 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+
+	// rddata = mmio_rd32(0x0B80 + PHYD_BASE_ADDR);
+	// NOTICE("raw byte2 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+
+	// rddata = mmio_rd32(0x0BB0 + PHYD_BASE_ADDR);
+	// NOTICE("raw byte3 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+#endif //DBG_SHMOO || DDR_SIM
+}
+
+void cvx16_rdlvl_status(void)
+{
+#if defined(DBG_SHMOO) || defined(DDR_SIM)
+	uint32_t i;
+
+	NOTICE("cvx16_rdlvl_status\n");
+	ddr_debug_wr32(0x34);
+	ddr_debug_num_write();
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3180 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3184 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3188 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x318C + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3190 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3194 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x3198 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x319C + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A0 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x31A4 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A8 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31AC + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x31B0 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_status0_byte%x = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x31B4 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_status1_byte%x = %x\n", i, rddata);
+	}
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B00 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq3210 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B04 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq7654 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x rdqspos/neg/deskewdq8 = %x\n", i, rddata);
+	}
+	// rdvld
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B14 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x_rdvld = %x\n", i, get_bits_from_value(rddata, 20, 16));
+	}
+	// trig_lvl
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x trig_lvl_dq = %x, trig_lvl_dqs = %x\n", i, get_bits_from_value(rddata, 4, 0),
+		       get_bits_from_value(rddata, 20, 16));
+	}
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B18 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq3210_raw = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B1C + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq7654_raw = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B20 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x rdqspos/neg/mask/deskewdq8 = %x\n", i, rddata);
+	}
+#endif // DBG_SHMOO || DDR_SIM
+}
+
+void cvx16_wdqlvl_status(void)
+{
+#if defined(DBG_SHMOO) || defined(DDR_SIM)
+	NOTICE("cvx16_wdqlvl_status\n");
+	ddr_debug_wr32(0x35);
+	ddr_debug_num_write();
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3280 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq0_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq1_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3284 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq2_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq3_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3288 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq4_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq5_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x328C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq6_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq7_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3290 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq8_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq0_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3294 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq1_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq2_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3298 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq3_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq4_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x329C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq5_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq6_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x32A0 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq7_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq8_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x32A4 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_status0 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x32A8 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_status1 = %x\n", i, rddata);
+	}
+	// wdq shift
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0A00 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq0 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq1 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A04 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq2 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq3 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A08 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq4 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq5 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A0C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq6 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq7 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A10 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq8 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+	}
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	NOTICE("piwdqlvl tx vref = %x\n", get_bits_from_value(rddata, 20, 16));
+
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0A20 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq0 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq1 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A24 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq2 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq3 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A28 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq4 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq5 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A2C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq6 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq7 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A30 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq8 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+	}
+#endif //DBG_SHMOO || DDR_SIM
+}
+
+void cvx16_dll_cal_status(void)
+{
+#if defined(DBG_SHMOO) || defined(DDR_SIM)
+	uint32_t err_cnt;
+	uint32_t rx_dll_code;
+	uint32_t tx_dll_code;
+
+	NOTICE("cvx16_dll_cal_status\n");
+	ddr_debug_wr32(0x37);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x3018 + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_rx_dll_code0= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_rx_dll_code1= %x ...\n", get_bits_from_value(rddata, 15, 8));
+	NOTICE("param_phyd_to_reg_rx_dll_code2= %x ...\n", get_bits_from_value(rddata, 23, 16));
+	NOTICE("param_phyd_to_reg_rx_dll_code3= %x ...\n", get_bits_from_value(rddata, 31, 24));
+
+	rddata = mmio_rd32(0x301c + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_rx_dll_max= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_rx_dll_min= %x ...\n", get_bits_from_value(rddata, 15, 8));
+
+	rddata = mmio_rd32(0x3020 + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_tx_dll_code0= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_tx_dll_code1= %x ...\n", get_bits_from_value(rddata, 15, 8));
+	NOTICE("param_phyd_to_reg_tx_dll_code2= %x ...\n", get_bits_from_value(rddata, 23, 16));
+	NOTICE("param_phyd_to_reg_tx_dll_code3= %x ...\n", get_bits_from_value(rddata, 31, 24));
+
+	rddata = mmio_rd32(0x3024 + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_tx_dll_max= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_tx_dll_min= %x ...\n", get_bits_from_value(rddata, 15, 8));
+
+	err_cnt = 0;
+	rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+	rx_dll_code = get_bits_from_value(rddata, 15, 8);
+	tx_dll_code = get_bits_from_value(rddata, 31, 24);
+#ifdef _mem_freq_2133
+	if (!((rx_dll_code > 0x26) && (rx_dll_code < 0x2b))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x26~0x2b --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x26) && (tx_dll_code < 0x2b))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x26~0x2b --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_3200
+	if (!((rx_dll_code > 0x15) && (rx_dll_code < 0x22))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x15~0x22 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x15) && (tx_dll_code < 0x22))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x15~0x22 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1866
+	if (!((rx_dll_code > 0x2b) && (rx_dll_code < 0x30))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x2b~0x30 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x2b) && (tx_dll_code < 0x30))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x2b~0x30 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1600
+	if (!((rx_dll_code > 0x2a) && (rx_dll_code < 0x44))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x2a~0x44 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x2a) && (tx_dll_code < 0x44))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x2a~0x44 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_2400
+	if (!((rx_dll_code > 0x21) && (rx_dll_code < 0x25))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x21~0x25 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x21) && (tx_dll_code < 0x25))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x21~0x25 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_2666
+	if (!((rx_dll_code > 0x1e) && (rx_dll_code < 0x22))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x1e~0x22 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x1e) && (tx_dll_code < 0x22))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x1e~0x22 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1333
+	if (!((rx_dll_code > 0x3d) && (rx_dll_code < 0x44))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x3e~0x42 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x3d) && (tx_dll_code < 0x44))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x3e~0x42 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1066
+	if (!((rx_dll_code > 0x4e) && (rx_dll_code < 0x52))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x4e~0x52 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x4e) && (tx_dll_code < 0x52))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x4e~0x52 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	if (err_cnt != 0x0) {
+		NOTICE("*****************************************\n");
+		NOTICE("DLL_CAL ERR!!! err_cnt = %x...\n", err_cnt);
+		NOTICE("*****************************************\n");
+	} else {
+		NOTICE("*****************************************\n");
+		NOTICE("DLL_CAL PASS!!!\n");
+		NOTICE("*****************************************\n");
+	}
+#endif //DBG_SHMOO || DDR_SIM
+}
+
+void cvx16_zqcal_status(void)
+{
+	uint32_t zq_drvn;
+	uint32_t zq_drvp;
+
+	uartlog("cvx16_zqcal_status\n");
+	ddr_debug_wr32(0x36);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+	zq_drvn = get_bits_from_value(rddata, 20, 16);
+	zq_drvp = get_bits_from_value(rddata, 28, 24);
+	if ((zq_drvn >= 0x07) && (zq_drvn <= 0x9)) {
+		KC_MSG("ZQ Complete ... param_phya_reg_tx_zq_drvn = %x\n", zq_drvn);
+	} else {
+		KC_MSG("ZQ Complete ... INFO! param_phya_reg_tx_zq_drvn != 0b01000 +- 1, read:value: %x\n",
+		       zq_drvn);
+	}
+	if ((zq_drvp >= 0x07) && (zq_drvp <= 0x9)) {
+		KC_MSG("ZQ Complete ... param_phya_reg_tx_zq_drvp = %x\n", zq_drvp);
+	} else {
+		KC_MSG("ZQ Complete ... INFO! param_phya_reg_tx_zq_drvp != 0b01000 +- 1, read value: %x\n",
+		       zq_drvp);
+	}
+}
+
+void cvx16_training_status(void)
+{
+	uint32_t i;
+
+	uartlog("cvx16_training_status\n");
+	// wrlvl
+	rddata = mmio_rd32(0x0A14 + PHYD_BASE_ADDR);
+	uartlog("byte0 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A54 + PHYD_BASE_ADDR);
+	uartlog("byte1 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rdglvl
+	rddata = mmio_rd32(0x0B0C + PHYD_BASE_ADDR);
+	uartlog("byte0 mask shift/delay = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0B3C + PHYD_BASE_ADDR);
+	uartlog("byte1 mask shift/delay = %x\n", rddata);
+
+	// rdlvl
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3180 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3184 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3188 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x318C + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3190 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3194 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x3198 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x319C + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A0 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x31A4 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A8 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31AC + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+	}
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B00 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x deskewdq3210 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B04 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x deskewdq7654 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x rdqspos/neg/deskewdq8 = %x\n", i, rddata);
+	}
+	// rdvld
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B14 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x_rdvld = %x\n", i, get_bits_from_value(rddata, 20, 16));
+	}
+	// trig_lvl
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x trig_lvl_dq = %x, trig_lvl_dqs = %x\n", i, get_bits_from_value(rddata, 4, 0),
+		       get_bits_from_value(rddata, 20, 16));
+	}
+	// wdqlvl
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3280 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq0_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq1_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3284 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq2_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq3_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3288 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq4_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq5_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x328C + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq6_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq7_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3290 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq8_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq0_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3294 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq1_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq2_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3298 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq3_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq4_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x329C + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq5_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq6_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x32A0 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq7_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq8_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+	}
+	// wdq shift
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0A00 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq0 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq1 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A04 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq2 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq3 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A08 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq4 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq5 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A0C + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq6 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq7 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A10 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq8 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+	}
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	KC_MSG("piwdqlvl tx vref = %x\n", get_bits_from_value(rddata, 20, 16));
+}
+
+void cvx16_setting_check(void)
+{
+	uint32_t dfi_tphy_wrlat;
+	uint32_t dfi_tphy_wrdata;
+	uint32_t dfi_t_rddata_en;
+	uint32_t dfi_t_ctrl_delay;
+	uint32_t dfi_t_wrdata_delay;
+	uint32_t phy_reg_version;
+
+	uartlog("cvx16_setting_check\n");
+	ddr_debug_wr32(0x0a);
+	ddr_debug_num_write();
+	phy_reg_version = mmio_rd32(0x3000 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(cfg_base + 0x190);
+	dfi_tphy_wrlat = get_bits_from_value(rddata, 5, 0); // DFITMG0.dfi_tphy_wrlat
+	dfi_tphy_wrdata = get_bits_from_value(rddata, 13, 8); // DFITMG0.dfi_tphy_wrdata
+	dfi_t_rddata_en = get_bits_from_value(rddata, 22, 16); // DFITMG0.dfi_t_rddata_en
+	dfi_t_ctrl_delay = get_bits_from_value(rddata, 29, 24); // DFITMG0.dfi_t_ctrl_delay
+	rddata = mmio_rd32(cfg_base + 0x194);
+	dfi_t_wrdata_delay = get_bits_from_value(rddata, 20, 16); // DFITMG1.dfi_t_wrdata_delay
+	KC_MSG("phy_reg_version = %x, dfi_t_ctrl_delay = %x, dfi_t_rddata_en = %x\n", phy_reg_version,
+	       dfi_t_ctrl_delay, dfi_t_rddata_en);
+
+	KC_MSG("dfi_tphy_wrlat  = %x, dfi_tphy_wrdata  = %x, dfi_t_wrdata_delay = %x\n", dfi_tphy_wrlat,
+	       dfi_tphy_wrdata, dfi_t_wrdata_delay);
+
+	if (dfi_t_ctrl_delay != 0x4) {
+		KC_MSG("ERR !!! dfi_t_ctrl_delay not 0x4\n");
+	}
+#ifndef DDR2_3
+#ifdef _mem_freq_2133
+	if (dfi_tphy_wrlat != 0x6) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x6\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0xa) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0xa\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#ifdef _mem_freq_1866
+	if (dfi_tphy_wrlat != 0x5) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x5\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0xa) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0xa\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#ifdef _mem_freq_1600
+	if (dfi_tphy_wrlat != 0x4) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x4\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x8) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x8\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#ifdef _mem_freq_1333
+#ifdef ESMT_ETRON_1333
+	if (dfi_tphy_wrlat != 0x4) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x4\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x7) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x7\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#else
+	if (dfi_tphy_wrlat != 0x2) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x2\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x5) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x5\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#endif
+#ifdef _mem_freq_1066
+	if (dfi_tphy_wrlat != 0x2) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x2\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x5) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x5\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#else
+	if (get_ddr_type() == DDR_TYPE_DDR3) {//DDR3:1866
+
+		if (dfi_tphy_wrlat != 0x5) {
+			KC_MSG("ERR !!! dfi_tphy_wrlat not 0x5\n");
+		}
+		if (dfi_tphy_wrdata != 0x3) {
+			KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+		}
+		if (dfi_t_rddata_en != 0xa) {
+			KC_MSG("ERR !!! dfi_t_rddata_en not 0xa\n");
+		}
+		if (dfi_t_wrdata_delay != 0x7) {
+			KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+		}
+	} else {
+	#ifdef ESMT_ETRON_1333
+		if (dfi_tphy_wrlat != 0x4) {
+			KC_MSG("ERR !!! dfi_tphy_wrlat not 0x4\n");
+		}
+		if (dfi_tphy_wrdata != 0x3) {
+			KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+		}
+		if (dfi_t_rddata_en != 0x7) {
+			KC_MSG("ERR !!! dfi_t_rddata_en not 0x7\n");
+		}
+		if (dfi_t_wrdata_delay != 0x7) {
+			KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+		}
+	#else
+		if (dfi_tphy_wrlat != 0x2) {
+			KC_MSG("ERR !!! dfi_tphy_wrlat not 0x2\n");
+		}
+		if (dfi_tphy_wrdata != 0x3) {
+			KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+		}
+		if (dfi_t_rddata_en != 0x5) {
+			KC_MSG("ERR !!! dfi_t_rddata_en not 0x5\n");
+		}
+		if (dfi_t_wrdata_delay != 0x7) {
+			KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+		}
+	#endif
+	}
+#endif
+}
+
+void cvx16_ddr_freq_change_htol(void)
+{
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#if defined(DDR3) || defined(DDR4) || defined(DDR2_3)
+	uint32_t rtt_nom = 0;
+#ifdef DDR4
+	uint32_t rtt_park;
+#endif //DDR4
+	uint32_t rtt_wr = 0;
+	uint32_t mwr_temp;
+#endif //defined(DDR3) || defined(DDR4)
+	uint32_t port_num;
+	// Note: freq_change_htol need ctrl_low_patch first
+	KC_MSG("HTOL Frequency Change Start\n");
+
+	uartlog("cvx16_ddr_freq_change_htol\n");
+	ddr_debug_wr32(0x38);
+	ddr_debug_num_write();
+	// TOP_REG_EN_PLL_SPEED_CHG =1, TOP_REG_NEXT_PLL_SPEED = 0b01, TOP_REG_CUR_PLL_SPEED=0b10
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	// rddata[0]     = 1;        //TOP_REG_EN_PLL_SPEED_CHG
+	// rddata[5:4]   = 0b10;    //TOP_REG_CUR_PLL_SPEED
+	// rddata[9:8]   = 0b01;    //TOP_REG_NEXT_PLL_SPEED
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 2, 5, 4);
+	rddata = modified_bits_by_value(rddata, 1, 9, 8);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	// clock gating disable
+	cvx16_clk_gating_disable();
+	// save lowpower setting
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// en_dfi_dram_clk_disable = rddata[3];
+	// powerdown_en            = rddata[1];
+	// selfref_en              = rddata[0];
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 0 to PCTRL_n.port_en, without port 0
+	// port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// 3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+	rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+// 5. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable RTT_NOM:
+//    a. DDR3: Write ????to MR1[9], MR1[6] and MR1[2]
+//    b. DDR4: Write ????to MR1[10:8]
+// 6. For DDR4 only: Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to write ????to
+//    MR5[8:6] to disable RTT_PARK
+// 7. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to write ????to MR2[10:9], to
+//    disable RTT_WR (and therefore disable dynamic ODT). This applies for both DDR3 and DDR4.
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = rddata[10:8];
+	rtt_nom = get_bits_from_value(rddata, 10, 8);
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 11) << 11 | get_bits_from_value(rddata, 7, 0);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], 0b000, rddata[7:0]});
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+	KC_MSG("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// rtt_park = rddata[8:6];
+	rtt_park = get_bits_from_value(rddata, 8, 6);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], 0b000, rddata[5:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 9) << 9 | get_bits_from_value(rddata, 5, 0);
+	cvx16_synp_mrw(0x5, mwr_temp);
+	uartlog("write ????to MR5[8:6] to disable RTT_PARK\n");
+	KC_MSG("write ????to MR5[8:6] to disable RTT_PARK\n");
+
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// rtt_wr = rddata[25:24];
+	rtt_wr = get_bits_from_value(rddata, 25, 24);
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 31, 26) << 10 | get_bits_from_value(rddata, 23, 16);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], 0b00, rddata[23:16]});
+	cvx16_synp_mrw(0x2, mwr_temp);
+	uartlog("write ????to MR2[10:9], to disable RTT_WR\n");
+	KC_MSG("write ????to MR2[10:9], to disable RTT_WR\n");
+
+#endif
+#ifdef DDR3
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+	rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+		  get_bits_from_value(rddata, 2, 2);
+	// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+		   get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+	KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// rtt_wr = rddata[25:24];
+	rtt_wr = get_bits_from_value(rddata, 25, 24);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], 0b00, rddata[23:16]});
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 10 | get_bits_from_value(rddata, 23, 16));
+	uartlog("write ????to MR2[10:9], to disable RTT_WR\n");
+	KC_MSG("write ????to MR2[10:9], to disable RTT_WR\n");
+
+#endif
+#ifdef DDR2
+	KC_MSG("DDR2\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+		rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+			get_bits_from_value(rddata, 2, 2);
+		// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+		mwr_temp = 0;
+		mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+			get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+		cvx16_synp_mrw(0x1, mwr_temp);
+		uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+		KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+
+		// read mr2 @INIT4
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		// rtt_wr = rddata[25:24];
+		rtt_wr = get_bits_from_value(rddata, 25, 24);
+		// cvx16_synp_mrw(0x2,  {rddata[31:26], 0b00, rddata[23:16]});
+		cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 10 | get_bits_from_value(rddata, 23, 16));
+		uartlog("write ????to MR2[10:9], to disable RTT_WR\n");
+		KC_MSG("write ????to MR2[10:9], to disable RTT_WR\n");
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		KC_MSG("DDR2\n");
+	}
+#endif
+	// 20200206
+	//  3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+	rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+// 8. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable the DLL. The timing of
+// this MRS is automatically handled by the uMCTL2.
+// a. DDR3: Write ????to MR1[0]
+// b. DDR4: Write ????to MR1[0]
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1);
+	uartlog("DDR4: Write ????to MR1[0]\n");
+	KC_MSG("DDR4: Write ????to MR1[0]\n");
+
+#endif
+#ifdef DDR3
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	mwr_temp = modified_bits_by_value(rddata, 1, 0, 0);
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+	cvx16_synp_mrw(0x1, mwr_temp);
+#endif
+#ifdef DDR2
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	////read EMR1 @INIT3
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	////DDR2: Write ????to EMR1
+	////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = mmio_rd32(cfg_base + 0x30);
+		// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+		// rddata[1] = 0x0; //PWRCTL.powerdown_en
+		// rddata[0] = 0x0; //PWRCTL.selfref_en
+		rddata = modified_bits_by_value(rddata, 0, 3, 3);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0);
+		mmio_wr32(cfg_base + 0x30, rddata);
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		mwr_temp = modified_bits_by_value(rddata, 1, 0, 0);
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+		cvx16_synp_mrw(0x1, mwr_temp);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		rddata = mmio_rd32(cfg_base + 0x30);
+		// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+		// rddata[1] = 0x0; //PWRCTL.powerdown_en
+		// rddata[0] = 0x0; //PWRCTL.selfref_en
+		rddata = modified_bits_by_value(rddata, 0, 3, 3);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0);
+		mmio_wr32(cfg_base + 0x30, rddata);
+		////read EMR1 @INIT3
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		////DDR2: Write ????to EMR1
+		////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+	}
+#endif
+	// 9. Put the SDRAM into self-refresh mode by setting PWRCTL.selfref_sw = 1, and polling STAT.operating_
+	// mode to ensure the DDRC has entered self-refresh.
+	// Write 1 to PWRCTL.selfref_sw
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x1; //PWRCTL.selfref_sw
+	// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+// Poll STAT.selfref_type= 2b10
+// Poll STAT.selfref_state = 0b10 (LPDDR4 only)
+#ifndef LP4
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_state = 0b10\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 2) {
+			break;
+		}
+	}
+	// 11. Set the MSTR.dll_off_mode = 1.
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x1;
+	rddata = modified_bits_by_value(rddata, 1, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#else
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type= 2b10\n");
+
+		if ((get_bits_from_value(rddata, 9, 8) == 0x2)) {
+			break;
+		}
+	}
+#endif
+	// Change PLL frequency
+	cvx16_chg_pll_freq();
+	KC_MSG("cvx16_chg_pll_freq done ...\n");
+
+	// test only when dll_cal is not use
+	//     #ifdef DDR3
+	//         //param_phyd_dll_sw_code    <= `PI_SD int_regin[23:16]
+	//         //param_phyd_dll_sw_code_mode    <= `PI_SD int_regin[8];
+	//         REGREAD(169 + PHY_BASE_ADDR, rddata);
+	//         rddata[23:16] = 0x54;
+	//         rddata[8] = 0b1;
+	//         REGWR  (169 + PHY_BASE_ADDR, rddata, 0);
+	uartlog("param_phyd_dll_sw_code\n");
+	//        //param_phyd_dll_sw_clr          <= `PI_SD int_regin[7];
+	//        rddata[7] = 0b1;
+	//        REGWR  (169 + PHY_BASE_ADDR, rddata, 0);
+	//        rddata[7] = 0b0;
+	//        REGWR  (169 + PHY_BASE_ADDR, rddata, 0);
+	//    #endif
+	// dll_cal
+	cvx16_dll_cal();
+	KC_MSG("Do DLLCAL done ...\n");
+
+	// refresh requirement
+	// Program controller
+	rddata = mmio_rd32(cfg_base + 0x64);
+	// rddata[27:16] = rddata[27:17];
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 27, 17), 27, 16);
+	// rddata[9:0] = rddata[9:1] + rddata[0];
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 9, 1) + get_bits_from_value(rddata, 0, 0),
+					9, 0);
+	mmio_wr32(cfg_base + 0x64, rddata);
+	rddata = mmio_rd32(cfg_base + 0x68);
+	// rddata[23:16] = rddata[23:17] + rddata[16];
+	rddata = modified_bits_by_value(
+		rddata, get_bits_from_value(rddata, 23, 17) + get_bits_from_value(rddata, 16, 16), 23, 16);
+	mmio_wr32(cfg_base + 0x68, rddata);
+//    // program phyupd_mask
+//    rddata = mmio_rd32(0x0800a504);
+//    //rddata[27:16] = rddata[27:17] + rddata[16];
+//    rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 27, 17) +
+//                                    get_bits_from_value(rddata, 16, 16), 27, 16);
+//    mmio_wr32(0x0800a504, rddata);
+//    rddata = mmio_rd32(0x0800a500);
+//    //rddata[31:16] = rddata[31:17];
+//    rddata=modified_bits_by_value(rddata, get_bits_from_value(rddata, 31, 17), 31, 16);
+//    mmio_wr32(0x0800a500, rddata);
+#ifndef LP4
+	// 9. Set MSTR.dll_off_mode = 0
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x0;
+	rddata = modified_bits_by_value(rddata, 0, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#endif
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type = 2b00\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 0) {
+			break;
+		}
+	}
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.operating_mode for Normal Mode entry\n");
+
+		if (get_bits_from_value(rddata, 1, 0) == 1) {
+			break;
+		}
+	}
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+	uartlog("DDR4: Write ????to MR1[0]\n");
+	KC_MSG("DDR4: Write ????to MR1[0]\n");
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// opdelay(1).2us; //wait tDLLK ??
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	uartlog("15. Perform an MRS command\n");
+	KC_MSG("15. Perform an MRS command\n");
+
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], rtt_nom[2:0], rddata[7:0]});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 11) << 11 | get_bits_from_value(rtt_nom, 2, 0) << 8 |
+				    get_bits_from_value(rddata, 7, 0));
+	uartlog("enable RTT_NOM\n");
+	KC_MSG("enable RTT_NOM\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], rtt_park[2:0], rddata[5:0]});
+	cvx16_synp_mrw(0x5, get_bits_from_value(rddata, 15, 9) << 9 | get_bits_from_value(rtt_park, 2, 0) << 6 |
+				    get_bits_from_value(rddata, 5, 0));
+	uartlog("enable RTT_PARK\n");
+	KC_MSG("enable RTT_PARK\n");
+
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], rtt_wr[1:0], rddata[23:16]});
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 11 | get_bits_from_value(rtt_wr, 1, 0) << 8 |
+				    get_bits_from_value(rddata, 23, 16));
+	uartlog("enable RTT_WR\n");
+	KC_MSG("enable RTT_WR\n");
+
+#endif
+#ifdef DDR3
+	////read mr1 @INIT3
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	////DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], rtt_wr[1:0], rddata[23:16]});
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 11 | get_bits_from_value(rtt_wr, 1, 0) << 8 |
+				    get_bits_from_value(rddata, 23, 16));
+	uartlog("enable RTT_WR\n");
+	KC_MSG("enable RTT_WR\n");
+
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// cvx16_synp_mrw(0x1,
+	//      {rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rtt_nom, 2, 2) << 9 |
+				    get_bits_from_value(rddata, 8, 7) << 7 | get_bits_from_value(rtt_nom, 1, 1) << 5 |
+				    get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rtt_nom, 0, 0) << 2 |
+				    get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+	uartlog("enable RTT_NOM\n");
+	KC_MSG("enable RTT_NOM %x\n", rtt_nom);
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	KC_MSG("15. Perform an MRS command\n");
+
+	// opdelay(2).2us; //don't remove. wait tDLLK ??
+	opdelay(2200);
+#endif
+#ifdef DDR2
+	// reset the DLL
+	// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+	// The uMCTL2 sets this bit appropriately.
+	// read EMR1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	////DDR2: Write ????to EMR1
+	////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	KC_MSG("15. Perform an MRS command\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		////read mr1 @INIT3
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		////DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+		// read mr2 @INIT4
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		// cvx16_synp_mrw(0x2,  {rddata[31:26], rtt_wr[1:0], rddata[23:16]});
+		cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 11 | get_bits_from_value(rtt_wr, 1, 0) << 8 |
+						get_bits_from_value(rddata, 23, 16));
+		uartlog("enable RTT_WR\n");
+		KC_MSG("enable RTT_WR\n");
+
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// cvx16_synp_mrw(0x1,
+		//      {rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 |
+					get_bits_from_value(rtt_nom, 2, 2) << 9 |
+					get_bits_from_value(rddata, 8, 7) << 7 |
+					get_bits_from_value(rtt_nom, 1, 1) << 5 |
+					get_bits_from_value(rddata, 5, 3) << 3 |
+					get_bits_from_value(rtt_nom, 0, 0) << 2 |
+					get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+		uartlog("enable RTT_NOM\n");
+		KC_MSG("enable RTT_NOM %x\n", rtt_nom);
+
+		// read mr0 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+		// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+		// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+						get_bits_from_value(rddata, 23, 16));
+		KC_MSG("15. Perform an MRS command\n");
+
+		// opdelay(2).2us; //don't remove. wait tDLLK ??
+		opdelay(2200);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		// reset the DLL
+		// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+		// The uMCTL2 sets this bit appropriately.
+		// read EMR1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		////DDR2: Write ????to EMR1
+		////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+						get_bits_from_value(rddata, 23, 16));
+		KC_MSG("15. Perform an MRS command\n");
+	}
+#endif
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	uartlog("restore selfref_en powerdown_en\n");
+#ifdef DDR4
+	rddata = mmio_rd32(0x0b0c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) >> 1), 6, 0);
+	mmio_wr32(0x0b0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0b3c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) >> 1), 6, 0);
+	mmio_wr32(0x0b3c + PHYD_BASE_ADDR, rddata);
+	cvx16_dll_sw_upd();
+#endif
+	uartlog("rdlvl_gate\n");
+	//        KC_MSG("pi_rdlvl_gate_req done ...\n");
+
+	//    #endif
+	cvx16_clk_gating_enable();
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	KC_MSG("HTOL Frequency Change Finished\n");
+}
+
+void cvx16_ddr_freq_change_ltoh(void)
+{
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#if defined(DDR3) || defined(DDR4) || defined(DDR2_3)
+	uint32_t rtt_nom = 0;
+#ifdef DDR4
+	uint32_t rtt_park;
+#endif //DDR4
+	uint32_t mwr_temp;
+#endif // defined(DDR3) || defined(DDR4)
+
+	uint32_t port_num;
+
+	// Note: freq_change_ltoh need ctrl_low_patch first
+	KC_MSG("LTOH Frequency Change Start\n");
+
+	uartlog("cvx16_ddr_freq_change_ltoh\n");
+	ddr_debug_wr32(0x39);
+	ddr_debug_num_write();
+	// TOP_REG_EN_PLL_SPEED_CHG =1, TOP_REG_NEXT_PLL_SPEED = 0b01, TOP_REG_CUR_PLL_SPEED=0b10
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	// rddata[0]     = 1;        //TOP_REG_EN_PLL_SPEED_CHG
+	// rddata[5:4]   = 0b01;    //TOP_REG_CUR_PLL_SPEED
+	// rddata[9:8]   = 0b10;    //TOP_REG_NEXT_PLL_SPEED
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 5, 4);
+	rddata = modified_bits_by_value(rddata, 2, 9, 8);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	// clock gating disable
+	cvx16_clk_gating_disable();
+	// save lowpower setting
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// en_dfi_dram_clk_disable = rddata[3];
+	//  powerdown_en            = rddata[1];
+	//  selfref_en              = rddata[0];
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 0 to PCTRL_n.port_en, without port 0
+	// port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+// 3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+//   rddata = mmio_rd32(cfg_base + 0x60);
+////rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+//  rddata = modified_bits_by_value(rddata, 1, 0, 0);
+//  mmio_wr32(cfg_base + 0x60, rddata);
+// 5. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable RTT_NOM:
+//    a. DDR3: Write ????to MR1[9], MR1[6] and MR1[2]
+//    b. DDR4: Write ????to MR1[10:8]
+// 6. For DDR4 only: Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to write ????to
+//    MR5[8:6] to disable RTT_PARK
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = rddata[10:8];
+	rtt_nom = get_bits_from_value(rddata, 10, 8);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], 0b000, rddata[7:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 11) << 11 | get_bits_from_value(rddata, 7, 0);
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+	KC_MSG("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// rtt_park = rddata[8:6];
+	rtt_park = get_bits_from_value(rddata, 8, 6);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], 0b000, rddata[5:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 9) << 9 | get_bits_from_value(rddata, 5, 0);
+	uartlog("write ????to MR5[8:6] to disable RTT_PARK\n");
+	KC_MSG("write ????to MR5[8:6] to disable RTT_PARK\n");
+
+#endif
+#ifdef DDR3
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+	rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+		  get_bits_from_value(rddata, 2, 2);
+	// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+		   get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+	KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+
+#endif
+#ifdef DDR2
+	KC_MSG("DDR2\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+		rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+			get_bits_from_value(rddata, 2, 2);
+		// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+		mwr_temp = 0;
+		mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+			get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+		cvx16_synp_mrw(0x1, mwr_temp);
+		uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+		KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2)	{
+		KC_MSG("DDR2\n");
+	}
+#endif
+	// 20200206
+	//  3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+	rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+// 8. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable the DLL. The timing of
+// this MRS is automatically handled by the uMCTL2.
+// a. DDR3: Write ????to MR1[0]
+// b. DDR4: Write ????to MR1[0]
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 0);
+	uartlog("DDR4: Write ????to MR1[0]\n");
+	KC_MSG("DDR4: Write ????to MR1[0]\n");
+
+#endif
+#ifdef DDR3
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+#endif
+#ifdef DDR2
+	KC_MSG("DDR2\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		KC_MSG("DDR2\n");
+	}
+#endif
+	// 9. Put the SDRAM into self-refresh mode by setting PWRCTL.selfref_sw = 1, and polling STAT.operating_
+	// mode to ensure the DDRC has entered self-refresh.
+	// Write 1 to PWRCTL.selfref_sw
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x1; //PWRCTL.selfref_sw
+	// rddata[3] = 0x1; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+// Poll STAT.selfref_type= 2b10
+// Poll STAT.selfref_state = 0b10 (LPDDR4 only)
+#ifndef LP4
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_state = 0b10\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 2) {
+			break;
+		}
+	}
+	// 11. Set the MSTR.dll_off_mode = 1.
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x1;
+	rddata = modified_bits_by_value(rddata, 1, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#else
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type= 2b10\n");
+
+		if (get_bits_from_value(rddata, 9, 8) == 2) {
+			break;
+		}
+	}
+#endif
+	// Change PLL frequency
+	cvx16_chg_pll_freq();
+	KC_MSG("cvx16_chg_pll_freq done ...\n");
+
+	cvx16_dll_cal();
+	// refresh requirement
+	// Program controller
+	rddata = mmio_rd32(cfg_base + 0x64);
+	// rddata[27:16] = {rddata[26:16], 0b0};
+	// rddata[9:0] = {rddata[8:0], 0b0};
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 26, 16) << 1, 27, 16);
+	mmio_wr32(cfg_base + 0x64, rddata);
+	rddata = mmio_rd32(cfg_base + 0x68);
+	// rddata[23:16] = {rddata[22:16], 0b0};
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 22, 16) << 1, 23, 16);
+	mmio_wr32(cfg_base + 0x68, rddata);
+//    // program phyupd_mask
+//    rddata = mmio_rd32(0x0800a504);
+//    //rddata[27:16] = {rddata[26:16],0b0};
+//    rddata=modified_bits_by_value(rddata, get_bits_from_value(rddata, 26, 16)<<1, 27, 16);
+//    mmio_wr32(0x0800a504, rddata);
+//    rddata = mmio_rd32(0x0800a500);
+//    //rddata[31:16] = {rddata[30:16],0b0};
+//    rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 30, 16)<<1, 31, 16);
+//    mmio_wr32(0x0800a500, rddata);
+#ifndef LP4
+	// 9. Set MSTR.dll_off_mode = 0
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x0;
+	rddata = modified_bits_by_value(rddata, 0, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#endif
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type = 0b00\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 0) {
+			break;
+		}
+	}
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.operating_mode for Normal Mode entry\n");
+
+		if (get_bits_from_value(rddata, 1, 0) == 1) {
+			break;
+		}
+	}
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write 1 to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+	uartlog("DDR4: Write 1 to MR1[0]\n");
+	KC_MSG("DDR4: Write 1 to MR1[0]\n");
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// opdelay(0).7us; //wait tDLLK ??
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0,
+		       ((get_bits_from_value(rddata, 31, 25) << 9) | (0b1 << 8) | get_bits_from_value(rddata, 23, 16)));
+	uartlog("15. Perform an MRS command\n");
+	KC_MSG("15. Perform an MRS command\n");
+
+	// 17. Re-enable RTT_PARK (DDR4 only) and RTT_NOM by performing MRS commands (if required).
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], rtt_nom[2:0], rddata[7:0]});
+	cvx16_synp_mrw(0x1, ((get_bits_from_value(rddata, 15, 11) << 11) | (get_bits_from_value(rtt_nom, 2, 0) << 8) |
+			     get_bits_from_value(rddata, 7, 0)));
+	uartlog("Re-enable RTT_NOM\n");
+	KC_MSG("Re-enable RTT_NOM\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], rtt_park[2:0], rddata[5:0]});
+	cvx16_synp_mrw(0x5, ((get_bits_from_value(rddata, 15, 9) << 9) | (get_bits_from_value(rtt_park, 2, 0) << 6) |
+			     get_bits_from_value(rddata, 5, 0)));
+	uartlog("Re-enable RTT_PARK\n");
+	KC_MSG("Re-enable RTT_PARK\n");
+
+#endif
+#ifdef DDR3
+	////read mr1 @INIT3
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	////DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	//  17. Re-enable RTT_PARK (DDR4 only) and RTT_NOM by performing MRS commands (if required).
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	//cvx16_synp_mrw(0x1,
+	//		{rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rtt_nom, 2, 2) << 9 |
+				    get_bits_from_value(rddata, 8, 7) << 7 | get_bits_from_value(rtt_nom, 1, 1) << 5 |
+				    get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rtt_nom, 0, 0) << 2 |
+				    get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+	uartlog("Re-enable RTT_NOM\n");
+	KC_MSG("Re-enable RTT_NOM\n");
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	opdelay(600); // don't remove. wait tDLLK ??
+#endif
+#ifdef DDR2
+	// reset the DLL
+	// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+	// The uMCTL2 sets this bit appropriately.
+	// read EMR1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	////DDR2: Write ????to EMR1
+	////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	KC_MSG("15. Perform an MRS command\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		////read mr1 @INIT3
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		////DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+		//  17. Re-enable RTT_PARK (DDR4 only) and RTT_NOM by performing MRS commands (if required).
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		//cvx16_synp_mrw(0x1,
+		//{rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 |
+				get_bits_from_value(rtt_nom, 2, 2) << 9 |
+				get_bits_from_value(rddata, 8, 7) << 7 |
+				get_bits_from_value(rtt_nom, 1, 1) << 5 |
+				get_bits_from_value(rddata, 5, 3) << 3 |
+				get_bits_from_value(rtt_nom, 0, 0) << 2 |
+				get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+		uartlog("Re-enable RTT_NOM\n");
+		KC_MSG("Re-enable RTT_NOM\n");
+
+		// read mr0 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+		// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+		// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+					get_bits_from_value(rddata, 23, 16));
+		opdelay(600); // don't remove. wait tDLLK ??
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2)	{
+		// reset the DLL
+		// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+		// The uMCTL2 sets this bit appropriately.
+		// read EMR1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		////DDR2: Write ????to EMR1
+		////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+					get_bits_from_value(rddata, 23, 16));
+		KC_MSG("15. Perform an MRS command\n");
+	}
+#endif
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3);
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1);
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	uartlog("restore selfref_en powerdown_en\n");
+#ifdef DDR4
+	rddata = mmio_rd32(0x0b0c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) << 1), 6, 0);
+	mmio_wr32(0x0b0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0b3c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) << 1), 6, 0);
+	mmio_wr32(0x0b3c + PHYD_BASE_ADDR, rddata);
+	cvx16_dll_sw_upd();
+#endif
+	cvx16_clk_gating_disable();
+	for (int i = 0; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	//KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	//        rddata[0], rddata[9:8], rddata[5:4]);
+
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	KC_MSG("LTOH Frequency Change Finished\n");
+}
+
+void cvx16_set_dq_vref(uint32_t vref)
+{
+#ifdef DDR4
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	uint32_t mr6_tmp;
+#endif //DDR4
+	uartlog("cvx16_set_dq_vref\n");
+	ddr_debug_wr32(0x3b);
+	ddr_debug_num_write();
+#ifdef DDR4
+	// save lowpower setting
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// en_dfi_dram_clk_disable = rddata[3];
+	//  powerdown_en            = rddata[1];
+	//  selfref_en              = rddata[0];
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// dis_auto_refresh = 1
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	// read mr6 @INIT7
+	rddata = mmio_rd32(cfg_base + 0xec);
+	rddata = modified_bits_by_value(rddata, vref, 6, 0);
+	mr6_tmp = modified_bits_by_value(rddata, 1, 7, 7);
+	cvx16_synp_mrw(0x6, mr6_tmp);
+	uartlog("vrefDQ Training Enable\n");
+	KC_MSG("vrefDQ Training Enable\n");
+
+	opdelay(150);
+	cvx16_synp_mrw(0x6, mr6_tmp);
+	uartlog("vrefDQ set\n");
+	opdelay(150);
+	mr6_tmp = modified_bits_by_value(mr6_tmp, 0, 7, 7);
+	cvx16_synp_mrw(0x6, mr6_tmp);
+	uartlog("vrefDQ Training disable\n");
+	KC_MSG("vrefDQ Training disable\n");
+
+	opdelay(150);
+	// dis_auto_refresh = 0
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	// restore
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x0; //PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	// rddata[3] = en_dfi_dram_clk_disable; //PWRCTL.en_dfi_dram_clk_disable
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3);
+	// rddata[1] = powerdown_en; //PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1);
+	// rddata[0] = selfref_en; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	uartlog("restore selfref_en powerdown_en\n");
+#endif
+#ifdef DDR3
+	// f0_param_phya_reg_tx_vref_sel	[20:16]
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, vref, 20, 16);
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+#endif
+#ifdef DDR2
+	// f0_param_phya_reg_tx_vref_sel	[20:16]
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, vref, 20, 16);
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// f0_param_phya_reg_tx_vref_sel	[20:16]
+		rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref, 20, 16);
+		mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2)	{
+		// f0_param_phya_reg_tx_vref_sel	[20:16]
+		rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref, 20, 16);
+		mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	}
+#endif
+}
+
+void cvx16_set_dfi_init_start(void)
+{
+	// synp setting
+	// phy is ready for initial dfi_init_start request
+	// set umctl2 to tigger dfi_init_start
+	uartlog("cvx16_set_dfi_init_start\n");
+	ddr_debug_wr32(0x0d);
+	ddr_debug_num_write();
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001b0); // dfi_init_start @ rddata[5];
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	mmio_wr32(cfg_base + 0x000001b0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 1);
+	KC_MSG("dfi_init_start finish\n");
+}
+
+void cvx16_ddr_phya_pd(void)
+{
+	uartlog("cvx16_ddr_phya_pd\n");
+	ddr_debug_wr32(0x3d);
+	ddr_debug_num_write();
+	// ----------- PHY oen/pd reset ----------------
+	// OEN
+	// param_phyd_tx_ca_oenz         0
+	// param_phyd_tx_ca_clk0_oenz    8
+	// param_phyd_tx_ca_clk1_oenz    16
+	rddata = 0x00010101;
+	mmio_wr32(0x0130 + PHYD_BASE_ADDR, rddata);
+	// PD
+	// TOP_REG_TX_CA_PD_CA       22	0
+	// TOP_REG_TX_CA_PD_CKE0     24	24
+	// TOP_REG_TX_CLK_PD_CLK0    26	26
+	// TOP_REG_TX_CA_PD_CSB0     28	28
+	// TOP_REG_TX_CA_PD_RESETZ   30	30
+	// TOP_REG_TX_ZQ_PD          31	31
+	// rddata[31:0] = 0x947f_ffff;
+	rddata = 0x947fffff;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("All PHYA CA PD=0 ...\n");
+
+	// TOP_REG_TX_BYTE0_PD	0
+	// TOP_REG_TX_BYTE1_PD	1
+	rddata = 0x00000003;
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TX_BYTE PD=0 ...\n");
+
+	// OEN
+	// param_phyd_sel_cke_oenz        <= `PI_SD int_regin[0];
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	// rddata[0] = 0b1;
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	uartlog("[KC Info] : CKE and RESETZ oenz\n");
+
+	// PD
+	// All PHYA PD=0
+	rddata = 0xffffffff;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	uartlog("[KC Info] : RESETZ CKE PD !!!\n\n");
+
+	// PLL PD
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	// rddata[15]   = 1;    //TOP_REG_DDRPLL_PD
+	rddata = modified_bits_by_value(rddata, 1, 15, 15);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("PLL PD\n");
+
+	// ----------- PHY oen/pd reset ----------------
+}
+
+void cvx16_ddr_phyd_save(uint32_t sram_base_addr)
+{
+	int sram_offset = 0;
+
+	uartlog("cvx16_ddr_phyd_save\n");
+	ddr_debug_wr32(0x46);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xc + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x10 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x14 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x18 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x1c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x20 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x24 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x28 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x2c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x40 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x44 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x48 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x4c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x50 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x54 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x58 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x5c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x60 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x64 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x68 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x70 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x74 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x80 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x84 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x88 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x8c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x90 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x94 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xac + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xbc + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xf0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xf4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xf8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xfc + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x100 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x104 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x10c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x110 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x114 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x118 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x11c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x120 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x124 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x128 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x12c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x130 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x134 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x138 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x140 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x144 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x148 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x14c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x150 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x154 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x158 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x15c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x164 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x168 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x16c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x170 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x174 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x180 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x184 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x188 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x18c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x190 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x200 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x204 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x208 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x220 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x224 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x228 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x400 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x404 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x408 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x40c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x410 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x414 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x418 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x41c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x500 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x504 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x508 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x50c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x510 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x514 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x518 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x51c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x520 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x540 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x544 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x548 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x54c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x550 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x554 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x558 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x55c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x560 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x900 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	// rddata = mmio_rd32(0x904 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x908 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x90c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x910 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x914 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x918 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x91c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x920 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x924 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x928 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	rddata = mmio_rd32(0x92c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x930 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x934 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x938 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x940 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	// rddata = mmio_rd32(0x944 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x948 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x94c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x950 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x954 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x958 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x95c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x960 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x964 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x968 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x96c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	rddata = mmio_rd32(0x970 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x974 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x978 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x97c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x980 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa00 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa04 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa08 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa0c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa10 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa14 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa18 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa1c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa20 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa24 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa28 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa2c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa30 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa34 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa38 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa3c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa40 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa44 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa48 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa4c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa50 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa54 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa58 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa5c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa60 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa64 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa68 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa6c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa70 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa74 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa78 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa7c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb00 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb04 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb08 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb0c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb10 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb14 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb18 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb1c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb20 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb24 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb30 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb34 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb38 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb3c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb40 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb44 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb48 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb4c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb50 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb54 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+}
+
+void cvx16_ddr_phyd_restore(uint32_t sram_base_addr)
+{
+	int sram_offset = 0x0;
+	{
+		uartlog("cvx16_ddr_phyd_restore\n");
+		ddr_debug_wr32(0x47);
+		ddr_debug_num_write();
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xc + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x10 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x14 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x18 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x1c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x20 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x24 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x28 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x2c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x44 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x48 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x4c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x50 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x54 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x58 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x5c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x60 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x64 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x68 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x70 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x74 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x80 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x84 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x88 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x8c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x90 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x94 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xac + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xbc + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xf0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xf4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xf8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xfc + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x100 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x104 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x10c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x110 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x114 + PHYD_BASE_ADDR, rddata);
+		// reset param_phyd_clkctrl_init_complete
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x118 + PHYD_BASE_ADDR, rddata & 0x00000000);
+		//------------------------------------------------------------
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x11c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x120 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x124 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x128 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x12c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// mmio_wr32    ( 0x130 + PHYD_BASE_ADDR, rddata );
+		// ca oenz set by c-code
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x134 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x138 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x140 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x144 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x148 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x14c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x150 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// param_phyd_sel_cke_oenz=1
+		mmio_wr32(0x154 + PHYD_BASE_ADDR, (rddata | 0x00000001));
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x158 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x15c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x164 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x168 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x16c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x170 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x174 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x180 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x184 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x188 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x18c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x190 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x200 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline =0
+		mmio_wr32(0x204 + PHYD_BASE_ADDR, (rddata & 0xFFFBFFFF));
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x208 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x220 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// param_phya_reg_tx_byte1_en_extend_oenz_gated_dline =0
+		mmio_wr32(0x224 + PHYD_BASE_ADDR, (rddata & 0xFFFBFFFF));
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x228 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x400 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x404 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x408 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x40c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x410 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x414 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x418 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x41c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x500 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x504 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x508 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x50c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x510 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x514 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x518 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x51c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x520 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x540 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x544 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x548 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x54c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x550 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x554 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x558 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x55c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x560 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x900 + PHYD_BASE_ADDR, rddata);
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x904 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x908 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x90c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x910 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x914 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x918 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x91c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x920 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x924 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x928 + PHYD_BASE_ADDR, rddata );
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x92c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x930 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x934 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x938 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x940 + PHYD_BASE_ADDR, rddata);
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x944 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x948 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x94c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x950 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x954 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x958 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x95c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x960 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x964 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x968 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x96c + PHYD_BASE_ADDR, rddata );
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x970 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x974 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x978 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x97c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x980 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa00 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa04 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa08 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa0c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa10 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa14 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa18 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa1c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa20 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa24 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa28 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa2c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa30 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa34 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa38 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa3c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa44 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa48 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa4c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa50 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa54 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa58 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa5c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa60 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa64 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa68 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa6c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa70 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa74 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa78 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa7c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb00 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb04 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb08 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb0c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb10 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb14 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb18 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb1c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb20 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb24 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb30 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb34 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb38 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb3c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb44 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb48 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb4c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb50 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb54 + PHYD_BASE_ADDR, rddata);
+	}
+}
+
+void cvx16_dll_sw_upd(void)
+{
+	uartlog("cvx16_dll_sw_upd\n");
+	ddr_debug_wr32(0x4B);
+	ddr_debug_num_write();
+	rddata = 0x1;
+	mmio_wr32(0x0170 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x302C + PHYD_BASE_ADDR);
+		if (rddata == 0xffffffff) {
+			break;
+		}
+		KC_MSG("DLL SW UPD finish\n");
+	}
+}
+
+void cvx16_bist_mask_shift_delay(uint32_t shift_delay, uint32_t en_lead)
+{
+	uint8_t shift_tmp;
+	uint8_t delay_tmp;
+	uint8_t dlie_sub;
+
+	uartlog("cvx16_bist_mask_shift_delay\n");
+	ddr_debug_wr32(0x4b);
+	ddr_debug_num_write();
+	//{shift_tmp, delay_tmp} = shift_delay;
+	shift_tmp = get_bits_from_value(shift_delay, 12, 7);
+	delay_tmp = get_bits_from_value(shift_delay, 6, 0);
+	if (shift_tmp > en_lead) {
+		dlie_sub = shift_tmp - en_lead;
+	} else {
+		dlie_sub = 0;
+	}
+	rddata = 0x00000000;
+	rddata = shift_tmp << 8 | delay_tmp;
+	mmio_wr32(0x0B0C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0B3C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	rddata = dlie_sub << 24 | dlie_sub << 8;
+	mmio_wr32(0x0B10 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0B40 + PHYD_BASE_ADDR, rddata);
+	cvx16_dll_sw_clr();
+	KC_MSG("cvx16_bist_mask_shift_delay Fisish\n");
+}
+
+void cvx16_set_dq_trig_lvl(uint32_t trig_lvl)
+{
+	uartlog("cvx16_set_dq_trig_lvl\n");
+	ddr_debug_wr32(0x4c);
+	ddr_debug_num_write();
+	rddata = 0x00000000;
+	rddata = trig_lvl << 16 | trig_lvl;
+	mmio_wr32(0x0B24 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0B54 + PHYD_BASE_ADDR, rddata);
+}
+
+void cvx16_pll_init(void)
+{
+	// opdelay(10);
+	uartlog("pll_init\n");
+	ddr_debug_wr32(0x00);
+	ddr_debug_num_write();
+	// TX_VREF_PD
+	rddata = 0x00000000;
+	mmio_wr32(0x28 + CV_DDR_PHYD_APB, rddata);
+	// ZQ_240 OPTION
+	rddata = 0x00080001;
+	mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+#ifdef DDR3
+// GPO setting
+#ifdef _mem_freq_2133
+	rddata = 0x01000808; // TOP_REG_TX_DDR3_GPO_IN =0
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+#else
+	rddata = 0x01010808; // TOP_REG_TX_DDR3_GPO_IN =1
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+#endif
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = 0x01010808; // TOP_REG_TX_DDR3_GPO_IN =1
+		mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	}
+#endif
+#ifdef SSC_EN
+	//==============================================================
+	// Enable SSC
+	//==============================================================
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	KC_MSG("reg_step = %lx\n", reg_step);
+
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 1, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // extpulse
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_EN\n");
+#else
+#ifdef SSC_BYPASS
+	rddata = (reg_set & 0xfc000000) + 0x04000000; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 1, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_BYPASS\n");
+#else
+	//==============================================================
+	// SSC_EN =0
+	//==============================================================
+	uartlog("SSC_EN =0\n");
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_OFF\n");
+#endif // SSC_BYPASS
+#endif // SSC_EN
+	// opdelay(1000);
+	// DDRPLL setting
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	//[0]    = 1;      //TOP_REG_DDRPLL_EN_DLLCLK
+	//[1]    = 1;      //TOP_REG_DDRPLL_EN_LCKDET
+	//[2]    = 0;      //TOP_REG_DDRPLL_EN_TST
+	//[5:3]  = 0b001; //TOP_REG_DDRPLL_ICTRL
+	//[6]    = 0;      //TOP_REG_DDRPLL_MAS_DIV_SEL
+	//[7]    = 0;      //TOP_REG_DDRPLL_MAS_RSTZ_DIV
+	//[8]    = 1;      //TOP_REG_DDRPLL_SEL_4BIT
+	//[10:9] = 0b01;  //TOP_REG_DDRPLL_SEL_MODE
+	//[12:11]= 0b00;  //Rev
+	//[13]   = 0;      //TOP_REG_DDRPLL_SEL_LOW_SPEED
+	//[14]   = 0;      //TOP_REG_DDRPLL_MAS_DIV_OUT_SEL
+	//[15]   = 0;      //TOP_REG_DDRPLL_PD
+	rddata = modified_bits_by_value(rddata, 0x030b, 15, 0);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+	//[7:0] = 0x0;   //TOP_REG_DDRPLL_TEST
+	rddata = modified_bits_by_value(rddata, 0, 7, 0); // TOP_REG_DDRPLL_TEST
+	mmio_wr32(0x10 + CV_DDR_PHYD_APB, rddata);
+	//[0]   = 1;    //TOP_REG_RESETZ_DIV
+	rddata = 0x1;
+	mmio_wr32(0x04 + CV_DDR_PHYD_APB, rddata);
+	uartlog("RSTZ_DIV=1\n");
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	//[7]   = 1;    //TOP_REG_DDRPLL_MAS_RSTZ_DIV
+	rddata = modified_bits_by_value(rddata, 1, 7, 7);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("Wait for DRRPLL LOCK=1... pll init\n");
+
+	uartlog("Start DRRPLL LOCK pll init\n");
+#ifdef REAL_LOCK
+	while (1) {
+		rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+		if (get_bits_from_value(rddata, 15, 15)) {
+			break;
+		}
+	}
+#else
+	KC_MSG("check PLL lock...  pll init\n");
+
+#endif
+	uartlog("End DRRPLL LOCK=1... pll init\n");
+	KC_MSG("PLL init finish !!!\n");
+}
+
+void cvx16_lb_0_phase40(void)
+{
+	uint32_t i, j;
+
+	KC_MSG("DQ loop back test -IO internal loop back-\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_0\n");
+	ddr_debug_wr32(0x4F);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	rddata = 0x00404000;
+	for (j = 0; j < 2; j = j + 1) {
+		mmio_wr32(0x0B08 + j * 0x30 + PHYD_BASE_ADDR, rddata);
+	}
+	KC_MSG("rddata= %x\n", rddata);
+
+	cvx16_dll_sw_upd();
+	rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_lb_dq_en
+	rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	rddata = modified_bits_by_value(rddata, 1, 1, 1); // param_phyd_lb_dq_go
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("wait for param_phyd_to_reg_lb_dq0_doing\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq1_doing\n");
+
+	while (1) {
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 1, 0) == 0x3) {
+			break;
+		}
+	}
+	KC_MSG("param_phyd_to_reg_lb_dq0_doing = 1\n");
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_doing = 1\n");
+
+	uartlog("\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq0_syncfound\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq1_syncfound\n");
+
+	while (1) {
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 9, 8) == 0x3) {
+			break;
+		}
+	}
+	KC_MSG("param_phyd_to_reg_lb_dq0_syncfound = 1\n");
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_syncfound = 1\n");
+
+	uartlog("\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq0_startfound\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq1_startfound\n");
+
+	while (1) {
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 17, 16) == 0x3) {
+			break;
+		}
+	}
+	KC_MSG("param_phyd_to_reg_lb_dq0_startfound = 1\n");
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_startfound = 1\n");
+
+	// opdelay(1000);
+	// Read param_phyd_to_reg_lb_dq_fail
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+	uartlog("\n");
+
+	if (get_bits_from_value(rddata, 25, 24) != 0) {
+		KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+	}
+	// opdelay(1000);
+	// Read param_phyd_to_reg_lb_dq_fail
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+	uartlog("\n");
+
+	if (get_bits_from_value(rddata, 25, 24) != 0) {
+		KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+	}
+	// opdelay(1000);
+	// Read param_phyd_to_reg_lb_dq_fail
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+	uartlog("\n");
+
+	if (get_bits_from_value(rddata, 25, 24) != 0) {
+		KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+	}
+	uartlog("lb0 runing\n");
+}
+
+void cvx16_lb_0_external(void)
+{
+	uint32_t i, j;
+
+	KC_MSG("DQ loop back test - with front-} (Drivier / Receiver)-\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_0_external\n");
+	ddr_debug_wr32(0x4F);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	rddata = 0x00000000;
+	for (i = 0x00404000; i <= 0x00505000; i = i + 0x00101000) {
+		if (i == 0x00808000) {
+			rddata = 0x007f7f00;
+		} else {
+			rddata = i;
+		}
+		for (j = 0; j < 2; j = j + 1) {
+			mmio_wr32(0x0B08 + j * 0x30 + PHYD_BASE_ADDR, rddata);
+		}
+		KC_MSG("rddata= %x\n", rddata);
+
+		cvx16_dll_sw_upd();
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 1, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_doing\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_doing\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 1, 0) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_doing = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_doing = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_syncfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_syncfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 9, 8) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_syncfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_syncfound = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_startfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_startfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 17, 16) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_startfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_startfound = 1\n");
+
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail i Found ...\n");
+		}
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	}
+
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	// repeat(50) @(posedge axi3_ACLK);
+	uartlog("PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_1_dq_set_highlow(void)
+{
+	uint32_t i;
+	uint32_t pattern;
+
+	KC_MSG("DQ set highlow test\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_1_dq_set_highlow\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x0400001C;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_lb_sw_oenz_dout0      0
+	// param_phyd_lb_sw_oenz_dout1      1
+	// param_phyd_lb_sw_dqsn0           4
+	// param_phyd_lb_sw_dqsn1           5
+	// param_phyd_lb_sw_dqsp0           8
+	// param_phyd_lb_sw_dqsp1           9
+	// param_phyd_lb_sw_oenz_dqs_dout0  12
+	// param_phyd_lb_sw_oenz_dqs_dout1  13
+	rddata = 0x00003333;
+	mmio_wr32(0x010C + PHYD_BASE_ADDR, rddata);
+	// pattern all 0
+	rddata = 0x00000000;
+	mmio_wr32(0x0104 + PHYD_BASE_ADDR, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+	if (get_bits_from_value(rddata, 8, 0) != 0x000) {
+		KC_MSG("Error!!! RX loop back din0[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din0[8:0] is Pass..\n");
+	}
+	if (get_bits_from_value(rddata, 24, 16) != 0x000) {
+		KC_MSG("Error!!! RX loop back din1[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din1[8:0] is Pass..\n");
+	}
+	// pattern all 1
+	rddata = 0x01ff01ff;
+	mmio_wr32(0x0104 + PHYD_BASE_ADDR, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+	if (get_bits_from_value(rddata, 8, 0) != 0x1ff) {
+		KC_MSG("Error!!! RX loop back din0[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din0[8:0] is Pass..\n");
+	}
+	if (get_bits_from_value(rddata, 24, 16) != 0x1ff) {
+		KC_MSG("Error!!! RX loop back din1[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din1[8:0] is Pass..\n");
+	}
+	// pattern one hot
+	pattern = 0x1;
+	for (i = 0; i < 22; i = i + 1) {
+		uartlog("[DBG] YD, i= %x, pattern =%x\n", i, pattern);
+
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 8, 0), 8, 0);
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 17, 9), 24, 16);
+		mmio_wr32(0x0104 + PHYD_BASE_ADDR, rddata);
+		if (i < 18) {
+			rddata = mmio_rd32(0x010C + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, 0x3, 5, 4);
+			rddata = modified_bits_by_value(rddata, 0x3, 9, 8);
+			mmio_wr32(0x010C + PHYD_BASE_ADDR, rddata);
+		} else {
+			rddata = mmio_rd32(0x010C + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 19, 18), 5, 4);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 21, 20), 9, 8);
+		}
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 8, 0) != get_bits_from_value(pattern, 8, 0)) {
+			KC_MSG("Error!!! RX loop back din0[8:0] is not correct...\n");
+		} else {
+			KC_MSG("Pass!!! RX loop back din0[8:0] is Pass..\n");
+		}
+		if (get_bits_from_value(rddata, 24, 16) != get_bits_from_value(pattern, 17, 9)) {
+			KC_MSG("Error!!! RX loop back din1[8:0] is not correct...\n");
+		} else {
+			KC_MSG("Pass!!! RX loop back din1[8:0] is Pass..\n");
+		}
+		pattern = pattern << 1;
+	}
+	i = 0;
+	pattern = 0x1;
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000000;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	uartlog("LB_1 PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_2_mux_demux(void)
+{
+	uint32_t i, j;
+
+	KC_MSG("DQ loop back test 2 -DEMUX/MUX internal loop back-\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_2_mux_demux\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00004440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	rddata = 0x00000000;
+	for (i = 0x00404000; i <= 0x00404000; i = i + 0x00101000) {
+		if (i == 0x00808000) {
+			rddata = 0x007f7f00;
+		} else {
+			rddata = i;
+		}
+		for (j = 0; j < 2; j = j + 1) {
+			mmio_wr32(0x0B08 + j * 0x30 + PHYD_BASE_ADDR, rddata);
+		}
+		KC_MSG("rddata= %x\n", rddata);
+
+		cvx16_dll_sw_upd();
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 1, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_doing\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_doing\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 1, 0) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_doing = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_doing = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_syncfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_syncfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 9, 8) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_syncfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_syncfound = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_startfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_startfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 17, 16) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_startfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_startfound = 1\n");
+
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	}
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	// repeat(50) @(posedge axi3_ACLK);
+	uartlog("PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_3_ca_set_highlow(void)
+{
+	uint32_t i;
+	uint32_t pattern;
+	uint32_t rddata_addr;
+	uint32_t rddata_ctrl;
+
+	KC_MSG("CA set highlow test\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_3_ca_set_highlow\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000004;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0134 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x1, 2, 2); // param_phya_reg_tx_ca_en_ca_loop_back
+	mmio_wr32(0x0134 + PHYD_BASE_ADDR, rddata);
+	// GPO
+	// TOP_REG_TX_DDR3_GPO_DRVN	    [4:	    0]
+	// TOP_REG_TX_DDR3_GPO_DRVP	    [12:	8]
+	// TOP_REG_TX_DDR3_GPO_IN	    [16:	16]
+	// TOP_REG_TX_DDR3_GPO_OENZ	    [17:	17]
+	// TOP_REG_TX_DDR3_GPO_PD_GPO	[18:	18]
+	// TOP_REG_TX_DDR3_GPO_SEL_GPIO	[19:	19]
+	rddata = 0x01010808; // TOP_REG_TX_DDR3_GPO_IN =1
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x58 + CV_DDR_PHYD_APB);
+	if (get_bits_from_value(rddata, 28, 28) != 0x1) {
+		KC_MSG("Error!!! GPO test Fail\n");
+	} else {
+		KC_MSG("Pass!!! GPO test pass\n");
+	}
+	rddata = 0x01000808; // TOP_REG_TX_DDR3_GPO_IN =0
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x58 + CV_DDR_PHYD_APB);
+	if (get_bits_from_value(rddata, 28, 28) != 0x0) {
+		KC_MSG("Error!!! GPO test Fail\n");
+	} else {
+		KC_MSG("Pass!!! GPO test pass\n");
+	}
+	// pattern all 0
+	rddata_addr = 0x00000000;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00000000;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [16:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern all 1
+	rddata_addr = 0x007fffff;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00010011;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern 01
+	rddata_addr = 0x00555555;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00000010;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern 10
+	rddata_addr = 0x002aaaaa;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00010001;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern one hot
+	pattern = 0x1;
+	for (i = 0; i < 25; i = i + 1) {
+		uartlog("[DBG] YD, i= %x, pattern =%x\n", i, pattern);
+
+		rddata_addr = 0x00000000;
+		rddata_addr = modified_bits_by_value(rddata_addr, get_bits_from_value(pattern, 22, 0), 22, 0);
+		mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr);
+		// param_phyd_lb_sw_clkn0_dout   0
+		// param_phyd_lb_sw_clkp0_dout   4
+		// param_phyd_lb_sw_cke0_dout    8
+		// param_phyd_lb_sw_resetz_dout  12
+		// param_phyd_lb_sw_csb0_dout    16
+		rddata_ctrl = 0x00000000;
+		rddata_ctrl = modified_bits_by_value(rddata_ctrl, get_bits_from_value(pattern, 23, 23), 0, 0);
+		rddata_ctrl = modified_bits_by_value(rddata_ctrl, get_bits_from_value(pattern, 24, 24), 4, 4);
+		rddata_ctrl = modified_bits_by_value(rddata_ctrl, get_bits_from_value(pattern, 25, 25), 16, 16);
+		mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+		if (rddata != rddata_addr) {
+			KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+		} else {
+			KC_MSG("Pass!!! CA[22:0] is Pass..\n");
+		}
+		rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+		if (rddata != rddata_ctrl) {
+			KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+		} else {
+			KC_MSG("Pass!!! other pin [8:0]\n");
+		}
+		pattern = pattern << 1;
+	}
+	i = 0;
+	pattern = 0x1;
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000000;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	uartlog("LB_3 PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_4_ca_clk_pat(void)
+{
+	uint32_t i;
+	// uint32_t pattern; //unused
+	// uint32_t rddata_addr; //unused
+	// uint32_t rddata_ctrl; //unused
+	KC_MSG("%s test\n", __func__);
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_4_ca_clk_pat\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	// CKE/RESETN
+	rddata = 0x00000067; // TOP_REG_TX_CA_SEL_GPIO_CKE0  [2] = 1
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	rddata = 0x40000000; // TOP_REG_TX_CA_PD_RESETZ [30] = 1
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000044;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0134 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x1, 2, 2); // param_phya_reg_tx_ca_en_ca_loop_back
+	mmio_wr32(0x0134 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_ca_en_tx_de     24
+	// param_phya_reg_tx_clk0_en_tx_de   28
+	// param_phya_reg_tx_csb_en_tx_de    30
+	rddata = 0x51000000;
+	mmio_wr32(0x0404 + PHYD_BASE_ADDR, rddata);
+	// clock pattern
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != 0x007fffff) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if ((rddata & 0x00010011) != 0x00010011) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000000;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	uartlog("LB_4 PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_clk_gating_disable(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x4C);
+	ddr_debug_num_write();
+	// TOP_REG_CG_EN_PHYD_TOP      0
+	// TOP_REG_CG_EN_CALVL         1
+	// TOP_REG_CG_EN_WRLVL         2
+	// N/A                         3
+	// TOP_REG_CG_EN_WRDQ          4
+	// TOP_REG_CG_EN_RDDQ          5
+	// TOP_REG_CG_EN_PIGTLVL       6
+	// TOP_REG_CG_EN_RGTRACK       7
+	// TOP_REG_CG_EN_DQSOSC        8
+	// TOP_REG_CG_EN_LB            9
+	// TOP_REG_CG_EN_DLL_SLAVE     10 //0:a-on
+	// TOP_REG_CG_EN_DLL_MST       11 //0:a-on
+	// TOP_REG_CG_EN_ZQ            12
+	// TOP_REG_CG_EN_PHY_PARAM     13 //0:a-on
+	// TOP_REG_CG_EN_PHYA_GATED    14 //1: clock gating enable from controller
+	//                                  0:from TOP_REG_DDRPLL_CLK_OUT_GATED_EN
+	// 0b01001011110101
+	rddata = 0x000012F5;
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	rddata = 0x00000000;
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, rddata); // PHYD_SHIFT_GATING_EN
+	rddata = mmio_rd32(cfg_base + 0x30); // phyd_stop_clk
+	rddata = modified_bits_by_value(rddata, 0, 9, 9); //en_phyd_stop_clk
+	//rddata = modified_bits_by_value(rddata, 0, 10, 10 ); //phyd_stop_clk_sel, 1: old, 0: new
+	rddata = modified_bits_by_value(rddata, 0, 11, 11); //en_phya_stop_clk
+	//rddata = modified_bits_by_value(rddata, 0, 12, 12 ); //phya_stop_clk_sel, 1: old, 0: new
+	mmio_wr32(cfg_base + 0x30, rddata);
+	rddata = mmio_rd32(cfg_base + 0x148); // dfi read/write clock gatting
+	rddata = modified_bits_by_value(rddata, 0, 23, 23);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(cfg_base + 0x148, rddata);
+	KC_MSG("clk_gating_disable\n");
+
+	// disable clock gating
+	// mmio_wr32(0x0800_a000 + 0x14 , 0x00000fff);
+	// KC_MSG("axi disable clock gating\n");
+}
+
+void cvx16_clk_gating_enable(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x4D);
+	ddr_debug_num_write();
+	// TOP_REG_CG_EN_PHYD_TOP      0
+	// TOP_REG_CG_EN_CALVL         1
+	// TOP_REG_CG_EN_WRLVL         2
+	// N/A                         3
+	// TOP_REG_CG_EN_WRDQ          4
+	// TOP_REG_CG_EN_RDDQ          5
+	// TOP_REG_CG_EN_PIGTLVL       6
+	// TOP_REG_CG_EN_RGTRACK       7
+	// TOP_REG_CG_EN_DQSOSC        8
+	// TOP_REG_CG_EN_LB            9
+	// TOP_REG_CG_EN_DLL_SLAVE     10 //0:a-on
+	// TOP_REG_CG_EN_DLL_MST       11 //0:a-on
+	// TOP_REG_CG_EN_ZQ            12
+	// TOP_REG_CG_EN_PHY_PARAM     13 //0:a-on
+	// TOP_REG_CG_EN_PHYA_GATED    14 //1: clock gating enable from controller
+	//                                  0:from TOP_REG_DDRPLL_CLK_OUT_GATED_EN
+	// 0b10110010000001
+	rddata = 0x00006C81;
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	//    #ifdef _mem_freq_1333
+	//    #ifdef DDR2
+	rddata = mmio_rd32(cfg_base + 0x190);
+	rddata = modified_bits_by_value(rddata, 6, 28, 24);
+	mmio_wr32(cfg_base + 0x190, rddata);
+	//    #endif
+	rddata = 0x00030033;
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, rddata); // PHYD_SHIFT_GATING_EN
+	rddata = mmio_rd32(cfg_base + 0x30); // phyd_stop_clk
+	rddata = modified_bits_by_value(rddata, 1, 9, 9); //en_phyd_stop_clk
+	rddata = modified_bits_by_value(rddata, 0, 10, 10); //phyd_stop_clk_sel, 1: old, 0: new
+	rddata = modified_bits_by_value(rddata, 1, 11, 11); //en_phya_stop_clk
+	rddata = modified_bits_by_value(rddata, 0, 12, 12); //phya_stop_clk_sel, 1: old, 0: new
+	mmio_wr32(cfg_base + 0x30, rddata);
+	rddata = mmio_rd32(cfg_base + 0x148); // dfi read/write clock gatting
+	rddata = modified_bits_by_value(rddata, 1, 23, 23);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x148, rddata);
+	KC_MSG("clk_gating_enable\n");
+
+	// disable clock gating
+	// mmio_wr32(0x0800_a000 + 0x14 , 0x00000fff);
+	// KC_MSG("axi disable clock gating\n");
+}
+
+void cvx16_dfi_phyupd_req(void)
+{
+	uint32_t ca_raw_upd;
+	uint32_t byte0_wr_raw_upd;
+	uint32_t byte1_wr_raw_upd;
+	uint32_t byte0_wdqs_raw_upd;
+	uint32_t byte1_wdqs_raw_upd;
+	uint32_t byte0_rd_raw_upd;
+	uint32_t byte1_rd_raw_upd;
+	uint32_t byte0_rdg_raw_upd;
+	uint32_t byte1_rdg_raw_upd;
+	uint32_t byte0_rdqs_raw_upd;
+	uint32_t byte1_rdqs_raw_upd;
+
+	ca_raw_upd = 0x00000001 << 0;
+	byte0_wr_raw_upd = 0x00000001 << 4;
+	byte1_wr_raw_upd = 0x00000001 << 5;
+	byte0_wdqs_raw_upd = 0x00000001 << 8;
+	byte1_wdqs_raw_upd = 0x00000001 << 9;
+	byte0_rd_raw_upd = 0x00000001 << 12;
+	byte1_rd_raw_upd = 0x00000001 << 13;
+	byte0_rdg_raw_upd = 0x00000001 << 16;
+	byte1_rdg_raw_upd = 0x00000001 << 17;
+	byte0_rdqs_raw_upd = 0x00000001 << 20;
+	byte1_rdqs_raw_upd = 0x00000001 << 21;
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x54);
+	ddr_debug_num_write();
+	// if ($test$plusargs("")) {
+	//}
+	// RAW DLINE_UPD
+	rddata = ca_raw_upd;
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0174 + PHYD_BASE_ADDR);
+}
+
+void cvx16_en_rec_vol_mode(void)
+{
+	uartlog("cvx16_en_rec_vol_mode\n");
+	ddr_debug_wr32(0x54);
+	ddr_debug_num_write();
+#ifdef DDR2
+	rddata = 0x00001001;
+	mmio_wr32(0x0500 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0540 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("cvx16_en_rec_vol_mode done\n");
+
+#endif
+}
+
+void cvx16_dll_sw_clr(void)
+{
+	uint32_t phyd_stop_clk;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x56);
+	ddr_debug_num_write();
+	phyd_stop_clk = mmio_rd32(cfg_base + 0x30); // phyd_stop_clk
+	rddata = modified_bits_by_value(phyd_stop_clk, 0, 9, 9);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// param_phyd_sw_dfi_phyupd_req
+	rddata = 0x00000101;
+	mmio_wr32(0x0174 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		// param_phyd_to_reg_sw_phyupd_dline_done
+		rddata = mmio_rd32(0x3030 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 24, 24) == 0x1) {
+			break;
+		}
+	}
+	mmio_wr32(cfg_base + 0x30, phyd_stop_clk);
+}
+
+void cvx16_reg_toggle(void)
+{
+	uartlog("cvx16_reg_toggle\n");
+	ddr_debug_wr32(0x57);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x0 + PHYD_BASE_ADDR);
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x4 + PHYD_BASE_ADDR);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x8 + PHYD_BASE_ADDR);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xc + PHYD_BASE_ADDR);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x10 + PHYD_BASE_ADDR);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x14 + PHYD_BASE_ADDR);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x18 + PHYD_BASE_ADDR);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x20 + PHYD_BASE_ADDR);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x24 + PHYD_BASE_ADDR);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x28 + PHYD_BASE_ADDR);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x2c + PHYD_BASE_ADDR);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x40 + PHYD_BASE_ADDR);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x44 + PHYD_BASE_ADDR);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x48 + PHYD_BASE_ADDR);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x4c + PHYD_BASE_ADDR);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50 + PHYD_BASE_ADDR);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x54 + PHYD_BASE_ADDR);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x58 + PHYD_BASE_ADDR);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x5c + PHYD_BASE_ADDR);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x60 + PHYD_BASE_ADDR);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x64 + PHYD_BASE_ADDR);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x68 + PHYD_BASE_ADDR);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x70 + PHYD_BASE_ADDR);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x74 + PHYD_BASE_ADDR);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x74 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x80 + PHYD_BASE_ADDR);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x84 + PHYD_BASE_ADDR);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x88 + PHYD_BASE_ADDR);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x8c + PHYD_BASE_ADDR);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x90 + PHYD_BASE_ADDR);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x94 + PHYD_BASE_ADDR);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa0 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa4 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa8 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xac + PHYD_BASE_ADDR);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb0 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb4 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb8 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xbc + PHYD_BASE_ADDR);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xf8 + PHYD_BASE_ADDR);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xfc + PHYD_BASE_ADDR);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x100 + PHYD_BASE_ADDR);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x104 + PHYD_BASE_ADDR);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x10c + PHYD_BASE_ADDR);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x110 + PHYD_BASE_ADDR);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x114 + PHYD_BASE_ADDR);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x118 + PHYD_BASE_ADDR);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x11c + PHYD_BASE_ADDR);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x120 + PHYD_BASE_ADDR);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x124 + PHYD_BASE_ADDR);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x128 + PHYD_BASE_ADDR);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x12c + PHYD_BASE_ADDR);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x130 + PHYD_BASE_ADDR);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x134 + PHYD_BASE_ADDR);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x138 + PHYD_BASE_ADDR);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x140 + PHYD_BASE_ADDR);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x144 + PHYD_BASE_ADDR);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x148 + PHYD_BASE_ADDR);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x74 + PHYD_BASE_ADDR);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x74 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x14c + PHYD_BASE_ADDR);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x150 + PHYD_BASE_ADDR);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x154 + PHYD_BASE_ADDR);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x158 + PHYD_BASE_ADDR);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x15c + PHYD_BASE_ADDR);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x168 + PHYD_BASE_ADDR);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x16c + PHYD_BASE_ADDR);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x170 + PHYD_BASE_ADDR);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x174 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x174 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x174 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x180 + PHYD_BASE_ADDR);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x184 + PHYD_BASE_ADDR);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x188 + PHYD_BASE_ADDR);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x18c + PHYD_BASE_ADDR);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x190 + PHYD_BASE_ADDR);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x200 + PHYD_BASE_ADDR);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x204 + PHYD_BASE_ADDR);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x204 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x208 + PHYD_BASE_ADDR);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x220 + PHYD_BASE_ADDR);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x224 + PHYD_BASE_ADDR);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x224 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x228 + PHYD_BASE_ADDR);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x400 + PHYD_BASE_ADDR);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x404 + PHYD_BASE_ADDR);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x408 + PHYD_BASE_ADDR);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x40c + PHYD_BASE_ADDR);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x410 + PHYD_BASE_ADDR);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x414 + PHYD_BASE_ADDR);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x418 + PHYD_BASE_ADDR);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x41c + PHYD_BASE_ADDR);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x41c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x500 + PHYD_BASE_ADDR);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x504 + PHYD_BASE_ADDR);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x508 + PHYD_BASE_ADDR);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50c + PHYD_BASE_ADDR);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x510 + PHYD_BASE_ADDR);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x514 + PHYD_BASE_ADDR);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x518 + PHYD_BASE_ADDR);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x51c + PHYD_BASE_ADDR);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x520 + PHYD_BASE_ADDR);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x540 + PHYD_BASE_ADDR);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x544 + PHYD_BASE_ADDR);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x548 + PHYD_BASE_ADDR);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x54c + PHYD_BASE_ADDR);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x550 + PHYD_BASE_ADDR);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x554 + PHYD_BASE_ADDR);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x558 + PHYD_BASE_ADDR);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x55c + PHYD_BASE_ADDR);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x560 + PHYD_BASE_ADDR);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x900 + PHYD_BASE_ADDR);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x904 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x904 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x904 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x908 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x908 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x908 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x90c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x90c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x90c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x910 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x910 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x910 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x914 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x914 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x914 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x918 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x918 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x918 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x91c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x91c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x91c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x920 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x920 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x920 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x924 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x924 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x924 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x928 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x928 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x928 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x92c + PHYD_BASE_ADDR);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x930 + PHYD_BASE_ADDR);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x934 + PHYD_BASE_ADDR);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x938 + PHYD_BASE_ADDR);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x940 + PHYD_BASE_ADDR);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x944 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x944 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x944 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x948 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x948 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x948 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x94c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x94c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x94c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x950 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x950 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x950 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x954 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x954 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x954 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x958 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x958 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x958 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x95c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x95c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x95c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x960 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x960 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x960 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x964 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x964 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x964 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x968 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x968 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x968 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x96c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x96c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x96c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x970 + PHYD_BASE_ADDR);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x974 + PHYD_BASE_ADDR);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x978 + PHYD_BASE_ADDR);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x97c + PHYD_BASE_ADDR);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x980 + PHYD_BASE_ADDR);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa00 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa04 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa08 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa0c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa10 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa14 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa18 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa1c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa20 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa24 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa28 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa2c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa30 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa34 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa38 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa3c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa40 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa44 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa48 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa4c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa50 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa54 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa58 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa5c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa60 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa64 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa68 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa6c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa70 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa74 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa78 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa7c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb00 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb04 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb08 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb0c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb10 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb14 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb18 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb1c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb20 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb24 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb30 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb34 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb38 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb3c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb40 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb44 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb48 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb4c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb50 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb54 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1400 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1404 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1408 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x140c + PHYD_BASE_ADDR);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1410 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1414 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1418 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x141c + PHYD_BASE_ADDR);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1500 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1504 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1508 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x150c + PHYD_BASE_ADDR);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1510 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1514 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1518 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x151c + PHYD_BASE_ADDR);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1520 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1540 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1544 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1548 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x154c + PHYD_BASE_ADDR);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1550 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1554 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1558 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x155c + PHYD_BASE_ADDR);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1560 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1900 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x1904 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1904 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1904 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1908 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1908 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1908 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x190c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x190c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x190c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1910 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1910 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1910 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1914 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1914 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1914 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1918 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1918 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1918 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x191c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x191c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x191c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1920 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1920 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1920 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1924 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1924 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1924 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1928 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1928 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1928 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x192c + PHYD_BASE_ADDR);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1930 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1934 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1938 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1940 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x1944 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1944 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1944 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1948 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1948 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1948 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x194c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x194c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x194c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1950 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1950 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1950 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1954 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1954 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1954 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1958 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1958 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1958 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x195c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x195c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x195c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1960 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1960 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1960 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1964 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1964 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1964 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1968 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1968 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1968 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x196c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x196c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x196c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x1970 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1974 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1978 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x197c + PHYD_BASE_ADDR);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1980 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a00 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a04 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a08 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a0c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a10 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a14 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a18 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a1c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a20 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a24 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a28 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a2c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a30 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a34 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a38 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a3c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a40 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a44 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a48 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a4c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a50 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a54 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a58 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a5c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a60 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a64 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a68 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a6c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a70 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a74 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a78 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a7c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b00 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b04 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b08 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b0c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b10 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b14 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b18 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b1c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b20 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b24 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b30 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b34 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b38 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b3c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b40 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b44 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b48 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b4c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b50 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b54 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x164 + PHYD_BASE_ADDR);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x41c + PHYD_BASE_ADDR);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x41c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x204 + PHYD_BASE_ADDR);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x204 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x224 + PHYD_BASE_ADDR);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x224 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x3000 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3004 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3008 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x300c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3010 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3018 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x301c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3020 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3024 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3028 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x302c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3030 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3100 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3104 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3110 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3140 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3144 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3150 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3180 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3184 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3188 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x318c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3190 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3194 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3198 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x319c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31a0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31a4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31a8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31ac + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31b0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31b4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31c0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31c4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31c8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31cc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31d0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31d4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31d8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31dc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31e0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31e4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31e8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31ec + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31f0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31f4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3280 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3284 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3288 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x328c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3290 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3294 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3298 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x329c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32a0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32a4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32a8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32c0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32c4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32c8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32cc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32d0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32d4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32d8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32dc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32e0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32e4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32e8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3370 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3380 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x340c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3418 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x00 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x04 + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x08 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x10 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x10 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x1C + CV_DDR_PHYD_APB);
+	mmio_wr32(0x1C + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x1C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x20 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x20 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x20 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x24 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x24 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x24 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x28 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x28 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x48 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x48 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x48 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x54 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x54 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x58 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x00F0 + PHYD_BASE_ADDR);
+	mmio_wr32(0x00F0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x00F0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x00F4 + PHYD_BASE_ADDR);
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, 0x00030033);
+	mmio_wr32(0x092C + PHYD_BASE_ADDR, 0x00000008);
+	for (int i = 0; i < 23; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x0000 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0004 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0008 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x000C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0010 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0014 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0018 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x001C + PHYD_BASE_ADDR, rddata);
+		rddata = i << 28 | i << 24 | i << 20 | i << 16 | i << 12 | i << 8 | i << 4 | i;
+		mmio_wr32(0x0020 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0024 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0028 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x002C + PHYD_BASE_ADDR, rddata);
+	}
+	for (int i = 0; i < 23; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x011C + PHYD_BASE_ADDR, rddata);
+	}
+	for (int i = 0; i < 128; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x0B0C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B10 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B14 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B3C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B44 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_cal();
+	for (int i = 0; i < 64; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x900 + PHYD_BASE_ADDR, rddata);
+		// mmio_wr32( 0x904 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x908 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x90C + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x910 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x914 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x918 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x91C + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x920 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x924 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x928 + PHYD_BASE_ADDR, rddata );
+		mmio_wr32(0x92C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x930 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x934 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x938 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA00 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA04 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA08 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA0C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA10 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA14 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA18 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA44 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA48 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA4C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA50 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA54 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA58 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB00 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB04 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB08 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB0C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB10 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB30 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB34 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB38 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB3C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB40 + PHYD_BASE_ADDR, rddata);
+		cvx16_lb_1_dq_set_highlow();
+		cvx16_lb_3_ca_set_highlow();
+		cvx16_dll_sw_clr();
+		KC_MSG("shift = %x\n", i);
+	}
+}
+
+void cvx16_ana_test(void)
+{
+	uint32_t i;
+	uint32_t j;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x58);
+	ddr_debug_num_write();
+	//[31] TOP_REG_TX_ZQ_PD =0
+	//[24] TOP_REG_TX_CA_PD_CKE0=0
+	rddata = 0x7EFFFFFF;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	//[1] TOP_REG_TX_CA_GPIO_OENZ=0
+	//[2] TOP_REG_TX_CA_SEL_GPIO_CKE0=1
+	rddata = 0x00000065;
+	mmio_wr32(0x1C + CV_DDR_PHYD_APB, rddata);
+	//[2] REG_DDRPLL_EN_TST=0b1
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 2, 2);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	//[15] param_phya_reg_tx_zq_en_test_mux
+	rddata = mmio_rd32(0x014C + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 1, 1);
+	mmio_wr32(0x014C + PHYD_BASE_ADDR, rddata);
+	//[0] param_phya_reg_en_test
+	rddata = mmio_rd32(0x0134 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(0x0134 + PHYD_BASE_ADDR, rddata);
+	uartlog("start ana test\n");
+	for (i = 1; i < 9; i = i + 1) {
+		KC_MSG("param_phya_reg_zq_sel_test_out=%x\n", get_bits_from_value(i, 3, 0));
+
+		// param_phya_reg_zq_sel_test_out0	7	4
+		// param_phya_reg_zq_sel_test_out1	11	8
+		rddata = mmio_rd32(0x014C + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(i, 3, 0), 7, 4);
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(i, 3, 0), 11, 8);
+		mmio_wr32(0x014C + PHYD_BASE_ADDR, rddata);
+		for (j = 0; j <= 15; j = j + 1) {
+			KC_MSG("param_phya_reg_rx_byte0_sel_test_in=%x\n", get_bits_from_value(j, 3, 0));
+
+			// param_phya_reg_rx_byte0_sel_test_in0	19 16
+			// param_phya_reg_rx_byte0_sel_test_in1	23 20
+			rddata = mmio_rd32(0x0200 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 19, 16);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 23, 20);
+			// param_phya_reg_rx_byte1_sel_test_in0  19  16
+			// param_phya_reg_rx_byte1_sel_test_in1  23  20
+			mmio_wr32(0x0200 + PHYD_BASE_ADDR, rddata);
+			rddata = mmio_rd32(0x0220 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 19, 16);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 23, 20);
+			mmio_wr32(0x0220 + PHYD_BASE_ADDR, rddata);
+			// opdelay(1000);
+		}
+	}
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_ddr_zq240(void)
+{
+	//        KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	int i;
+	int pre_zq240_cmp_out;
+
+	KC_MSG("START ZQ240 Calibration ...\n");
+
+	uartlog("ddr_zq240\n");
+	ddr_debug_wr32(0x2c1);
+	ddr_debug_num_write();
+	// VDDQ_TXr        = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// param_phyd_zqcal_hw_mode =1
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+	// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 2, 2);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+	// b.
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+	rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+	// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+	rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+	rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// d.
+	// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 0);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_SEL_GPIO         <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+	//  TOP_REG_TX_GPIO_OENZ        <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 7, 6);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	//------------------------------
+	// CMP offset Cal.
+	//------------------------------
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("zq_cmp_en\n");
+
+	//------------------------------
+	// ZQ Complete
+	//------------------------------
+	uartlog("wait hw_done\n");
+	// param_phyd_to_reg_zqcal_hw_done
+	while (1) {
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 16, 16) == 1) {
+			break;
+		}
+		KC_MSG("wait param_phyd_to_reg_zqcal_hw_done ...\n");
+	}
+	// check param_phya_reg_tx_zq_cmp_offset
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	KC_MSG("reg_tx_zq_cmp_offset = %x\n", get_bits_from_value(rddata, 12, 8));
+
+	uartlog("hw_done\n");
+	KC_MSG("param_phyd_to_reg_zqcal_hw_done ...\n");
+
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_zqcal_hw_mode =0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	//------------------------------
+	// ZQ240
+	//------------------------------
+	KC_MSG("START ZQ240 Calibration - ZQ 240 ...\n");
+
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	//         rddata=modified_bits_by_value(rddata, 0, 19, 16 );
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x15, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 19, 16);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	pre_zq240_cmp_out = 0x0;
+	for (i = 0; i < 16; i = i + 1) {
+		rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240_TRIM
+		rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240_TRIM
+		mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+		// opdelay(128);
+		KC_MSG("START ZQ240 Calibration ==> round %x...\n", i);
+
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		// param_phya_to_reg_zq_cmp_out
+		KC_MSG("START ZQ240 Calibration - cmp_out = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		if ((pre_zq240_cmp_out == 0x1) && (get_bits_from_value(rddata, 24, 24) == 0x0)) {
+			KC_MSG("ZQ240 Calibration = %x\n", i);
+
+			rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240
+			rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240
+			mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+			i = 18;
+		}
+		pre_zq240_cmp_out = get_bits_from_value(rddata, 24, 24);
+	}
+	if ((pre_zq240_cmp_out == 0x0) || (i == 16)) {
+		KC_MSG("Error !!! ZQ240 Calibration\n");
+	}
+	uartlog("zq240 done\n");
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM =0
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+	// opdelay(200);
+	KC_MSG("ZQ240 Complete ...\n");
+}
+
+void cvx16_ddr_zq240_ate(void)
+{
+	//        KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	int i;
+	int pre_zq240_cmp_out;
+
+	KC_MSG("START ZQ240 Calibration ...\n");
+
+	uartlog("ddr_zq240\n");
+	ddr_debug_wr32(0x2c1);
+	ddr_debug_num_write();
+	// VDDQ_TXr        = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// param_phyd_zqcal_hw_mode =1
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+	// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 2, 2);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+	// b.
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+	rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+	// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+	rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+	rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// d.
+	// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 0);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_SEL_GPIO         <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+	//  TOP_REG_TX_GPIO_OENZ        <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 7, 6);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	//------------------------------
+	// CMP offset Cal.
+	//------------------------------
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x15, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("zq_cmp_en\n");
+
+	//------------------------------
+	// ZQ Complete
+	//------------------------------
+	uartlog("wait hw_done\n");
+	// param_phyd_to_reg_zqcal_hw_done
+	while (1) {
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 16, 16) == 1) {
+			break;
+		}
+		KC_MSG("wait param_phyd_to_reg_zqcal_hw_done ...\n");
+	}
+	// check param_phya_reg_tx_zq_cmp_offset
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	KC_MSG("reg_tx_zq_cmp_offset = %x\n", get_bits_from_value(rddata, 12, 8));
+
+	uartlog("hw_done\n");
+	KC_MSG("param_phyd_to_reg_zqcal_hw_done ...\n");
+
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 0, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// param_phyd_zqcal_hw_mode =0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	//------------------------------
+	// ZQ240
+	//------------------------------
+	KC_MSG("START ZQ240 Calibration - ZQ 240 ...\n");
+
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 1, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// rddata = mmio_rd32(0x50+CV_DDR_PHYD_APB);
+	// rddata=modified_bits_by_value(rddata, 1, 0, 0 );
+	//          rddata=modified_bits_by_value(rddata, 0, 19, 16 );
+	// mmio_wr32(0x50+CV_DDR_PHYD_APB,  rddata);
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 0x15, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// rddata = mmio_rd32(0x50+CV_DDR_PHYD_APB);
+	rddata = 0x00000000;
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 19, 16);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	pre_zq240_cmp_out = 0x0;
+	for (i = 0; i < 16; i = i + 1) {
+		rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240_TRIM
+		rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240_TRIM
+		mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("START ZQ240 Calibration ==> round %x...\n", i);
+
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		// param_phya_to_reg_zq_cmp_out
+		KC_MSG("START ZQ240 Calibration - cmp_out = %x\n", get_bits_from_value(rddata, 24, 24));
+	}
+	uartlog("zq240 done\n");
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 0, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM =0
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+	// opdelay(200);
+	KC_MSG("ZQ240 Complete ...\n");
+}
+
+void cvx16_ddr_zq240_cal(void)
+{
+	//        KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	int i;
+	int pre_zq240_cmp_out;
+
+	KC_MSG("START ZQ240 Calibration ...\n");
+
+	uartlog("ddr_zq240_cal\n");
+	ddr_debug_wr32(0x2c1);
+	ddr_debug_num_write();
+	//------------------------------
+	// ZQ240
+	//------------------------------
+	KC_MSG("START ZQ240 Calibration - ZQ 240 ...\n");
+
+	// param_phyd_zqcal_hw_mode =0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+	// param_phya_reg_tx_zq_cmp_en = 1
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM = 1
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	//         rddata=modified_bits_by_value(rddata, 0, 19, 16 );
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];            =1
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];            =1
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];            =1
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x15, 4, 0);
+#ifdef DDR4
+	rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+#else
+	// for zq pull high 60ohm
+	rddata = modified_bits_by_value(rddata, 0x1A, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+#endif
+	// rddata = mmio_rd32(0x50+CV_DDR_PHYD_APB);
+	// rddata=modified_bits_by_value(rddata, 1, 0, 0 );
+	// rddata=modified_bits_by_value(rddata, 1, 19, 16 );
+	// mmio_wr32(0x50+CV_DDR_PHYD_APB,  rddata);
+	pre_zq240_cmp_out = 0x0;
+	for (i = 0; i < 16; i = i + 1) {
+		rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240_TRIM
+		rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240_TRIM
+		mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+		// opdelay(128);
+		KC_MSG("START ZQ240 Calibration ==> round %x...\n", i);
+
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		// param_phya_to_reg_zq_cmp_out
+		KC_MSG("START ZQ240 Calibration - cmp_out = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		if ((pre_zq240_cmp_out == 0x1) && (get_bits_from_value(rddata, 24, 24) == 0x0)) {
+			KC_MSG("ZQ240 Calibration = %x\n", i);
+
+			rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240
+			rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240
+			mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+			i = 18;
+		}
+		pre_zq240_cmp_out = get_bits_from_value(rddata, 24, 24);
+	}
+	if ((i == 16)) {
+		KC_MSG("Error !!! ZQ240 Calibration\n");
+	}
+	uartlog("zq240 done\n");
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM =0
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+	// opdelay(200);
+	KC_MSG("ZQ240 Complete ...\n");
+}
+
+void ctrl_init_detect_dram_size(uint8_t *dram_cap_in_mbyte)
+{
+	uint8_t cap_in_mbyte = 0;
+#ifdef DDR3
+	uint32_t cmd[6];
+	uint8_t i;
+
+	// dram_cap_in_mbyte = 4;
+	cap_in_mbyte = 4;
+
+	for (i = 0; i < 6; i++)
+		cmd[i] = 0x0;
+
+	// Axsize = 3, axlen = 4, cgen
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x000e0006);
+
+	// DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0xffffffff);
+
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+
+	// write PRBS to 0x0 as background {{{
+	// write 16 UI prbs
+	cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0);
+
+	for (i = 0; i < 6; i++) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	}
+
+	// bist_enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+
+	// polling BIST done
+
+	do {
+		rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+	} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+	// bist disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+	// }}}
+
+	do {
+		// *dram_cap_in_mbyte++;
+		cap_in_mbyte++;
+		uartlog("cap_in_mbyte =  %x\n", cap_in_mbyte);
+
+		// write ~PRBS to (0x1 << *dram_cap_in_mbyte) {{{
+
+		// DDR space
+		mmio_wr32(DDR_BIST_BASE + 0x10, 1 << (cap_in_mbyte + 20 - 4));
+		// write 16 UI ~prbs
+		cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (1 << 8) + (0 << 0);
+
+		for (i = 0; i < 6; i++) {
+			mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+		}
+
+		// bist_enable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+		// polling BIST done
+
+		do {
+			rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+		// bist disable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+		// }}}
+
+		// check PRBS at 0x0 {{{
+
+		// DDR space
+		mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+		cmd[0] = (2 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0); // read 16 UI prbs
+
+		for (i = 0; i < 6; i++) {
+			mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+		}
+
+		// bist_enable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+		// polling BIST done
+
+		do {
+			rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+		// bist disable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+		// }}}
+
+	} while ((get_bits_from_value(rddata, 3, 3) == 0) && (cap_in_mbyte < 15)); // BIST fail stop the loop
+
+#endif
+#ifdef DDR2
+	// fix size for DDR2
+	cap_in_mbyte = 6;
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		uint32_t cmd[6];
+		uint8_t i;
+
+		// dram_cap_in_mbyte = 4;
+		cap_in_mbyte = 4;
+
+		for (i = 0; i < 6; i++)
+			cmd[i] = 0x0;
+
+		// Axsize = 3, axlen = 4, cgen
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x000e0006);
+
+		// DDR space
+		mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+		mmio_wr32(DDR_BIST_BASE + 0x14, 0xffffffff);
+
+		// specified AXI address step
+		mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+
+		// write PRBS to 0x0 as background {{{
+
+		cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0); // write 16 UI prbs
+
+		for (i = 0; i < 6; i++) {
+			mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+		}
+
+		// bist_enable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+
+		// polling BIST done
+
+		do {
+			rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+		// bist disable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+		// }}}
+
+		do {
+			// *dram_cap_in_mbyte++;
+			cap_in_mbyte++;
+			uartlog("cap_in_mbyte =  %x\n", cap_in_mbyte);
+
+			// write ~PRBS to (0x1 << *dram_cap_in_mbyte) {{{
+
+			// DDR space
+			mmio_wr32(DDR_BIST_BASE + 0x10, 1 << (cap_in_mbyte + 20 - 4));
+			// write 16 UI ~prbs
+			cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (1 << 8) + (0 << 0);
+
+			for (i = 0; i < 6; i++) {
+				mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+			}
+
+			// bist_enable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+			// polling BIST done
+
+			do {
+				rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+			} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+			// bist disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+			// }}}
+
+			// check PRBS at 0x0 {{{
+
+			// DDR space
+			mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+			// read 16 UI prbs
+			cmd[0] = (2 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0);
+
+			for (i = 0; i < 6; i++) {
+				mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+			}
+
+			// bist_enable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+			// polling BIST done
+
+			do {
+				rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+			} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+			// bist disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+			// }}}
+
+		} while ((get_bits_from_value(rddata, 3, 3) == 0) && (cap_in_mbyte < 15)); // BIST fail stop the loop
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2)	{
+		// fix size for DDR2
+		cap_in_mbyte = 6;
+	}
+#endif
+
+	*dram_cap_in_mbyte = cap_in_mbyte;
+
+	// save dram_cap_in_mbyte
+	rddata = cap_in_mbyte;
+	mmio_wr32(0x0208 + PHYD_BASE_ADDR, rddata);
+
+	// cgen disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+}
+
+#if defined(FULL_MEM_BIST) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+uint32_t ddr_bist_all(uint32_t mode, uint32_t capacity, uint32_t x16_mode)
+{
+	uint32_t axi_len8;
+	int loop;
+	uint32_t cmd[6];
+	uint64_t cap;
+	uint32_t pattern;
+	uint32_t bist_result = 1;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+
+	// mode--> 0/1/2 = prbs/sram/01
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	// KC  KC_MSG("capacity=%x, x16_mode=%x\n", capacity, x16_mode);
+
+	if (capacity == 0)
+		cap = (2 << 9) << (20 - 3);
+	else
+		cap = capacity << (30 - 3);
+
+	if (mode == 0) {
+		//prbs
+		pattern = 5;
+		sram_sp = 511;
+	} else if (mode == 1) {
+		//sram
+		pattern = 6;
+		fmax = 15;
+		fmin = 5;
+		sram_sp = 511; //for all dram size, repeat sso pattern
+		//sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+		//KC_MSG("sram_sp = %x\n", sram_sp);
+
+		// bist sso_period
+		mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+
+	} else {
+		pattern = 1;
+		sram_sp = 511;
+	}
+
+	loop = cap / (512 * 4 * 16 * 4 / (2 << x16_mode)) - 1;
+
+	// check xpi len
+	rddata = mmio_rd32(cfg_base + 0xc);
+	axi_len8 = FIELD_GET(rddata, 19, 19);
+	KC_MSG("cap=%x, loop=%x, axi_len8=%x\n", cap, loop, axi_len8);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	// sram based cmd
+	//        op_code     start       stop              pattern          dq_inv     dm_inv    dq_auto_rotate repeat
+	cmd[0] = (1 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (0 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	cmd[1] = (2 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (0 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	cmd[3] = (1 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (1 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	cmd[4] = (2 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (1 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	//        op_code     addr_not_assert    goto_idx    loop
+	cmd[2] = (3 << 30) | (1 << 20) | (0 << 16) | (loop << 0);
+	cmd[5] = (3 << 30) | (1 << 20) | (3 << 16) | (loop << 0);
+
+	// write cmd queue
+	for (int i = 0; i < 6; i++)
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+
+	// DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x00ffffff);
+	// set AXI_LEN8
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00080000 | (axi_len8 << 3));
+	// specified AXI address step
+	if (x16_mode == 0x1) {
+		if (axi_len8 == 0x1)
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+		else
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000002);
+	} else {
+		if (axi_len8 == 0x1)
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+		else
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+	}
+	// bist_enable & x16_en
+	if (x16_mode == 0x1) {
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00030003);
+	} else {
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+	}
+	// polling bist done
+	while (1) {
+		rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		if (FIELD_GET(rddata, 2, 2) == 1)
+			break;
+	}
+
+	//aspi_axi_sr(`SPI_REG_DDR_BIST + 0x80, ptest_aspi_spi_rdata, 0x0000_000C, "INFO: polling bist done and pass")
+	if (FIELD_GET(rddata, 3, 2) == 1) {
+		KC_MSG("bist_Pass\n");
+		bist_result = 1 & bist_result;
+	} else {
+		KC_MSG("ERROR bist_fail\n");
+		bist_result = 0;
+	}
+	// bist disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00050000);
+
+	return bist_result;
+}
+
+uint32_t bist_all_dram(uint32_t mode, uint32_t capacity)
+{
+	// mode--> 0/1/2 = prbs/sram/01
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	uint32_t bist_result;
+
+	bist_result = ddr_bist_all(mode, capacity, 1);
+
+	if (bist_result == 0)
+		NOTICE("ERROR bist_fail!(%d, %d)\n", mode, capacity);
+	else
+		NOTICE("ALL Bist_Pass!(%d, %d)\n", mode, capacity);
+
+	return bist_result;
+}
+
+void bist_all_dram_forever(uint32_t capacity)
+{
+	uint32_t count = 0;
+	uint32_t bist_result = 1;
+	// uint32_t sram_sp;
+
+	// sso_8x1_c(5, 15, 0, 1, &sram_sp);
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp);
+	while (1) {
+		NOTICE("%d\n", count++);
+		bist_result &= bist_all_dram(0, capacity);
+		bist_result &= bist_all_dram(1, capacity);
+		bist_result &= bist_all_dram(2, capacity);
+		if (bist_result == 0) {
+			NOTICE("BIST stress test FAIL\n");
+			break;
+		}
+	}
+}
+#endif // defined(FULL_MEM_BIST) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+
+#if defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+static void ddr_sys_init(void)
+{
+	KC_MSG("reset  !\n");
+	mmio_wr32(DDR_TOP_BASE + 0x20, 0x1);
+
+	KC_MSG("PLL INIT !\n");
+	cvx16_pll_init();
+
+	KC_MSG("DDRC_INIT !\n");
+	// ddrc_init_ddr3_4g_2133();
+	ddrc_init();
+
+	// cvx16_ctrlupd_short();
+
+	// release ddrc soft reset
+	KC_MSG("releast reset  !\n");
+	mmio_wr32(DDR_TOP_BASE + 0x20, 0x0);
+
+	KC_MSG("phy_init!\n");
+	phy_init();
+
+	cvx16_setting_check();
+	KC_MSG("cvx16_setting_check  finish");
+
+	cvx16_pinmux();
+	KC_MSG("cvx16_pinmux finish");
+
+	ddr_patch_set();
+
+	cvx16_en_rec_vol_mode();
+	KC_MSG("cvx16_en_rec_vol_mode finish");
+
+	// set_dfi_init_start
+	cvx16_set_dfi_init_start();
+	KC_MSG("set_dfi_init_start finish\n");
+
+	// ddr_phy_power_on_seq1
+	cvx16_ddr_phy_power_on_seq1();
+	KC_MSG("ddr_phy_power_on_seq1 finish\n");
+
+	// first dfi_init_start
+	KC_MSG("first dfi_init_start\n");
+
+	cvx16_polling_dfi_init_start();
+
+	KC_MSG("cvx16_polling_dfi_init_start finish");
+
+	cvx16_INT_ISR_08();
+	KC_MSG("cvx16_INT_ISR_08 finish");
+
+	// ddr_phy_power_on_seq3
+	cvx16_ddr_phy_power_on_seq3();
+	KC_MSG("ddr_phy_power_on_seq3 finish\n");
+
+	// wait_for_dfi_init_complete
+	cvx16_wait_for_dfi_init_complete();
+	KC_MSG("wait_for_dfi_init_complete finish\n");
+
+	// polling_synp_normal_mode
+	cvx16_polling_synp_normal_mode();
+	KC_MSG("polling_synp_normal_mode finish\n");
+}
+
+static void set_ca_vref(uint32_t vref)
+{
+	rddata = mmio_rd32(0x0414 + PHYD_BASE_ADDR);
+	rddata = FIELD_SET(rddata, vref, 20, 16); //param_phya_reg_tx_vrefca_sel
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	uartlog("vrefca = %08x\n", vref);
+	//time.sleep(0.01);
+	mdelay(10);
+}
+#endif // defined(SHMOO_CA) || defined(SHMOO_CS)
+
+#if defined(DBG_SHMOO_CA)
+static uint32_t bist_all_dram_calvl(uint32_t mode, uint32_t capacity, uint32_t shift_delay, uint32_t vrefca)
+{
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	uint32_t bist_result;
+	uint32_t bist_err;
+
+	bist_result = ddr_bist_all(mode, capacity, 1);
+
+	if (bist_result == 0) {
+		bist_err = 0xffffffff;
+	} else {
+		bist_err = 0x00000000;
+	}
+	SHMOO_MSG_CA("vref = %02x, sw_ca__training_start = %08x , err_data_rise/err_data_fall = %08x, %08x\n",
+		  vrefca, shift_delay, bist_err, bist_err);
+
+	return bist_result;
+}
+#endif // defined(DBG_SHMOO_CA)
+
+#if defined(DBG_SHMOO_CS)
+static uint32_t bist_all_dram_cslvl(uint32_t mode, uint32_t capacity, uint32_t shift_delay, uint32_t vrefca)
+{
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	uint32_t bist_result;
+	uint32_t bist_err;
+
+	bist_result = ddr_bist_all(mode, capacity, 1);
+
+	if (bist_result == 0) {
+		bist_err = 0xffffffff;
+	} else {
+		bist_err = 0x00000000;
+	}
+	SHMOO_MSG_CS("vref = %02x, sw_cs__training_start = %08x , err_data_rise/err_data_fall = %08x, %08x\n",
+		  vrefca, shift_delay, bist_err, bist_err);
+
+	return bist_result;
+}
+#endif // defined(DBG_SHMOO_CS)
+
+#if defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+static void bist_single(enum bist_mode mode)
+{
+	//uint32_t sram_sp;
+	uint32_t bist_result;
+	uint64_t err_data_odd;
+	uint64_t err_data_even;
+
+	if (mode == E_PRBS)
+		cvx16_bist_wr_prbs_init();
+	if (mode == E_SRAM) {
+		cvx16_bist_wr_sram_init();
+	}
+
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+
+	KC_MSG("bist_result=%x, err_data_odd=%x, err_data_even=%x\n", bist_result, err_data_odd, err_data_even);
+}
+
+void ddr_training(enum train_mode t_mode)
+{
+	uint32_t mode;
+	uint32_t rddata;
+
+	// sram_sp =0
+	if (t_mode == E_WRLVL) {
+		// wrlvl
+		cvx16_wrlvl_req();
+		// cvx16_wrlvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_RDGLVL) {
+		// rdglvl
+		cvx16_rdglvl_req();
+		// cvx16_rdglvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_WDQLVL) {
+		// wdqlvl
+		mode = 1;
+		// data_mode = 'h0 : phyd pattern
+		// data_mode = 'h1 : bist read/write
+		// data_mode = 'h11: with Error enject,  multi- bist write/read
+		// data_mode = 'h12: with Error enject,  multi- bist write/read
+		// lvl_mode  = 'h0 : wdmlvl
+		// lvl_mode  = 'h1 : wdqlvl
+		// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+		// cvx16_wdqlvl_req( data_mode,  lvl_mode,  sram_sp)
+		if (mode == 0) {
+			cvx16_wdqlvl_req(0, 2); // dq/dm
+		} else {
+			if (mode == 1) {
+				cvx16_wdqlvl_req(1, 2); // dq/dm
+				// cvx16_wdqlvl_req(1, 1); // dq
+				// cvx16_wdqlvl_req(1, 0); // dm
+			}
+		}
+		// cvx16_wdqlvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_RDLVL) {
+		// rdlvl
+		mode = 1;
+		// mode = 'h0  : MPR mode, DDR3 only.
+		// mode = 'h1  : sram write/read continuous goto
+		// mode = 'h2  : multi- bist write/read
+		// mode = 'h10 : with Error enject,  multi- bist write/read
+		// mode = 'h12 : with Error enject,  multi- bist write/read
+
+		if (mode == 0) {
+			rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, 1, 4, 4); // Dataflow from MPR
+			mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+			cvx16_rdlvl_req(0);
+			rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, 0, 4, 4); // Dataflow from MPR
+			mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+		} else {
+			cvx16_rdlvl_req(mode);
+		}
+		// cvx16_rdlvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_WDQLVL_SW) {
+		// wdqlvl_sw
+
+		KC_MSG("wdqlvl_SW_M1_ALL\n");
+		// data_mode = 'h0 : phyd pattern
+		// data_mode = 'h1 : bist read/write
+		// data_mode = 'h11: with Error enject,  multi- bist write/read
+		// data_mode = 'h12: with Error enject,  multi- bist write/read
+		// lvl_mode  = 'h0 : wdmlvl
+		// lvl_mode  = 'h1 : wdqlvl
+		// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+		// cvx16_wdqlvl_req(data_mode, lvl_mode)
+		rddata = 0x00000000;
+		rddata = modified_bits_by_value(rddata, 0x0c, 6, 0);  //param_phyd_dfi_wdqlvl_vref_start
+		rddata = modified_bits_by_value(rddata, 0x13, 14, 8); //param_phyd_dfi_wdqlvl_vref_end
+		rddata = modified_bits_by_value(rddata, 0x2, 19, 16); //param_phyd_dfi_wdqlvl_vref_step
+		mmio_wr32(0x0190 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("cvx16_wdqlvl_sw_req\n");
+		cvx16_wdqlvl_sw_req(1, 2);
+		// cvx16_wdqlvl_status();
+		KC_MSG("cvx16_wdqlvl_req dq/dm finish\n");
+	}
+
+	if (t_mode == E_RDLVL_SW) {
+		// rdlvl_sw
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 7, 4); //param_phyd_pirdlvl_capture_cnt
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+
+		KC_MSG("SW mode 1, sram write/read continuous goto\n");
+		cvx16_rdlvl_sw_req(1);
+		// cvx16_rdlvl_status();
+		KC_MSG("cvx16_rdlvl_req finish\n");
+	}
+}
+#endif // defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+
+#ifdef DBG_SHMOO_CA
+void calvl_req(uint32_t capacity)
+{
+	uint32_t i, j;
+	uint32_t vrefca_start = 0x02;
+	uint32_t vrefca_end   = 0x1f;
+	uint32_t vrefca_step  = 0x02;
+	uint32_t shift_start  = 0x02;
+	uint32_t shift_end    = 0x07;
+	uint32_t delay_start  = 0x00;
+	uint32_t delay_end    = 0x40;
+	uint32_t delay_step   = 0x04;
+
+	uartlog("=== calvl_req ===\n");
+	// if DDR3_4G:
+	//     capacity=4
+	// if DDR3_2G:
+	//     capacity=2
+	// if DDR3_1G:
+	//     capacity=1
+	// if DDR3_DBG:
+	//     capacity=4
+	// if N25_DDR2_512:
+	//     capacity=0
+
+	// for i in range(vrefca_start, vrefca_end+1, vrefca_step):
+	for (i = vrefca_start; i < (vrefca_end + 1); i += vrefca_step) {
+		uint32_t vrefca_sel = i;
+		uint32_t shift_delay_start = (shift_start << 7) + delay_start;
+		uint32_t shift_delay_end = (shift_end << 7) + delay_end + 1;
+		uint32_t bist_result = 0;
+
+		uartlog("vrefca_start = %08x\n", i);
+		// for j in range(shift_delay_start, shift_delay_end, delay_step):
+		for (j = shift_delay_start; j < shift_delay_end; j += delay_step) {
+			uint32_t shift_delay;
+
+			if (bist_result == 0) {
+				ddr_sys_init();
+				ddr_training(E_WRLVL);
+				ddr_training(E_RDGLVL);
+			#ifdef DDR3_DBG
+				ddr_training(E_RDLVL);
+			#endif //DDR3_DBG
+				ddr_training(E_WDQLVL);
+				ddr_training(E_RDLVL);
+				cvx16_clk_gating_disable();
+				set_ca_vref(vrefca_sel);
+			}
+			// #mmio_wr32(0x0414 + PHYD_BASE_ADDR, vrefca_sel) #param_phya_reg_tx_vrefca_sel
+			// #time.sleep(0.1)
+			uartlog("shift_delay_before = %08x\n", j);
+
+			shift_delay = ((get_bits_from_value(j, 12, 7)) << 8) + (get_bits_from_value(j, 6, 0));
+
+			uartlog("shift_delay_after = %08x\n", shift_delay);
+			cvx16_ca_shift_delay(shift_delay);
+			// #bist_single_calvl(mode="prbs", shift_delay=j, vrefca=vrefca_sel)
+
+		#if 1 //ca park 1
+			cvx16_dfi_ca_park_prbs(1);
+			bist_result = bist_all_dram_calvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#else //ca park 0
+			cvx16_dfi_ca_park_prbs(0);
+			bist_result = bist_all_dram_calvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#endif
+		}
+	}
+	// re-init
+	ddr_sys_init();
+	ddr_training(E_WRLVL);
+	ddr_training(E_RDGLVL);
+#ifdef DDR3_DBG
+	ddr_training(E_RDLVL);
+#endif //DDR3_DBG
+	ddr_training(E_WDQLVL);
+	ddr_training(E_RDLVL);
+
+	cvx16_clk_gating_enable();
+}
+#endif // DBG_SHMOO_CA
+
+#ifdef DBG_SHMOO_CS
+void cslvl_req(uint32_t capacity)
+{
+	uint32_t i, j;
+	//TODO
+	uint32_t vrefca_start = 0x02;
+	uint32_t vrefca_end   = 0x1f;
+	uint32_t vrefca_step  = 0x02;
+	uint32_t shift_start  = 0x02;
+	uint32_t shift_end    = 0x05;
+	uint32_t delay_start  = 0x40;
+	uint32_t delay_end    = 0x40;
+	uint32_t delay_step   = 0x04;
+
+	uartlog("=== cslvl_req ===\n");
+	// if DDR3_4G:
+	//     capacity=4
+	// if DDR3_2G:
+	//     capacity=2
+	// if DDR3_1G:
+	//     capacity=1
+	// if DDR3_DBG:
+	//     capacity=4
+	// if N25_DDR2_512:
+	//     capacity=0
+
+	// for i in range(vrefca_start, vrefca_end+1, vrefca_step):
+	for (i = vrefca_start; i < (vrefca_end + 1); i += vrefca_step) {
+		uint32_t vrefca_sel = i;
+		uint32_t shift_delay_start = (shift_start << 7) + delay_start;
+		uint32_t shift_delay_end = (shift_end << 7) + delay_end + 1;
+		uint32_t bist_result = 0;
+
+		uartlog("vrefca_start = %08x\n", i);
+		// for j in range(shift_delay_start, shift_delay_end, delay_step):
+		for (j = shift_delay_start; j < shift_delay_end; j += delay_step) {
+			uint32_t shift_delay;
+
+			if (bist_result == 0) {
+				ddr_sys_init();
+				ddr_training(E_WRLVL);
+				ddr_training(E_RDGLVL);
+			#ifdef DDR3_DBG
+				ddr_training(E_RDLVL);
+			#endif //DDR3_DBG
+				ddr_training(E_WDQLVL);
+				ddr_training(E_RDLVL);
+				cvx16_clk_gating_disable();
+				set_ca_vref(vrefca_sel);
+			}
+			// #mmio_wr32(0x0414 + PHYD_BASE_ADDR, vrefca_sel) #param_phya_reg_tx_vrefca_sel
+			// #time.sleep(0.1)
+			uartlog("shift_delay_before = %08x\n", j);
+
+			shift_delay = ((get_bits_from_value(j, 12, 7)) << 8) + (get_bits_from_value(j, 6, 0));
+
+			uartlog("shift_delay_after = %08x\n", shift_delay);
+			cvx16_cs_shift_delay(shift_delay);
+			// #bist_single_calvl(mode="prbs", shift_delay=j, vrefca=vrefca_sel)
+
+		#if 1 //ca park 1
+			cvx16_dfi_ca_park_prbs(1);
+			bist_result = bist_all_dram_cslvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#else //ca park 0
+			cvx16_dfi_ca_park_prbs(0);
+			bist_result = bist_all_dram_cslvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#endif
+		}
+	}
+	// re-init
+	ddr_sys_init();
+	ddr_training(E_WRLVL);
+	ddr_training(E_RDGLVL);
+#ifdef DDR3_DBG
+	ddr_training(E_RDLVL);
+#endif //DDR3_DBG
+	ddr_training(E_WDQLVL);
+	ddr_training(E_RDLVL);
+
+	cvx16_clk_gating_enable();
+}
+#endif // DBG_SHMOO_CS
+
+#pragma GCC diagnostic pop
diff --git a/firmware/plat/cv180x/ddr/ddr_sys_bring_up.c b/firmware/plat/cv180x/ddr/ddr_sys_bring_up.c
new file mode 100644
index 0000000..e2cf183
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/ddr_sys_bring_up.c
@@ -0,0 +1,493 @@
+#include <platform_def.h>
+#include <reg_soc.h>
+#include <phy_pll_init.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+#include <mmio.h>
+#include <bitwise_ops.h>
+#include <cvx16_dram_cap_check.h>
+#include <cvx16_pinmux.h>
+#include <regconfig.h>
+#include <console.h>
+#include <ddr_pkg_info.h>
+
+#define DO_BIST
+
+#define REMAPPING_BASE 0
+#define AXIMON_M1_WRITE	(REMAPPING_BASE + 0x0)
+#define AXIMON_M1_READ	(REMAPPING_BASE + 0x80)
+#define AXIMON_M2_WRITE	(REMAPPING_BASE + 0x100)
+#define AXIMON_M2_READ	(REMAPPING_BASE + 0x180)
+#define AXIMON_M3_WRITE	(REMAPPING_BASE + 0x200)
+#define AXIMON_M3_READ	(REMAPPING_BASE + 0x280)
+#define AXIMON_M4_WRITE	(REMAPPING_BASE + 0x300)
+#define AXIMON_M4_READ	(REMAPPING_BASE + 0x380)
+#define AXIMON_M5_WRITE	(REMAPPING_BASE + 0x400)
+#define AXIMON_M5_READ	(REMAPPING_BASE + 0x480)
+#define AXIMON_M6_WRITE	(REMAPPING_BASE + 0x500)
+#define AXIMON_M6_READ	(REMAPPING_BASE + 0x580)
+
+#define AXIMON_OFFSET_CYCLE 0x24
+#define AXIMON_OFFSET_BYTECNTS 0x2C
+#define AXIMON_OFFSET_LATENCYCNTS 0x34
+#define AXIMON_OFFSET_HITCNTS 0x28
+#define AXIMON_OFFSET_LAT_BIN_SIZE_SEL 0x50
+
+#define AXIMON_START_REGVALUE 0x30001
+#define AXIMON_STOP_REGVALUE 0x30002
+
+static void axi_mon_latency_setting(uint32_t lat_bin_size_sel)
+{
+	uint32_t rdata;
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_WRITE + AXIMON_OFFSET_LAT_BIN_SIZE_SEL),
+					lat_bin_size_sel);//for ddr3 1866: bin_size_sel=0d'5
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_READ + AXIMON_OFFSET_LAT_BIN_SIZE_SEL),
+					lat_bin_size_sel);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_WRITE + 0x00), 0x01000100);//input clk sel
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M1_WRITE + 0x04));//hit sel setting
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_WRITE + 0x04), rdata);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_READ + 0x00), 0x01000100);
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M1_READ + 0x04));
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_READ + 0x04), rdata);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_WRITE + AXIMON_OFFSET_LAT_BIN_SIZE_SEL), lat_bin_size_sel);
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_READ + AXIMON_OFFSET_LAT_BIN_SIZE_SEL), lat_bin_size_sel);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_WRITE + 0x00), 0x01000100);
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M5_WRITE + 0x04));
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_WRITE + 0x04), rdata);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_READ + 0x00), 0x01000100);
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M5_READ + 0x04));
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_READ + 0x04), rdata);
+
+	//NOTICE("mon cg en.\n");
+	rdata = mmio_rd32((DDR_TOP_BASE+0x14));
+	rdata = rdata | 0x00000100;
+	mmio_wr32((DDR_TOP_BASE+0x14), rdata);
+}
+
+static void axi_mon_start(uint32_t base_register)
+{
+	mmio_wr32((AXI_MON_BASE + base_register), AXIMON_START_REGVALUE);
+}
+
+void axi_mon_start_all(void)
+{
+	axi_mon_start(AXIMON_M1_WRITE);
+	axi_mon_start(AXIMON_M1_READ);
+	axi_mon_start(AXIMON_M2_WRITE);
+	axi_mon_start(AXIMON_M2_READ);
+	axi_mon_start(AXIMON_M3_WRITE);
+	axi_mon_start(AXIMON_M3_READ);
+	axi_mon_start(AXIMON_M4_WRITE);
+	axi_mon_start(AXIMON_M4_READ);
+	axi_mon_start(AXIMON_M5_WRITE);
+	axi_mon_start(AXIMON_M5_READ);
+	axi_mon_start(AXIMON_M6_WRITE);
+	axi_mon_start(AXIMON_M6_READ);
+}
+
+void dump_axi_mon_reg(uint32_t base_register)
+{
+	uint i = 0;
+
+	for (i = 0; i <= 0x7c; i = i+0x10) {
+		NOTICE("0x%08x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n", AXI_MON_BASE + base_register+i,
+								mmio_rd32(AXI_MON_BASE + base_register+i),
+								mmio_rd32(AXI_MON_BASE + base_register+i+0x4),
+								mmio_rd32(AXI_MON_BASE + base_register+i+0x8),
+								mmio_rd32(AXI_MON_BASE + base_register+i+0xc));
+	}
+}
+
+void ddr_sys_bring_up(void)
+{
+	uint32_t bist_result;
+	uint64_t err_data_even, err_data_odd;
+	uint8_t dram_cap_in_mbyte;
+
+#if defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS) || defined(FULL_MEM_BIST) || defined(FULL_MEM_BIST_FOREVER)
+	uint32_t cap = 1;
+
+	// switch (get_ddr_capacity()) {
+	// case DDR_CAPACITY_1G: cap = 1; break;
+	// case DDR_CAPACITY_2G: cap = 2; break;
+	// case DDR_CAPACITY_4G: cap = 4; break;
+	// default: cap = 1;
+	// }
+	uartlog("cap=%d\n", cap);
+#endif //FULL_MEM_BIST || FULL_MEM_BIST_FOREVER
+
+	uartlog("%s pattern!\n", __func__);
+
+	// mmio_wr32(PLLG6_BASE+top_pll_g6_reg_ddr_ssc_syn_src_en,
+	//            mmio_rd32(PLLG6_BASE+top_pll_g6_reg_ddr_ssc_syn_src_en)
+	//            &(~top_pll_g6_reg_ddr_ssc_syn_src_en_MASK)
+	//            |0x1<<top_pll_g6_reg_ddr_ssc_syn_src_en_OFFSET);
+
+#ifdef REAL_DDRPHY
+	uartlog("PLL INIT !\n");
+	pll_init();
+#endif
+
+	uartlog("DDRC_INIT !\n");
+	ddrc_init();
+
+	// cvx16_ctrlupd_short();
+
+	// release ddrc soft reset
+	uartlog("releast reset  !\n");
+	mmio_wr32(DDR_TOP_BASE + 0x20, 0x0);
+
+	// set axi QOS
+	// M1 = 0xA (VIP realtime)
+	// M2 = 0x8 (VIP offline)
+	// M3 = 0x7 (CPU)
+	// M4 = 0x0 (TPU)
+	// M5 = 0x9 (Video codec)
+	// M6 = 0x2 (high speed peri)
+	mmio_wr32(0x030001D8, 0x007788aa);
+	mmio_wr32(0x030001DC, 0x00002299);
+
+#ifdef REAL_DDRPHY
+	uartlog("phy_init !\n");
+	phy_init();
+#endif
+
+	cvx16_setting_check();
+	KC_MSG("cvx16_setting_check  finish\n");
+
+	// pinmux
+	cvx16_pinmux();
+	KC_MSG("cvx16_pinmux finish\n");
+
+	ddr_patch_set();
+
+	cvx16_en_rec_vol_mode();
+	KC_MSG("cvx16_en_rec_vol_mode finish\n");
+
+	// set_dfi_init_start
+	cvx16_set_dfi_init_start();
+	KC_MSG("set_dfi_init_start finish\n");
+
+	// ddr_phy_power_on_seq1
+	cvx16_ddr_phy_power_on_seq1();
+	KC_MSG("ddr_phy_power_on_seq1 finish\n");
+
+	// first dfi_init_start
+	KC_MSG("first dfi_init_start\n");
+	cvx16_polling_dfi_init_start();
+	KC_MSG("cvx16_polling_dfi_init_start finish\n");
+
+	cvx16_INT_ISR_08();
+	KC_MSG("cvx16_INT_ISR_08 finish\n");
+
+	// ddr_phy_power_on_seq3
+	cvx16_ddr_phy_power_on_seq3();
+	KC_MSG("ddr_phy_power_on_seq3 finish\n");
+
+	// wait_for_dfi_init_complete
+	cvx16_wait_for_dfi_init_complete();
+	KC_MSG("wait_for_dfi_init_complete finish\n");
+
+	// polling_synp_normal_mode
+	cvx16_polling_synp_normal_mode();
+	KC_MSG("polling_synp_normal_mode finish\n");
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		ERROR("ERROR bist_fail\n");
+		ERROR("bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+			  err_data_even);
+	}
+#endif
+
+	ctrl_init_low_patch();
+	KC_MSG("ctrl_low_patch finish\n");
+
+	// cvx16_wrlvl_req
+#ifndef DDR2
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3)	{
+		cvx16_wrlvl_req();
+		KC_MSG("cvx16_wrlvl_req finish\n");
+	}
+#else
+	cvx16_wrlvl_req();
+	KC_MSG("cvx16_wrlvl_req finish\n");
+#endif
+#endif
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		ERROR("ERROR bist_fail\n");
+		ERROR("bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+			  err_data_even);
+	}
+#endif
+	// cvx16_rdglvl_req
+	cvx16_rdglvl_req();
+	KC_MSG("cvx16_rdglvl_req finish\n");
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		ERROR("ERROR bist_fail\n");
+		ERROR("bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+			  err_data_even);
+	}
+#endif
+
+	//ERROR("AXI mon setting for latency histogram.\n");
+	//axi_mon_set_lat_bin_size(0x5);
+
+#ifdef DBG_SHMOO
+	// DPHY WDQ
+	// param_phyd_dfi_wdqlvl_vref_start [6:0]
+	// param_phyd_dfi_wdqlvl_vref_end [14:8]
+	// param_phyd_dfi_wdqlvl_vref_step [19:16]
+	mmio_wr32(0x08000190, 0x00021E02);
+
+	// param_phyd_piwdqlvl_dly_step[23:20]
+	mmio_wr32(0x080000a4, 0x01220504);
+
+	// write start   shift = 5  /  dline = 78
+	mmio_wr32(0x080000a0, 0x0d400578);
+
+	//write
+	KC_MSG("wdqlvl_M1_ALL_DQ_DM\n");
+	// data_mode = 'h0 : phyd pattern
+	// data_mode = 'h1 : bist read/write
+	// data_mode = 'h11: with Error enject,  multi- bist write/read
+	// data_mode = 'h12: with Error enject,  multi- bist write/read
+	// lvl_mode  = 'h0 : wdmlvl
+	// lvl_mode  = 'h1 : wdqlvl
+	// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+	// cvx16_wdqlvl_req(data_mode, lvl_mode)
+	NOTICE("cvx16_wdqlvl_sw_req dq/dm\n"); console_getc();
+	cvx16_wdqlvl_sw_req(1, 2);
+	// cvx16_wdqlvl_status();
+	KC_MSG("cvx16_wdqlvl_req dq/dm finish\n");
+
+	NOTICE("cvx16_wdqlvl_sw_req dq\n"); console_getc();
+	cvx16_wdqlvl_sw_req(1, 1);
+	// cvx16_wdqlvl_status();
+	KC_MSG("cvx16_wdqlvl_req dq finish\n");
+
+	NOTICE("cvx16_wdqlvl_sw_req dm\n"); console_getc();
+	cvx16_wdqlvl_sw_req(1, 0);
+	// cvx16_wdqlvl_status();
+	NOTICE("cvx16_wdqlvl_req dm finish\n");
+#else //DBG_SHMOO
+	// cvx16_wdqlvl_req
+	KC_MSG("wdqlvl_M1_ALL_DQ_DM\n");
+	// sso_8x1_c(5, 15, 0, 1, &sram_sp);//mode = write, input int fmin = 5, input int fmax = 15,
+					    //input int sram_st = 0, output int sram_sp
+
+	// data_mode = 'h0 : phyd pattern
+	// data_mode = 'h1 : bist read/write
+	// data_mode = 'h11: with Error enject,  multi- bist write/read
+	// data_mode = 'h12: with Error enject,  multi- bist write/read
+	// lvl_mode  = 'h0 : wdmlvl
+	// lvl_mode  = 'h1 : wdqlvl
+	// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+	// cvx16_wdqlvl_req(data_mode, lvl_mode);
+	cvx16_wdqlvl_req(1, 2);
+	KC_MSG("cvx16_wdqlvl_req dq/dm finish\n");
+
+	cvx16_wdqlvl_req(1, 1);
+	KC_MSG("cvx16_wdqlvl_req dq finish\n");
+
+	cvx16_wdqlvl_req(1, 0);
+	KC_MSG("cvx16_wdqlvl_req dm finish\n");
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR bist_fail\n");
+	}
+#endif
+#endif //!DBG_SHMOO
+
+#ifdef DBG_SHMOO
+	// param_phyd_pirdlvl_dly_step [3:0]
+	// param_phyd_pirdlvl_vref_step [11:8]
+	mmio_wr32(0x08000088, 0x0A010212);
+
+	//read
+	NOTICE("cvx16_rdlvl_req start\n"); console_getc();
+	NOTICE("SW mode 1, sram write/read continuous goto\n");
+	cvx16_rdlvl_sw_req(1);
+	// cvx16_rdlvl_status();
+	NOTICE("cvx16_rdlvl_req finish\n");
+#else //DBG_SHMOO
+	// cvx16_rdlvl_req
+	// mode = 'h0  : MPR mode, DDR3 only.
+	// mode = 'h1  : sram write/read continuous goto
+	// mode = 'h2  : multi- bist write/read
+	// mode = 'h10 : with Error enject,  multi- bist write/read
+	// mode = 'h12 : with Error enject,  multi- bist write/read
+	rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 7, 4); // param_phyd_pirdlvl_capture_cnt
+	mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+
+	KC_MSG("mode multi- bist write/read\n");
+	// cvx16_rdlvl_req(2); // mode multi- PRBS bist write/read
+	cvx16_rdlvl_req(1); // mode multi- SRAM bist write/read
+	KC_MSG("cvx16_rdlvl_req finish\n");
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR bist_fail\n");
+	}
+#endif
+#endif //!DBG_SHMOO
+
+#ifdef DBG_SHMOO_CA
+	//CA training
+	NOTICE("\n===== calvl_req =====\n"); console_getc();
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp_1);
+	calvl_req(cap);
+#endif //DBG_SHMOO_CA
+
+#ifdef DBG_SHMOO_CS
+	//CS training
+	NOTICE("\n===== cslvl_req =====\n"); console_getc();
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp_1);
+	cslvl_req(cap);
+#endif // DBG_SHMOO_CS
+
+#if defined(DBG_SHMOO) || defined(DDR_SIM)
+	cvx16_dll_cal_status();
+	cvx16_wrlvl_status();
+	cvx16_rdglvl_status();
+	cvx16_rdlvl_status();
+	cvx16_wdqlvl_status();
+#endif // DBG_SHMOO || DDR_SIM
+
+	// ctrl_high_patch
+	ctrl_init_high_patch();
+
+	ctrl_init_detect_dram_size(&dram_cap_in_mbyte);
+	KC_MSG("ctrl_init_detect_dram_size finish\n");
+
+	ctrl_init_update_by_dram_size(dram_cap_in_mbyte);
+	KC_MSG("ctrl_init_update_by_dram_size finish\n");
+
+	KC_MSG("dram_cap_in_mbyte = %x\n", dram_cap_in_mbyte);
+	cvx16_dram_cap_check(dram_cap_in_mbyte);
+	KC_MSG("cvx16_dram_cap_check finish\n");
+
+	// clk_gating_enable
+	cvx16_clk_gating_enable();
+	KC_MSG("cvx16_clk_gating_enable finish\n");
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR prbs bist_fail\n");
+		NOTICE("DDR BIST FAIL\n");
+		while (1) {
+		}
+	}
+
+	cvx16_bist_wr_sram_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR sram bist_fail\n");
+		NOTICE("DDR BIST FAIL\n");
+		while (1) {
+		}
+	}
+	NOTICE("DDR BIST PASS\n");
+#endif
+
+#ifdef FULL_MEM_BIST
+	//full memory
+	// sso_8x1_c(5, 15, 0, 1, &sram_sp);
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp);
+
+	NOTICE("====FULL_MEM_BIST====\n");
+	bist_result = bist_all_dram(0, cap);
+	if (bist_result == 0) {
+		NOTICE("bist_all_dram(prbs): ERROR bist_fail\n");
+	} else {
+		NOTICE("bist_all_dram(prbs): BIST PASS\n");
+	}
+
+	bist_result = bist_all_dram(1, cap);
+	if (bist_result == 0) {
+		NOTICE("bist_all_dram(sram): ERROR bist_fail\n");
+	} else {
+		NOTICE("bist_all_dram(sram): BIST PASS\n");
+	}
+
+	bist_result = bist_all_dram(2, cap);
+	if (bist_result == 0) {
+		NOTICE("bist_all_dram(01): ERROR bist_fail\n");
+	} else {
+		NOTICE("bist_all_dram(01): BIST PASS\n");
+	}
+
+	NOTICE("===== BIST END ======\n");
+#endif //FULL_MEM_BIST
+
+#ifdef FULL_MEM_BIST_FOREVER
+	NOTICE("Press any key to start stress test\n"); console_getc();
+	bist_all_dram_forever(cap);
+#endif //FULL_MEM_BIST_FOREVER
+
+	//NOTICE("AXI mon setting for latency histogram.\n");
+	axi_mon_latency_setting(0x5);
+
+	//NOTICE("AXI mon 0 register dump before start.\n");
+	//dump_axi_mon_reg(AXIMON_M1_WRITE);
+	//NOTICE("AXI mon 1 register dump before start.\n");
+	//dump_axi_mon_reg(AXIMON_M1_READ);
+
+	axi_mon_start_all();
+
+#if defined(DBG_SHMOO) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+	while (1)
+		;
+#endif
+
+}
diff --git a/firmware/plat/cv180x/ddr/phy_pll_init.c b/firmware/plat/cv180x/ddr/phy_pll_init.c
new file mode 100644
index 0000000..754ffba
--- /dev/null
+++ b/firmware/plat/cv180x/ddr/phy_pll_init.c
@@ -0,0 +1,40 @@
+#include <platform.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+
+uint32_t  freq_in;
+uint32_t  tar_freq;
+uint32_t  mod_freq;
+uint32_t  dev_freq;
+uint64_t  reg_set;
+uint64_t  reg_span;
+uint64_t  reg_step;
+
+void pll_init(void)
+{
+	freq_in = 752;
+	mod_freq = 100;
+	dev_freq = 15;
+	NOTICE("Data rate=%d.\n", ddr_data_rate);
+#ifdef SSC_EN
+	tar_freq = (ddr_data_rate >> 4) * 0.985;
+#else
+	tar_freq = (ddr_data_rate >> 4);
+#endif
+	reg_set = (uint64_t)freq_in * 67108864 / tar_freq;
+	reg_span = ((tar_freq * 250) / mod_freq);
+	reg_step = reg_set * dev_freq / (reg_span * 1000);
+	uartlog("ddr_data_rate = %d, freq_in = %d reg_set = %lx tar_freq = %x reg_span = %lx reg_step = %lx\n",
+		ddr_data_rate, freq_in, reg_set, tar_freq, reg_span, reg_step);
+	// uartlog("reg_set = %lx\n", reg_set);
+	// uartlog("tar_freq = %x\n", tar_freq);
+	// uartlog("reg_span = %lx\n", reg_span);
+	// uartlog("reg_step = %lx\n", reg_step);
+
+	cvx16_pll_init();
+}
diff --git a/firmware/plat/cv180x/fipsign.py b/firmware/plat/cv180x/fipsign.py
deleted file mode 100644
index 99d19c4..0000000
--- a/firmware/plat/cv180x/fipsign.py
+++ /dev/null
@@ -1,252 +0,0 @@
-#!/usr/bin/env python3
-# PYTHON_ARGCOMPLETE_OK
-
-import logging
-import argparse
-from struct import unpack
-
-from Crypto.Cipher import AES
-from Crypto.Hash import SHA256
-from Crypto.PublicKey import RSA
-from Crypto.Signature import pkcs1_15
-
-try:
-    import argcomplete
-except ImportError:
-    argcomplete = None
-
-from fiptool import FIP, IMAGE_ALIGN, init_logging
-
-ENCRYPTION_KEY_SIZE = 16
-ENCRYPTION_BLOCK_SIZE = 16
-IV_ZERO = b"\0" * ENCRYPTION_BLOCK_SIZE
-
-
-class SignedFIP(FIP):
-    def __init__(self, root_priv_path, bl_priv_path):
-        super().__init__()
-
-        with open(root_priv_path, "rb") as fp:
-            din = fp.read()
-            self.root_priv = RSA.import_key(din)
-
-        with open(bl_priv_path, "rb") as fp:
-            din = fp.read()
-            self.bl_priv = RSA.import_key(din)
-
-    def read_fip(self, path):
-        super().read_fip(path)
-
-        # Verity the reading of fip.bin
-        with open(path, "rb") as fp:
-            assert fp.read() == self.make()
-
-    def rsa_to_n(self, rsa):
-        return rsa.n.to_bytes(rsa.size_in_bytes(), byteorder="big")
-
-    def print_kpub_hash(self, bytes):
-        bytes_str = ['{:02x}'.format(int(i)) for i in bytes]
-        logging.info("KPUB_HASH:" + "".join(bytes_str))
-
-    def sign_bl_pk(self):
-        self.param1["ROOT_PK"].content = self.rsa_to_n(self.root_priv)
-        kpub_hash = SHA256.new(self.param1["ROOT_PK"].content[:256])
-        self.print_kpub_hash(kpub_hash.digest())
-
-        self.param1["BL_PK"].content = self.rsa_to_n(self.bl_priv)
-
-        digest = SHA256.new(self.rsa_to_n(self.bl_priv))
-
-        sig = pkcs1_15.new(self.root_priv).sign(digest)
-        self.param1["BL_PK_SIG"].content = sig
-
-    def sign_by_bl_priv(self, image):
-        digest = SHA256.new(image)
-        return pkcs1_15.new(self.bl_priv).sign(digest)
-
-    def sign(self):
-        logging.info("sign fip.bin")
-
-        self.param1["FIP_FLAGS"].content = self.FIP_FLAGS_SCS_MASK | self.param1["FIP_FLAGS"].toint()
-
-        self.sign_bl_pk()
-
-        cc = self.param1["CHIP_CONF"].content
-        cc_size = unpack("<I", self.param1["CHIP_CONF_SIZE"].content)[0]
-        logging.debug("CHIP_CONF_SIZE=%#x", cc_size)
-        cc = cc[:cc_size]
-
-        self.param1["CHIP_CONF_SIG"].content = self.sign_by_bl_priv(cc)
-        self.param1["BL2_IMG_SIG"].content = self.sign_by_bl_priv(self.body1["BL2"].content)
-
-        if self.body1["BLCP"].content:
-            logging.debug("sign blcp")
-            self.param1["BLCP_IMG_SIG"].content = self.sign_by_bl_priv(self.body1["BLCP"].content)
-
-        self.sign_fip2()
-
-    def sign_fip2(self):
-        logging.debug("sign_fip2:")
-
-        sig_size = len(self.rsa_to_n(self.bl_priv))
-
-        for name in ["BLCP_2ND", "MONITOR"]:
-            e = self.body2[name]
-            if not e.content:
-                continue
-
-            logging.info("sign %s: len=%#x", name, len(e.content))
-
-            image = bytearray(self.pad(e.content + b"\xCE" * sig_size, IMAGE_ALIGN))
-            sig = self.sign_by_bl_priv(image[:-sig_size])
-            assert sig_size == len(sig)
-            image[-sig_size:] = sig
-
-            e.content = image
-
-        loader_2nd_loadaddr = self.param2["LOADER_2ND_LOADADDR"].toint()
-        if loader_2nd_loadaddr:
-            logging.info("sign %s at %#x", "LOADER_2ND_LOADADDR", loader_2nd_loadaddr)
-
-            # Only data after CKSUM field are signed.
-            # The value CKSUM include signature and is updated later.
-            e = self.body2["LOADER_2ND"]
-            e.content = self.pad(e.content + b"\xCE" * sig_size, IMAGE_ALIGN)
-            # SIZE is after CKSUM, update it before signing
-            self._update_ldr_2nd_hdr()
-
-            image = bytearray(e.content)
-            sig = self.sign_by_bl_priv(image[self.ldr_2nd_hdr["CKSUM"].end : -sig_size])
-            assert sig_size == len(sig)
-            image[-sig_size:] = sig
-
-            e.content = image
-
-
-class EncryptedFIP(SignedFIP):
-    def __init__(self, root_priv_path, bl_priv_path, ldr_ek_path, bl_ek_path):
-        super().__init__(root_priv_path, bl_priv_path)
-
-        with open(ldr_ek_path, "rb") as fp:
-            self.ldr_ek = fp.read()
-
-        with open(bl_ek_path, "rb") as fp:
-            self.bl_ek = fp.read()
-
-    def _aes_encrypt(self, key, plain):
-        return AES.new(key, iv=IV_ZERO, mode=AES.MODE_CBC).encrypt(plain)
-
-    def encrypt(self):
-        logging.debug("encrypt:")
-
-        self.param1["FIP_FLAGS"].content = self.FIP_FLAGS_ENCRYPTED_MASK | self.param1["FIP_FLAGS"].toint()
-
-        self.param1["BL_EK"].content = self._aes_encrypt(self.ldr_ek, self.bl_ek)
-        self.body1["BL2"].content = self._aes_encrypt(self.bl_ek, self.body1["BL2"].content)
-
-        for name in ["BLCP_2ND", "MONITOR"]:
-            e = self.body2[name]
-            if not e.content:
-                continue
-
-            logging.info("encrypt %s: len=%#x", name, len(e.content))
-            e.content = self._aes_encrypt(self.bl_ek, e.content)
-
-        loader_2nd_loadaddr = self.param2["LOADER_2ND_LOADADDR"].toint()
-        if loader_2nd_loadaddr:
-            logging.info("encrypt %s at %#x", "LOADER_2ND_LOADADDR", loader_2nd_loadaddr)
-
-            # Only data after header are encrypted
-            e = self.body2["LOADER_2ND"]
-
-            hdr_size = self._param_size(self.ldr_2nd_hdr)
-            hdr, body = e.content[:hdr_size], e.content[hdr_size:]
-
-            body = self._aes_encrypt(self.bl_ek, body)
-            e.content = hdr + body
-
-
-def sign_fip(args):
-    logging.debug("sign_fip:")
-
-    fip = SignedFIP(args.root_priv, args.bl_priv)
-    fip.read_fip(args.SRC_FIP)
-
-    fip.sign()
-
-    fip_bin = fip.make()
-    fip.print_fip_params()
-    with open(args.DEST_FIP, "wb") as fp:
-        fp.write(fip_bin)
-
-
-def encrypt_fip(args):
-    logging.debug("encrypt_fip:")
-
-    fip = EncryptedFIP(args.root_priv, args.bl_priv, args.ldr_ek, args.bl_ek)
-    fip.read_fip(args.SRC_FIP)
-
-    fip.sign()
-    fip.encrypt()
-
-    fip_bin = fip.make()
-    fip.print_fip_params()
-    with open(args.DEST_FIP, "wb") as fp:
-        fp.write(fip_bin)
-
-
-def parse_args():
-    parser = argparse.ArgumentParser(description="FIP tools")
-
-    parser.add_argument(
-        "-v",
-        "--verbose",
-        help="Increase output verbosity",
-        action="store_const",
-        const=logging.DEBUG,
-        default=logging.INFO,
-    )
-
-    def auto_int(x):
-        return int(x, 0)
-
-    subparsers = parser.add_subparsers(dest="subcmd", help="Sub-command help")
-
-    pr_encrypt = subparsers.add_parser("sign-enc")
-    pr_encrypt.set_defaults(func=encrypt_fip)
-    pr_encrypt.add_argument("--ldr-ek", type=str)
-    pr_encrypt.add_argument("--bl-ek", type=str)
-
-    pr_sign = subparsers.add_parser("sign")
-    pr_sign.set_defaults(func=sign_fip)
-
-    for pr in [pr_sign, pr_encrypt]:
-        pr.add_argument("--root-priv", type=str)
-        pr.add_argument("--bl-priv", type=str)
-        pr.add_argument("SRC_FIP", type=str, help="Source fip.bin")
-        pr.add_argument("DEST_FIP", type=str, help="Signed fip.bin")
-
-    if argcomplete:
-        argcomplete.autocomplete(parser)
-
-    args = parser.parse_args()
-    init_logging(stdout_level=args.verbose)
-    logging.info("PROG: %s", parser.prog)
-
-    if not args.subcmd:
-        parser.print_help()
-        raise SystemExit(1)
-
-    for a, v in sorted(vars(args).items()):
-        logging.debug("%s=%r", a, v)
-
-    return args
-
-
-def main():
-    args = parse_args()
-    args.func(args)
-
-
-if __name__ == "__main__":
-    main()
diff --git a/firmware/plat/cv180x/fipsign.py b/firmware/plat/cv180x/fipsign.py
new file mode 120000
index 0000000..230fdb2
--- /dev/null
+++ b/firmware/plat/cv180x/fipsign.py
@@ -0,0 +1 @@
+../cv181x/fipsign.py
\ No newline at end of file
diff --git a/firmware/plat/cv180x/fiptool.py b/firmware/plat/cv180x/fiptool.py
deleted file mode 100755
index f85f89e..0000000
--- a/firmware/plat/cv180x/fiptool.py
+++ /dev/null
@@ -1,802 +0,0 @@
-#!/usr/bin/env python3
-# PYTHON_ARGCOMPLETE_OK
-
-import sys
-import logging
-import os
-import os.path
-import argparse
-from collections import OrderedDict
-import binascii
-from struct import pack, unpack
-# import lzma
-import pprint
-
-
-PYTHON_MIN_VERSION = (3, 5, 2)  # Ubuntu 16.04 LTS contains Python v3.5.2 by default
-
-
-if sys.version_info < PYTHON_MIN_VERSION:
-    print("Python >= %r is required" % (PYTHON_MIN_VERSION,))
-    sys.exit(-1)
-
-
-try:
-    import coloredlogs
-except ImportError:
-    coloredlogs = None
-
-try:
-    import argcomplete
-except ImportError:
-    argcomplete = None
-
-
-LOADER_2ND_MAGIC_ORIG = b"BL33"
-LOADER_2ND_MAGIC_LZMA = b"B3MA"
-LOADER_2ND_MAGIC_LZ4 = b"B3Z4"
-
-LOADER_2ND_MAGIC_LIST = [
-    LOADER_2ND_MAGIC_ORIG,
-    LOADER_2ND_MAGIC_LZMA,
-    LOADER_2ND_MAGIC_LZ4,
-]
-
-IMAGE_ALIGN = 512
-PARAM1_SIZE = 0x1000
-PARAM1_SIZE_WO_SIG = 0x800
-PARAM2_SIZE = 0x1000
-
-
-def round_up(divident, divisor):
-    return ((divident + divisor - 1) // divisor) * divisor
-
-
-def lzma_compress(body):
-    z = lzma.LZMACompressor(lzma.FORMAT_ALONE, preset=lzma.PRESET_EXTREME)
-    compressed = z.compress(body)
-    compressed += z.flush()
-
-    return compressed
-
-
-def lz4_compress(body):
-    try:
-        import lz4.frame
-    except ImportError:
-        logging.error("lz4 is not installed. Run 'pip install lz4'.")
-        raise
-
-    compressed = lz4.frame.compress(body)
-    return compressed
-
-
-class Entry:
-    __slots__ = "name", "type", "addr", "_content", "entry_size"
-
-    def __init__(self):
-        self.addr = None
-        self._content = None
-
-    @property
-    def end(self):
-        return self.addr + self.entry_size
-
-    @property
-    def content(self):
-        return self._content
-
-    @content.setter
-    def content(self, value):
-        if type(value) == int:
-            value = value.to_bytes(self.entry_size, "little")
-
-        if self.entry_size is not None:
-            if len(value) > self.entry_size:
-                raise ValueError("%s (%d bytes) must <= %#r" % (self.name, len(value), self.entry_size))
-            value = value + b"\0" * (self.entry_size - len(value))
-
-        self._content = value
-
-    @classmethod
-    def make(cls, name, entry_size, _type, init=None):
-        entry = Entry()
-        entry.name = name
-        entry.type = _type
-        entry.entry_size = entry_size
-
-        if type(init) in (bytes, bytearray):
-            entry.content = bytes(init)
-        elif entry_size is not None:
-            entry.content = b"\0" * entry.entry_size
-        else:
-            entry.content = b""
-
-        return (name, entry)
-
-    def toint(self):
-        if self.type != int:
-            raise TypeError("%s is not int type" % self.name)
-
-        return int.from_bytes(self.content, "little")
-
-    def tostr(self):
-        v = self.content
-        if self.type == int:
-            v = "%#08x" % self.toint()
-        elif type(self.content) in [bytes, bytearray]:
-            v = v.hex()
-            if len(v) > 32:
-                v = v[:32] + "..."
-
-        return v
-
-    def __str__(self):
-        v = self.tostr()
-        return "<%s=%s (%dbytes)>" % (self.name, v, self.entry_size)
-
-    def __repr__(self):
-        v = self.tostr()
-        return "<%s: a=%#x s=%#x c=%s %r>" % (self.name, self.addr, self.entry_size, v, self.type)
-
-
-class FIP:
-    param1 = OrderedDict(
-        [
-            Entry.make("MAGIC1", 8, int, b"CVBL01\n\0"),
-            Entry.make("MAGIC2", 4, int),
-            Entry.make("PARAM_CKSUM", 4, int),
-            Entry.make("NAND_INFO", 128, int),
-            Entry.make("NOR_INFO", 36, int),
-            Entry.make("FIP_FLAGS", 8, int),
-            Entry.make("CHIP_CONF_SIZE", 4, int),
-            Entry.make("BLCP_IMG_CKSUM", 4, int),
-            Entry.make("BLCP_IMG_SIZE", 4, int),
-            Entry.make("BLCP_IMG_RUNADDR", 4, int),
-            Entry.make("BLCP_PARAM_LOADADDR", 4, int),
-            Entry.make("BLCP_PARAM_SIZE", 4, int),
-            Entry.make("BL2_IMG_CKSUM", 4, int),
-            Entry.make("BL2_IMG_SIZE", 4, int),
-            Entry.make("BLD_IMG_SIZE", 4, int),
-            Entry.make("PARAM2_LOADADDR", 4, int),
-            Entry.make("RESERVED1", 4, int),
-            Entry.make("CHIP_CONF", 760, bytes),
-            Entry.make("BL_EK", 32, bytes),
-            Entry.make("ROOT_PK", 512, bytes),
-            Entry.make("BL_PK", 512, bytes),
-            Entry.make("BL_PK_SIG", 512, bytes),
-            Entry.make("CHIP_CONF_SIG", 512, bytes),
-            Entry.make("BL2_IMG_SIG", 512, bytes),
-            Entry.make("BLCP_IMG_SIG", 512, bytes),
-        ]
-    )
-
-    body1 = OrderedDict(
-        [
-            Entry.make("BLCP", None, bytes),
-            Entry.make("BL2", None, bytes),
-        ]
-    )
-
-    param2 = OrderedDict(
-        [
-            Entry.make("MAGIC1", 8, int, b"CVLD02\n\0"),
-            Entry.make("PARAM2_CKSUM", 4, int),
-            Entry.make("RESERVED1", 4, bytes),
-            # DDR param
-            Entry.make("DDR_PARAM_CKSUM", 4, int),
-            Entry.make("DDR_PARAM_LOADADDR", 4, int),
-            Entry.make("DDR_PARAM_SIZE", 4, int),
-            Entry.make("DDR_PARAM_RESERVED", 4, int),
-            # BLCP_2ND
-            Entry.make("BLCP_2ND_CKSUM", 4, int),
-            Entry.make("BLCP_2ND_LOADADDR", 4, int),
-            Entry.make("BLCP_2ND_SIZE", 4, int),
-            Entry.make("BLCP_2ND_RUNADDR", 4, int),
-            # ATF-BL31 or OpenSBI
-            Entry.make("MONITOR_CKSUM", 4, int),
-            Entry.make("MONITOR_LOADADDR", 4, int),
-            Entry.make("MONITOR_SIZE", 4, int),
-            Entry.make("MONITOR_RUNADDR", 4, int),
-            # u-boot
-            Entry.make("LOADER_2ND_RESERVED0", 4, int),
-            Entry.make("LOADER_2ND_LOADADDR", 4, int),
-            Entry.make("LOADER_2ND_RESERVED1", 4, int),
-            Entry.make("LOADER_2ND_RESERVED2", 4, int),
-            # Reserved
-            Entry.make("RESERVED_LAST", 4096 - 16 * 5, bytes),
-        ]
-    )
-
-    body2 = OrderedDict(
-        [
-            Entry.make("DDR_PARAM", None, bytes),
-            Entry.make("BLCP_2ND", None, bytes),
-            Entry.make("MONITOR", None, bytes),
-            Entry.make("LOADER_2ND", None, bytes),
-        ]
-    )
-
-    ldr_2nd_hdr = OrderedDict(
-        [
-            Entry.make("JUMP0", 4, int),
-            Entry.make("MAGIC", 4, int),
-            Entry.make("CKSUM", 4, int),
-            Entry.make("SIZE", 4, int),
-            Entry.make("RUNADDR", 8, int),
-            Entry.make("RESERVED1", 4, int),
-            Entry.make("RESERVED2", 4, int),
-        ]
-    )
-
-    FIP_FLAGS_SCS_MASK = 0x000c
-    FIP_FLAGS_ENCRYPTED_MASK = 0x0030
-
-    def _param_size(self, param):
-        return max((e.end for e in param.values()))
-
-    def _gen_param(self):
-        addr = 0
-        for entry in self.param1.values():
-            entry.addr = addr
-            addr += entry.entry_size
-
-        assert PARAM1_SIZE_WO_SIG == self.param1["BL_PK_SIG"].addr
-
-        addr = 0
-        for entry in self.param2.values():
-            entry.addr = addr
-            addr += entry.entry_size
-
-        assert PARAM2_SIZE == self.param2["RESERVED_LAST"].addr + self.param2["RESERVED_LAST"].entry_size
-
-        addr = 0
-        for entry in self.ldr_2nd_hdr.values():
-            entry.addr = addr
-            addr += entry.entry_size
-
-    def __init__(self):
-        self.compress_algo = None
-        self._gen_param()
-
-    def image_crc(self, image):
-        crc = binascii.crc_hqx(image, 0)
-        crc = pack("<H", crc) + b"\xFE\xCA"
-        return crc
-
-    def pad(self, data, block_size):
-        if type(data) not in [bytearray, bytes]:
-            raise TypeError("Need bytearray or bytes")
-
-        r = len(data) % block_size
-        if r:
-            data += b"\0" * (block_size - r)
-
-        return data
-
-    def _pprint_attr(self, name):
-        v = getattr(self, name)
-
-        if type(v) == OrderedDict:
-            v = list(v.values())
-        logging.info("print(%s):\n" % name + pprint.pformat(v, 4, 140))
-
-    def print_fip_params(self):
-        self._pprint_attr("param1")
-        self._pprint_attr("param2")
-        self._pprint_attr("ldr_2nd_hdr")
-
-    def read_fip(self, path):
-        logging.debug("read_fip:")
-
-        with open(path, "rb") as fp:
-            fip_bin = fp.read()
-
-        fip_bin = bytearray(fip_bin)
-
-        e = self.param1["MAGIC1"]
-        if fip_bin[e.addr : e.end] != e.content:
-            raise ValueError("Unknown magic %r" % fip_bin[e.addr : e.end])
-
-        # Read param1 from fip.bin
-        for e in self.param1.values():
-            e.content = fip_bin[e.addr : e.end]
-
-        self.read_end = PARAM1_SIZE
-
-        # Read BLCP
-        e = self.param1["BLCP_IMG_SIZE"]
-        blcp_img_size = unpack("<I", fip_bin[e.addr : e.end])[0]
-        if blcp_img_size:
-            start = self.read_end
-            self.read_end = start + blcp_img_size
-            self.body1["BLCP"].content = fip_bin[start : self.read_end]
-
-        # Read FSBL as BL2
-        e = self.param1["BL2_IMG_SIZE"]
-        bl2_img_size = unpack("<I", fip_bin[e.addr : e.end])[0]
-        if bl2_img_size:
-            start = self.read_end
-            self.read_end = start + bl2_img_size
-            self.body1["BL2"].content = fip_bin[start : self.read_end]
-
-        logging.info("read_fip end=%#x", self.read_end)
-        self.rest_fip = fip_bin[self.read_end :]
-
-        self.read_fip2(fip_bin)
-
-    def read_fip2(self, fip_bin):
-        param2_loadaddr = self.param1["PARAM2_LOADADDR"].toint()
-        param2_bin = fip_bin[param2_loadaddr : param2_loadaddr + PARAM2_SIZE]
-
-        for e in self.param2.values():
-            e.content = param2_bin[e.addr : e.end]
-
-        self.read_end = param2_loadaddr + PARAM2_SIZE
-
-        # Read DDR_PARAM, BLCP_2ND, and MONITOR
-        for name in ["DDR_PARAM", "BLCP_2ND", "MONITOR"]:
-            size = self.param2[name + "_SIZE"].toint()
-            loadaddr = self.param2[name + "_LOADADDR"].toint()
-            self.body2[name].content = fip_bin[loadaddr : loadaddr + size]
-            self.read_end = loadaddr + size
-
-        # Read LOADER_2ND
-        loader_2nd_loadaddr = self.param2["LOADER_2ND_LOADADDR"].toint()
-        if loader_2nd_loadaddr:
-            self.read_loader_2nd(fip_bin)
-
-        logging.info("read_fip2 end=%#x", self.read_end)
-        self.rest_fip = fip_bin[self.read_end :]
-
-    def read_loader_2nd(self, fip_bin):
-        loader_2nd_loadaddr = self.param2["LOADER_2ND_LOADADDR"].toint()
-
-        self._parse_ldr_2nd_hdr(fip_bin[loader_2nd_loadaddr:])
-
-        if self.ldr_2nd_hdr["MAGIC"].content not in LOADER_2ND_MAGIC_LIST:
-            raise ValueError("%r" % self.ldr_2nd_hdr["MAGIC"].content)
-
-        ldr_2nd_size = self.ldr_2nd_hdr["SIZE"].toint()
-
-        self.body2["LOADER_2ND"].content = fip_bin[loader_2nd_loadaddr : loader_2nd_loadaddr + ldr_2nd_size]
-
-        self.read_end = loader_2nd_loadaddr + ldr_2nd_size
-        self.rest_fip = fip_bin[self.read_end :]
-
-    def add_chip_conf(self, args):
-        logging.debug("add_chip_conf:")
-
-        with open(args.CHIP_CONF, "rb") as fp:
-            image = fp.read()
-
-        if image.startswith(b"APLB"):
-            image = image[8:]  # strip old BLP header
-
-        self.param1["CHIP_CONF"].content = image
-
-    def add_blcp(self, args):
-        logging.debug("add_blcp:")
-
-        with open(args.BLCP, "rb") as fp:
-            image = fp.read()
-
-        image = self.pad(image, IMAGE_ALIGN)
-
-        self.param1["BLCP_IMG_RUNADDR"].content = args.BLCP_IMG_RUNADDR
-        self.body1["BLCP"].content = image
-
-    def add_bl2(self, args):
-        logging.debug("add_bl2:")
-
-        with open(args.BL2, "rb") as fp:
-            image = fp.read()
-
-        bl2_fill = 0
-        if args.BL2_FILL:
-            bl2_fill = args.BL2_FILL
-
-        image += b"\xA9" * (bl2_fill - len(image))
-        image = self.pad(image, IMAGE_ALIGN)
-
-        self.body1["BL2"].content = image
-
-    def add_nor_info(self, args):
-        logging.debug("add_nor_info:")
-        self.param1["NOR_INFO"].content = args.NOR_INFO
-
-    def add_nand_info(self, args):
-        logging.debug("add_nand_info:")
-        self.param1["NAND_INFO"].content = args.NAND_INFO
-
-    def update_param1_cksum(self, image):
-        image = bytearray(image)
-        crc = self.image_crc(image[self.param1["NAND_INFO"].addr : PARAM1_SIZE_WO_SIG])
-
-        param_cksum = self.param1["PARAM_CKSUM"]
-        param_cksum.content = crc
-        image[param_cksum.addr : param_cksum.end] = crc
-        return image
-
-    def make_fip1(self):
-        logging.debug("make_fip1:")
-
-        chip_conf = self.param1["CHIP_CONF"].content
-        self.param1["CHIP_CONF_SIZE"].content = len(chip_conf)
-
-        blcp = self.body1["BLCP"].content
-        self.param1["BLCP_IMG_CKSUM"].content = self.image_crc(blcp)
-        self.param1["BLCP_IMG_SIZE"].content = len(blcp)
-
-        bl2 = self.body1["BL2"].content
-        self.param1["BL2_IMG_CKSUM"].content = self.image_crc(bl2)
-        self.param1["BL2_IMG_SIZE"].content = len(bl2)
-
-        # Pack body1
-        body1_bin = b""
-        for entry in self.body1.values():
-            if len(entry.content) % IMAGE_ALIGN:
-                raise ValueError("%s (%d) is not align to %d" % (entry.name, len(entry.content), IMAGE_ALIGN))
-
-            logging.info("add %s (%#x)", entry.name, len(entry.content))
-            body1_bin += entry.content
-
-        logging.debug("len(body1_bin) is %d", len(body1_bin))
-
-        # Param1 cksum
-        param1_bin = b"".join((entry.content for entry in self.param1.values()))
-        param1_bin = self.update_param1_cksum(param1_bin)
-
-        if len(param1_bin) != PARAM1_SIZE:
-            raise ValueError("param1_bin is %d bytes" % len(param1_bin))
-
-        fip1_bin = param1_bin + body1_bin
-        logging.debug("len(fip1_bin) is %d", len(fip1_bin))
-
-        return fip1_bin
-
-    def add_ddr_param(self, args):
-        with open(args.DDR_PARAM, "rb") as fp:
-            ddr_param = fp.read()
-
-        logging.debug("ddr_param=%#x bytes", len(ddr_param))
-        self.body2["DDR_PARAM"].content = ddr_param
-
-    def add_blcp_2nd(self, args):
-        with open(args.BLCP_2ND, "rb") as fp:
-            blcp_2nd = fp.read()
-
-        logging.debug("blcp_2nd=%#x bytes", len(blcp_2nd))
-        self.body2["BLCP_2ND"].content = blcp_2nd
-
-    def add_monitor(self, args):
-        with open(args.MONITOR, "rb") as fp:
-            monitor = fp.read()
-
-        logging.debug("monitor=%#x bytes", len(monitor))
-        self.body2["MONITOR"].content = monitor
-
-    def add_loader_2nd(self, args):
-        with open(args.LOADER_2ND, "rb") as fp:
-            loader_2nd = fp.read()
-
-        logging.debug("loader_2nd=%#x bytes", len(loader_2nd))
-
-        e = self.ldr_2nd_hdr["MAGIC"]
-        magic = loader_2nd[e.addr : e.end]
-        if magic != LOADER_2ND_MAGIC_ORIG:
-            raise ValueError("loader_2nd's magic should be %r, but %r" % (LOADER_2ND_MAGIC_ORIG, magic))
-
-        self.compress_algo = args.compress
-        self.body2["LOADER_2ND"].content = loader_2nd
-
-    def pack_ddr_param(self, fip_bin):
-        if not len(self.body2["DDR_PARAM"].content):
-            return
-
-        fip_bin = self.pad(fip_bin, IMAGE_ALIGN)
-
-        # Pack DDR_PARAM to body2
-        ddr_param = self.pad(self.body2["DDR_PARAM"].content, IMAGE_ALIGN)
-
-        self.param2["DDR_PARAM_CKSUM"].content = self.image_crc(ddr_param)
-        self.param2["DDR_PARAM_SIZE"].content = len(ddr_param)
-        self.param2["DDR_PARAM_LOADADDR"].content = len(fip_bin)
-
-        return fip_bin + ddr_param
-
-    def pack_blcp_2nd(self, fip_bin, blcp_2nd_runaddr):
-        logging.debug("pack_blcp_2nd:")
-        if not len(self.body2["BLCP_2ND"].content):
-            return
-
-        runaddr = int(blcp_2nd_runaddr)
-
-        fip_bin = self.pad(fip_bin, IMAGE_ALIGN)
-
-        # Pack MONITOR to body2
-        body = self.pad(self.body2["BLCP_2ND"].content, IMAGE_ALIGN)
-
-        self.param2["BLCP_2ND_CKSUM"].content = self.image_crc(body)
-        self.param2["BLCP_2ND_SIZE"].content = len(body)
-        self.param2["BLCP_2ND_LOADADDR"].content = len(fip_bin)
-        self.param2["BLCP_2ND_RUNADDR"].content = runaddr
-
-        return fip_bin + body
-
-    def pack_monitor(self, fip_bin, monitor_runaddr):
-        logging.debug("pack_monitor:")
-        if not len(self.body2["MONITOR"].content):
-            return
-
-        monitor_runaddr = int(monitor_runaddr)
-
-        fip_bin = self.pad(fip_bin, IMAGE_ALIGN)
-
-        # Pack MONITOR to body2
-        monitor = self.pad(self.body2["MONITOR"].content, IMAGE_ALIGN)
-
-        self.param2["MONITOR_CKSUM"].content = self.image_crc(monitor)
-        self.param2["MONITOR_SIZE"].content = len(monitor)
-        self.param2["MONITOR_LOADADDR"].content = len(fip_bin)
-        self.param2["MONITOR_RUNADDR"].content = monitor_runaddr
-
-        return fip_bin + monitor
-
-    def _parse_ldr_2nd_hdr(self, image):
-        for e in self.ldr_2nd_hdr.values():
-            e.content = image[e.addr : e.end]
-
-    def _update_ldr_2nd_hdr(self):
-        image = self.body2["LOADER_2ND"].content
-        hdr_size = self._param_size(self.ldr_2nd_hdr)
-        hdr, body = image[:hdr_size], image[hdr_size:]
-
-        # Update SIZE
-        self.ldr_2nd_hdr["SIZE"].content = len(image)
-
-        # Update CKSUM
-        hdr = bytearray(b"".join((e.content for e in self.ldr_2nd_hdr.values())))
-        # CKSUM is calculated after "CKSUM" field
-        hdr_cksum = self.ldr_2nd_hdr["CKSUM"]
-        crc = self.image_crc((hdr + body)[hdr_cksum.end :])
-        hdr_cksum.content = crc
-        hdr = bytearray(b"".join((e.content for e in self.ldr_2nd_hdr.values())))
-
-        self.body2["LOADER_2ND"].content = hdr + body
-
-    def _compress_ldr_2nd(self):
-        image = self.body2["LOADER_2ND"].content
-        hdr_size = self._param_size(self.ldr_2nd_hdr)
-        hdr, body = image[:hdr_size], image[hdr_size:]
-
-        magic = self.ldr_2nd_hdr["MAGIC"].content
-        if magic == LOADER_2ND_MAGIC_ORIG:
-            # if image is uncompressed, compress it.
-            if self.compress_algo is None:
-                pass
-            elif self.compress_algo == "lzma":
-                self.ldr_2nd_hdr["MAGIC"].content = LOADER_2ND_MAGIC_LZMA
-                body = lzma_compress(body)
-                logging.info("lzma loader_2nd=%#x bytes wo header", len(body))
-            elif self.compress_algo == "lz4":
-                self.ldr_2nd_hdr["MAGIC"].content = LOADER_2ND_MAGIC_LZ4
-                body = lz4_compress(body)
-                logging.info("lz4 loader_2nd=%#x bytes wo header", len(body))
-            else:
-                raise NotImplementedError("'%r' is not supported." % self.compress_algo)
-        elif magic in LOADER_2ND_MAGIC_LIST:
-            logging.info("loader_2nd is already compressed")
-        else:
-            raise ValueError("unknown loader_2nd magic (%r)", magic)
-
-        self.body2["LOADER_2ND"].content = self.pad(hdr + body, IMAGE_ALIGN)
-
-    def pack_loader_2nd(self, fip_bin):
-        logging.debug("pack_loader_2nd:")
-        if not len(self.body2["LOADER_2ND"].content):
-            return
-
-        fip_bin = self.pad(fip_bin, IMAGE_ALIGN)
-        self.param2["LOADER_2ND_LOADADDR"].content = len(fip_bin)
-
-        self._parse_ldr_2nd_hdr(self.body2["LOADER_2ND"].content)
-        self._compress_ldr_2nd()
-        self._update_ldr_2nd_hdr()
-
-        # Append LOADER_2ND to body2
-        return fip_bin + self.body2["LOADER_2ND"].content
-
-    def insert_param1(self, fip_bin, name, value):
-        fip_bin = bytearray(fip_bin)
-        e = self.param1[name]
-        e.content = value
-        fip_bin[e.addr : e.end] = value
-        return self.update_param1_cksum(fip_bin)
-
-    def append_fip2(self, fip1_bin, args):
-        logging.debug("make_fip2:")
-        fip_bin = bytearray(fip1_bin)
-
-        # Update PARAM2_LOADADDR
-        param2_loadaddr = len(fip1_bin)
-        fip_bin = self.insert_param1(fip_bin, "PARAM2_LOADADDR", pack("<I", param2_loadaddr))
-
-        # Add an empty PARAM2
-        fip_bin += b"\0" * PARAM2_SIZE
-
-        # Pack body
-        fip_bin = self.pack_ddr_param(fip_bin)
-
-        if len(self.body2["BLCP_2ND"].content):
-            runaddr = self.param2["BLCP_2ND_RUNADDR"].toint()
-            if not runaddr:
-                runaddr = int(args.BLCP_2ND_RUNADDR)
-            fip_bin = self.pack_blcp_2nd(fip_bin, runaddr)
-
-        if len(self.body2["MONITOR"].content):
-            runaddr = self.param2["MONITOR_RUNADDR"].toint()
-            if not runaddr:
-                runaddr = int(args.MONITOR_RUNADDR)
-            fip_bin = self.pack_monitor(fip_bin, runaddr)
-
-        if len(self.body2["LOADER_2ND"].content):
-            fip_bin = self.pack_loader_2nd(fip_bin)
-
-        # Pack param2_bin
-        param2_bin = b"".join((entry.content for entry in self.param2.values()))
-        self.param2["PARAM2_CKSUM"].content = self.image_crc(param2_bin[self.param2["PARAM2_CKSUM"].end :])
-        param2_bin = b"".join((entry.content for entry in self.param2.values()))  # update cksum
-
-        logging.debug("len(param2_bin) is %d", len(param2_bin))
-        assert len(param2_bin) == PARAM2_SIZE
-
-        fip_bin[param2_loadaddr : param2_loadaddr + PARAM2_SIZE] = param2_bin
-
-        return fip_bin
-
-    def make(self, args=None):
-        fip_bin = self.make_fip1()
-        if len(self.body2["DDR_PARAM"].content):
-            fip_bin = self.append_fip2(fip_bin, args)
-
-        logging.info("generated fip_bin is %d bytes", len(fip_bin))
-
-        if getattr(self, "rest_fip", None):
-            logging.error("the rest of fip is not used: %#x bytes ", len(self.rest_fip))
-
-        return fip_bin
-
-
-METHODS = {
-    "NOR_INFO": FIP.add_nor_info,
-    "NAND_INFO": FIP.add_nand_info,
-    "CHIP_CONF": FIP.add_chip_conf,
-    "BLCP": FIP.add_blcp,
-    "BL2": FIP.add_bl2,
-    "DDR_PARAM": FIP.add_ddr_param,
-    "BLCP_2ND": FIP.add_blcp_2nd,
-    "MONITOR": FIP.add_monitor,
-    "LOADER_2ND": FIP.add_loader_2nd,
-}
-
-
-def generate_fip(args):
-    logging.debug("generate_fip:")
-    fip = FIP()
-
-    if args.OLD_FIP:
-        fip.read_fip(args.OLD_FIP)
-
-    for m, f in METHODS.items():
-        if getattr(args, m):
-            f(fip, args)
-
-    fip_bin = fip.make(args)
-    fip.print_fip_params()
-
-    if args.output:
-        with open(args.output, "wb") as fp:
-            fp.write(fip_bin)
-
-
-def parse_args():
-    parser = argparse.ArgumentParser(description="FIP tools")
-
-    parser.add_argument(
-        "-v",
-        "--verbose",
-        help="Increase output verbosity",
-        action="store_const",
-        const=logging.DEBUG,
-        default=logging.INFO,
-    )
-
-    subparsers = parser.add_subparsers(dest="subcmd", help="Sub-command help")
-    pr_gen = subparsers.add_parser("genfip", help="Generate keys")
-
-    for name in list(METHODS):
-        if name in ["NOR_INFO", "NAND_INFO"]:
-            pr_gen.add_argument("--" + name, type=bytes.fromhex)
-        else:
-            pr_gen.add_argument("--" + name, dest=name, type=str, help="Add %s into FIP" % name)
-
-    def auto_int(x):
-        return int(x, 0)
-
-    pr_gen.add_argument("--BLCP_IMG_RUNADDR", type=auto_int)
-    pr_gen.add_argument("--BLCP_PARAM_LOADADDR", type=auto_int)
-
-    pr_gen.add_argument("--BLCP_2ND_RUNADDR", type=auto_int)
-
-    pr_gen.add_argument("--MONITOR_RUNADDR", type=auto_int)
-
-    pr_gen.add_argument("--compress", choices=["lzma", "lz4", ""])
-
-    pr_gen.add_argument("--OLD_FIP", type=str)
-    pr_gen.add_argument("--BLOCK_SIZE", type=auto_int)
-    pr_gen.add_argument("--BL2_FILL", type=auto_int)
-
-    pr_gen.add_argument("output", type=str, help="Output filename")
-
-    pr_gen.set_defaults(func=generate_fip)
-
-    if argcomplete:
-        argcomplete.autocomplete(parser)
-
-    args = parser.parse_args()
-    init_logging(stdout_level=args.verbose)
-    logging.info("PROG: %s", parser.prog)
-
-    if not args.subcmd:
-        parser.print_help()
-        raise SystemExit(1)
-
-    for a, v in sorted(vars(args).items()):
-        logging.debug("  %s=%r", a, v)
-
-    return args
-
-
-def main():
-    args = parse_args()
-    args.func(args)
-
-
-def init_logging(log_file=None, file_level="DEBUG", stdout_level="WARNING"):
-    root_logger = logging.getLogger()
-    root_logger.setLevel(logging.NOTSET)
-
-    fmt = "%(asctime)s %(levelname)8s:%(name)s:%(message)s"
-
-    if log_file is not None:
-        file_handler = logging.FileHandler(log_file, encoding="utf-8")
-        file_handler.setFormatter(logging.Formatter(fmt))
-        file_handler.setLevel(file_level)
-        root_logger.addHandler(file_handler)
-
-    if coloredlogs:
-        os.environ["COLOREDLOGS_DATE_FORMAT"] = "%H:%M:%S"
-
-        field_styles = {
-            "asctime": {"color": "green"},
-            "hostname": {"color": "magenta"},
-            "levelname": {"color": "black", "bold": True},
-            "name": {"color": "blue"},
-            "programname": {"color": "cyan"},
-        }
-
-        level_styles = coloredlogs.DEFAULT_LEVEL_STYLES
-        level_styles["debug"]["color"] = "cyan"
-
-        coloredlogs.install(
-            level=stdout_level,
-            fmt=fmt,
-            field_styles=field_styles,
-            level_styles=level_styles,
-            milliseconds=True,
-        )
-
-
-if __name__ == "__main__":
-    main()
diff --git a/firmware/plat/cv180x/fiptool.py b/firmware/plat/cv180x/fiptool.py
new file mode 120000
index 0000000..7cfe401
--- /dev/null
+++ b/firmware/plat/cv180x/fiptool.py
@@ -0,0 +1 @@
+../cv181x/fiptool.py
\ No newline at end of file
diff --git a/firmware/plat/cv180x/include/bl2.h b/firmware/plat/cv180x/include/bl2.h
deleted file mode 100644
index 2458acf..0000000
--- a/firmware/plat/cv180x/include/bl2.h
+++ /dev/null
@@ -1,45 +0,0 @@
-#ifndef __BL2_H__
-#define __BL2_H__
-
-#define BLOCK_SIZE 512
-
-struct fip_param2 {
-	uint64_t magic1;
-	uint32_t param2_cksum;
-	uint32_t reserved1;
-	uint32_t ddr_param_cksum;
-	uint32_t ddr_param_loadaddr;
-	uint32_t ddr_param_size;
-	uint32_t ddr_param_reserved;
-	uint32_t blcp_2nd_cksum;
-	uint32_t blcp_2nd_loadaddr;
-	uint32_t blcp_2nd_size;
-	uint32_t blcp_2nd_runaddr;
-	uint32_t monitor_cksum;
-	uint32_t monitor_loadaddr;
-	uint32_t monitor_size;
-	uint32_t monitor_runaddr;
-	uint32_t loader_2nd_reserved0;
-	uint32_t loader_2nd_loadaddr;
-	uint32_t loader_2nd_reserved1;
-	uint32_t loader_2nd_reserved2;
-	uint8_t reserved4[4016];
-} __packed;
-
-struct loader_2nd_header {
-	uint32_t jump0;
-	uint32_t magic;
-	uint32_t cksum;
-	uint32_t size;
-	uint64_t runaddr;
-	uint32_t reserved1;
-	uint32_t reserved2;
-} __packed;
-
-#define PARAM2_SIZE 0x1000
-
-#define LOADER_2ND_MAGIC_RAW 0x20203342 // "B3  "
-#define LOADER_2ND_MAGIC_LZMA 0x414d3342 // "B3MA"
-#define LOADER_2ND_MAGIC_LZ4 0x345a3342 // "B3Z4"
-
-#endif /* __BL2_H__ */
diff --git a/firmware/plat/cv180x/include/bl2.h b/firmware/plat/cv180x/include/bl2.h
new file mode 120000
index 0000000..80a9ef4
--- /dev/null
+++ b/firmware/plat/cv180x/include/bl2.h
@@ -0,0 +1 @@
+../../cv181x/include/bl2.h
\ No newline at end of file
diff --git a/firmware/plat/cv180x/include/cvi_board_memmap.h b/firmware/plat/cv180x/include/cvi_board_memmap.h
deleted file mode 100644
index a9200f0..0000000
--- a/firmware/plat/cv180x/include/cvi_board_memmap.h
+++ /dev/null
@@ -1,74 +0,0 @@
-#ifndef __BOARD_MMAP__b2c10de7__
-#define __BOARD_MMAP__b2c10de7__
-
-#ifdef CVI_BUILDROOT_64MB
-
-#define CONFIG_SYS_TEXT_BASE 0x80200000  /* offset 2.0MiB */
-#define CVIMMAP_ATF_SIZE 0x80000  /* 512.0KiB */
-#define CVIMMAP_BOOTLOGO_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_BOOTLOGO_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_CONFIG_SYS_INIT_SP_ADDR 0x82300000  /* offset 35.0MiB */
-#define CVIMMAP_CVI_UPDATE_HEADER_ADDR 0x813ffc00  /* offset 19.9990234375MiB */
-#define CVIMMAP_CVI_UPDATE_HEADER_SIZE 0x400  /* 1.0KiB */
-#define CVIMMAP_DRAM_BASE 0x80000000  /* offset 0.0KiB */
-#define CVIMMAP_DRAM_SIZE 0x4000000  /* 64.0MiB */
-#define CVIMMAP_FREERTOS_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_FREERTOS_RESERVED_ION_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_FREERTOS_SIZE 0xc0000  /* 768.0KiB */
-#define CVIMMAP_FSBL_C906L_START_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_FSBL_UNZIP_ADDR 0x81400000  /* offset 20.0MiB */
-#define CVIMMAP_FSBL_UNZIP_SIZE 0xf00000  /* 15.0MiB */
-#define CVIMMAP_H26X_BITSTREAM_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_H26X_BITSTREAM_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_H26X_ENC_BUFF_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_H26X_ENC_BUFF_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_ION_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_ION_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_ISP_MEM_BASE_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_ISP_MEM_BASE_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_KERNEL_MEMORY_ADDR 0x80000000  /* offset 0.0KiB */
-#define CVIMMAP_KERNEL_MEMORY_SIZE 0x3f40000  /* 63.25MiB */
-#define CVIMMAP_MONITOR_ADDR 0x80000000  /* offset 0.0KiB */
-#define CVIMMAP_OPENSBI_FDT_ADDR 0x80080000  /* offset 512.0KiB */
-#define CVIMMAP_OPENSBI_SIZE 0x80000  /* 512.0KiB */
-#define CVIMMAP_UIMAG_ADDR 0x81400000  /* offset 20.0MiB */
-#define CVIMMAP_UIMAG_SIZE 0xf00000  /* 15.0MiB */
-
-#endif
-
-#ifdef CVI_BUILDROOT_ION
-
-#define CONFIG_SYS_TEXT_BASE 0x80200000  /* offset 2.0MiB */
-#define CVIMMAP_ATF_SIZE 0x80000  /* 512.0KiB */
-#define CVIMMAP_BOOTLOGO_ADDR 0x82473000  /* offset 36.44921875MiB */
-#define CVIMMAP_BOOTLOGO_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_CONFIG_SYS_INIT_SP_ADDR 0x82300000  /* offset 35.0MiB */
-#define CVIMMAP_CVI_UPDATE_HEADER_ADDR 0x813ffc00  /* offset 19.9990234375MiB */
-#define CVIMMAP_CVI_UPDATE_HEADER_SIZE 0x400  /* 1.0KiB */
-#define CVIMMAP_DRAM_BASE 0x80000000  /* offset 0.0KiB */
-#define CVIMMAP_DRAM_SIZE 0x4000000  /* 64.0MiB */
-#define CVIMMAP_FREERTOS_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_FREERTOS_RESERVED_ION_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_FREERTOS_SIZE 0xc0000  /* 768.0KiB */
-#define CVIMMAP_FSBL_C906L_START_ADDR 0x83f40000  /* offset 63.25MiB */
-#define CVIMMAP_FSBL_UNZIP_ADDR 0x81400000  /* offset 20.0MiB */
-#define CVIMMAP_FSBL_UNZIP_SIZE 0xf00000  /* 15.0MiB */
-#define CVIMMAP_H26X_BITSTREAM_ADDR 0x82473000  /* offset 36.44921875MiB */
-#define CVIMMAP_H26X_BITSTREAM_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_H26X_ENC_BUFF_ADDR 0x82473000  /* offset 36.44921875MiB */
-#define CVIMMAP_H26X_ENC_BUFF_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_ION_ADDR 0x82473000  /* offset 36.44921875MiB */
-#define CVIMMAP_ION_SIZE 0x1acd000  /* 26.80078125MiB */
-#define CVIMMAP_ISP_MEM_BASE_ADDR 0x82473000  /* offset 36.44921875MiB */
-#define CVIMMAP_ISP_MEM_BASE_SIZE 0x0  /* 0.0KiB */
-#define CVIMMAP_KERNEL_MEMORY_ADDR 0x80000000  /* offset 0.0KiB */
-#define CVIMMAP_KERNEL_MEMORY_SIZE 0x3f40000  /* 63.25MiB */
-#define CVIMMAP_MONITOR_ADDR 0x80000000  /* offset 0.0KiB */
-#define CVIMMAP_OPENSBI_FDT_ADDR 0x80080000  /* offset 512.0KiB */
-#define CVIMMAP_OPENSBI_SIZE 0x80000  /* 512.0KiB */
-#define CVIMMAP_UIMAG_ADDR 0x81400000  /* offset 20.0MiB */
-#define CVIMMAP_UIMAG_SIZE 0xf00000  /* 15.0MiB */
-
-#endif
-
-#endif /* __BOARD_MMAP__b2c10de7__ */
diff --git a/firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr2_1333_init.h b/firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr2_1333_init.h
new file mode 100644
index 0000000..11b60df
--- /dev/null
+++ b/firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr2_1333_init.h
@@ -0,0 +1,1156 @@
+#ifndef __DDR2_PI_PHY_H__
+#define __DDR2_PI_PHY_H__
+
+extern uint32_t ddr_data_rate;
+// $Module: reg_cv_phy_param_ddr2_1333 $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: KC TSAI $
+// $Date: Fri, 11 Mar 2022 03:31:19 PM $
+//
+
+#define  DDR2_PHY_REG_0_DATA  0b00000011000000100000000100000000
+	// param_phyd_swap_ca0:[4:0]=0b00000
+	// param_phyd_swap_ca1:[12:8]=0b00001
+	// param_phyd_swap_ca2:[20:16]=0b00010
+	// param_phyd_swap_ca3:[28:24]=0b00011
+#define  DDR2_PHY_REG_1_DATA  0b00000111000001100000010100000100
+	// param_phyd_swap_ca4:[4:0]=0b00100
+	// param_phyd_swap_ca5:[12:8]=0b00101
+	// param_phyd_swap_ca6:[20:16]=0b00110
+	// param_phyd_swap_ca7:[28:24]=0b00111
+#define  DDR2_PHY_REG_2_DATA  0b00001011000010100000100100001000
+	// param_phyd_swap_ca8:[4:0]=0b01000
+	// param_phyd_swap_ca9:[12:8]=0b01001
+	// param_phyd_swap_ca10:[20:16]=0b01010
+	// param_phyd_swap_ca11:[28:24]=0b01011
+#define  DDR2_PHY_REG_3_DATA  0b00001111000011100000110100001100
+	// param_phyd_swap_ca12:[4:0]=0b01100
+	// param_phyd_swap_ca13:[12:8]=0b01101
+	// param_phyd_swap_ca14:[20:16]=0b01110
+	// param_phyd_swap_ca15:[28:24]=0b01111
+#define  DDR2_PHY_REG_4_DATA  0b00010011000100100001000100010000
+	// param_phyd_swap_ca16:[4:0]=0b10000
+	// param_phyd_swap_ca17:[12:8]=0b10001
+	// param_phyd_swap_ca18:[20:16]=0b10010
+	// param_phyd_swap_ca19:[28:24]=0b10011
+#define  DDR2_PHY_REG_5_DATA  0b00000000000101100001010100010100
+	// param_phyd_swap_ca20:[4:0]=0b10100
+	// param_phyd_swap_ca21:[12:8]=0b10101
+	// param_phyd_swap_ca22:[20:16]=0b10110
+#define  DDR2_PHY_REG_6_DATA  0b00000000000000000000000000000000
+	// param_phyd_swap_cke0:[0:0]=0b0
+	// param_phyd_swap_cs0:[4:4]=0b0
+#define  DDR2_PHY_REG_7_DATA  0b00000000000000000000000100000000
+	// param_phyd_data_byte_swap_slice0:[1:0]=0b00
+	// param_phyd_data_byte_swap_slice1:[9:8]=0b01
+#define  DDR2_PHY_REG_8_DATA  0b01110110010101000011001000010000
+	// param_phyd_swap_byte0_dq0_mux:[3:0]=0b0000
+	// param_phyd_swap_byte0_dq1_mux:[7:4]=0b0001
+	// param_phyd_swap_byte0_dq2_mux:[11:8]=0b0010
+	// param_phyd_swap_byte0_dq3_mux:[15:12]=0b0011
+	// param_phyd_swap_byte0_dq4_mux:[19:16]=0b0100
+	// param_phyd_swap_byte0_dq5_mux:[23:20]=0b0101
+	// param_phyd_swap_byte0_dq6_mux:[27:24]=0b0110
+	// param_phyd_swap_byte0_dq7_mux:[31:28]=0b0111
+#define  DDR2_PHY_REG_9_DATA  0b00000000000000000000000000001000
+	// param_phyd_swap_byte0_dm_mux:[3:0]=0b1000
+#define  DDR2_PHY_REG_10_DATA  0b01110110010101000011001000010000
+	// param_phyd_swap_byte1_dq0_mux:[3:0]=0b0000
+	// param_phyd_swap_byte1_dq1_mux:[7:4]=0b0001
+	// param_phyd_swap_byte1_dq2_mux:[11:8]=0b0010
+	// param_phyd_swap_byte1_dq3_mux:[15:12]=0b0011
+	// param_phyd_swap_byte1_dq4_mux:[19:16]=0b0100
+	// param_phyd_swap_byte1_dq5_mux:[23:20]=0b0101
+	// param_phyd_swap_byte1_dq6_mux:[27:24]=0b0110
+	// param_phyd_swap_byte1_dq7_mux:[31:28]=0b0111
+#define  DDR2_PHY_REG_11_DATA  0b00000000000000000000000000001000
+	// param_phyd_swap_byte1_dm_mux:[3:0]=0b1000
+#define  DDR2_PHY_REG_16_DATA  0b00000000000000000000000000000000
+	// param_phyd_dll_rx_sw_mode:[0:0]=0b0
+	// param_phyd_dll_rx_start_cal:[1:1]=0b0
+	// param_phyd_dll_rx_cntr_mode:[2:2]=0b0
+	// param_phyd_dll_rx_hwrst_time:[3:3]=0b0
+	// param_phyd_dll_tx_sw_mode:[16:16]=0b0
+	// param_phyd_dll_tx_start_cal:[17:17]=0b0
+	// param_phyd_dll_tx_cntr_mode:[18:18]=0b0
+	// param_phyd_dll_tx_hwrst_time:[19:19]=0b0
+#define  DDR2_PHY_REG_17_DATA  0b00000000011111110000000000001101
+	// param_phyd_dll_slave_delay_en:[0:0]=0b1
+	// param_phyd_dll_rw_en:[1:1]=0b0
+	// param_phyd_dll_avg_mode:[2:2]=0b1
+	// param_phyd_dll_upd_wait:[6:3]=0b0001
+	// param_phyd_dll_sw_clr:[7:7]=0b0
+	// param_phyd_dll_sw_code_mode:[8:8]=0b0
+	// param_phyd_dll_sw_code:[23:16]=0b01111111
+#define  DDR2_PHY_REG_18_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_tx_clk_tx_dline_code_clkn0:[6:0]=0b0000000
+	// param_phya_reg_tx_clk_tx_dline_code_clkp0:[14:8]=0b0000000
+#define  DDR2_PHY_REG_19_DATA  0b00000000000000000000000000010000
+	// param_phya_reg_sel_ddr4_mode:[0:0]=0b0
+	// param_phya_reg_sel_lpddr3_mode:[1:1]=0b0
+	// param_phya_reg_sel_lpddr4_mode:[2:2]=0b0
+	// param_phya_reg_sel_ddr3_mode:[3:3]=0b0
+	// param_phya_reg_sel_ddr2_mode:[4:4]=0b1
+#define  DDR2_PHY_REG_20_DATA  0b00000000000000000000000000000100
+	// param_phyd_dram_class:[3:0]=0b0100
+#define  DDR2_PHY_REG_21_DATA  0b00001100000000000000101100000000
+	// param_phyd_wrlvl_start_delay_code:[6:0]=0b0000000
+	// param_phyd_wrlvl_start_shift_code:[13:8]=0b001011
+	// param_phyd_wrlvl_end_delay_code:[22:16]=0b0000000
+	// param_phyd_wrlvl_end_shift_code:[29:24]=0b001100
+#define  DDR2_PHY_REG_22_DATA  0b00001001000101100000000001001111
+	// param_phyd_wrlvl_capture_cnt:[3:0]=0b1111
+	// param_phyd_wrlvl_dly_step:[7:4]=0b0100
+	// param_phyd_wrlvl_disable:[11:8]=0b0000
+	// param_phyd_wrlvl_resp_wait_cnt:[21:16]=0b010110
+	// param_phyd_oenz_lead_cnt:[26:23]=0b0010
+	// param_phyd_wrlvl_mode:[27:27]=0b1
+#define  DDR2_PHY_REG_23_DATA  0b00000000000000000000000000000000
+	// param_phyd_wrlvl_sw:[0:0]=0b0
+	// param_phyd_wrlvl_sw_upd_req:[1:1]=0b0
+	// param_phyd_wrlvl_sw_resp:[2:2]=0b0
+	// param_phyd_wrlvl_data_mask:[23:16]=0b00000000
+#define  DDR2_PHY_REG_24_DATA  0b00000100000000000000001101110000
+	// param_phyd_pigtlvl_back_step:[7:0]=0b01110000
+	// param_phyd_pigtlvl_capture_cnt:[11:8]=0b0011
+	// param_phyd_pigtlvl_disable:[19:16]=0b0000
+	// param_phyd_pigtlvl_dly_step:[27:24]=0b0100
+#define  DDR2_PHY_REG_25_DATA  0b00001110000000000000100101000000
+	// param_phyd_pigtlvl_start_delay_code:[6:0]=0b1000000
+	// param_phyd_pigtlvl_start_shift_code:[13:8]=0b001001
+	// param_phyd_pigtlvl_end_delay_code:[22:16]=0b0000000
+	// param_phyd_pigtlvl_end_shift_code:[29:24]=0b001110
+#define  DDR2_PHY_REG_26_DATA  0b00000000100000000000000000000000
+	// param_phyd_pigtlvl_resp_wait_cnt:[5:0]=0b000000
+	// param_phyd_pigtlvl_sw:[8:8]=0b0
+	// param_phyd_pigtlvl_sw_resp:[13:12]=0b00
+	// param_phyd_pigtlvl_sw_upd_req:[16:16]=0b0
+	// param_phyd_rx_en_lead_cnt:[23:20]=0b1000
+#define  DDR2_PHY_REG_28_DATA  0b00000000000000000000000100001000
+	// param_phyd_rgtrack_threshold:[4:0]=0b01000
+	// param_phyd_rgtrack_dly_step:[11:8]=0b0001
+	// param_phyd_rgtrack_disable:[19:16]=0b0000
+#define  DDR2_PHY_REG_29_DATA  0b00000000000001110010000000000000
+	// param_phyd_zqcal_wait_count:[3:0]=0b0000
+	// param_phyd_zqcal_cycle_count:[15:8]=0b00100000
+	// param_phyd_zqcal_hw_mode:[18:16]=0b111
+#define  DDR2_PHY_REG_32_DATA  0b00011111000000001110000000000000
+	// param_phyd_pirdlvl_dlie_code_start:[7:0]=0b00000000
+	// param_phyd_pirdlvl_dlie_code_end:[15:8]=0b11100000
+	// param_phyd_pirdlvl_deskew_start:[22:16]=0b0000000
+	// param_phyd_pirdlvl_deskew_end:[30:24]=0b0011111
+#define  DDR2_PHY_REG_33_DATA  0b00000001000010010001000000001111
+	// param_phyd_pirdlvl_trig_lvl_start:[4:0]=0b01111
+	// param_phyd_pirdlvl_trig_lvl_end:[12:8]=0b10000
+	// param_phyd_pirdlvl_rdvld_start:[20:16]=0b01001
+	// param_phyd_pirdlvl_rdvld_end:[28:24]=0b00001
+#define  DDR2_PHY_REG_34_DATA  0b00001010000000010000000100010100
+	// param_phyd_pirdlvl_dly_step:[3:0]=0b0100
+	// param_phyd_pirdlvl_ds_dly_step:[7:4]=0b0001
+	// param_phyd_pirdlvl_vref_step:[11:8]=0b0001
+	// param_phyd_pirdlvl_disable:[15:12]=0b0000
+	// param_phyd_pirdlvl_resp_wait_cnt:[21:16]=0b000001
+	// param_phyd_pirdlvl_vref_wait_cnt:[31:24]=0b00001010
+#define  DDR2_PHY_REG_35_DATA  0b10101010101010100000000010001111
+	// param_phyd_pirdlvl_rx_prebit_deskew_en:[0:0]=0b1
+	// param_phyd_pirdlvl_rx_init_deskew_en:[1:1]=0b1
+	// param_phyd_pirdlvl_vref_training_en:[2:2]=0b1
+	// param_phyd_pirdlvl_rdvld_training_en:[3:3]=0b1
+	// param_phyd_pirdlvl_capture_cnt:[7:4]=0b1000
+	// param_phyd_pirdlvl_MR1520_BYTE:[15:8]=0b00000000
+	// param_phyd_pirdlvl_MR3240:[31:16]=0b1010101010101010
+#define  DDR2_PHY_REG_36_DATA  0b00000000000000000011100000000000
+	// param_phyd_pirdlvl_data_mask:[8:0]=0b000000000
+	// param_phyd_pirdlvl_sw:[9:9]=0b0
+	// param_phyd_pirdlvl_sw_upd_req:[10:10]=0b0
+	// param_phyd_pirdlvl_sw_resp:[12:11]=0b11
+	// param_phyd_pirdlvl_trig_lvl_dqs_follow_dq:[13:13]=0b1
+#define  DDR2_PHY_REG_37_DATA  0b00000000000000000000100000000001
+	// param_phyd_pirdlvl_rdvld_offset:[3:0]=0b0001
+	// param_phyd_pirdlvl_found_cnt_limite:[15:8]=0b00001000
+#define  DDR2_PHY_REG_40_DATA  0b00000111010000000000010101000000
+	// param_phyd_piwdqlvl_start_delay_code:[6:0]=0b1000000
+	// param_phyd_piwdqlvl_start_shift_code:[13:8]=0b000101
+	// param_phyd_piwdqlvl_end_delay_code:[22:16]=0b1000000
+	// param_phyd_piwdqlvl_end_shift_code:[29:24]=0b000111
+#define  DDR2_PHY_REG_41_DATA  0b00000001010000100000010100000100
+	// param_phyd_piwdqlvl_tx_vref_start:[4:0]=0b00100
+	// param_phyd_piwdqlvl_tx_vref_end:[12:8]=0b00101
+	// param_phyd_piwdqlvl_capture_cnt:[19:16]=0b0010
+	// param_phyd_piwdqlvl_dly_step:[23:20]=0b0100
+	// param_phyd_piwdqlvl_vref_step:[27:24]=0b0001
+	// param_phyd_piwdqlvl_disable:[31:28]=0b0000
+#define  DDR2_PHY_REG_42_DATA  0b00000000010101010000000000001010
+	// param_phyd_piwdqlvl_vref_wait_cnt:[7:0]=0b00001010
+	// param_phyd_piwdqlvl_tx_vref_training_en:[8:8]=0b0
+	// param_phyd_piwdqlvl_byte_invert_0:[23:16]=0b01010101
+#define  DDR2_PHY_REG_43_DATA  0b00000000010101010011110001011010
+	// param_phyd_piwdqlvl_dq_pattern_0:[15:0]=0b0011110001011010
+	// param_phyd_piwdqlvl_byte_invert_1:[23:16]=0b01010101
+#define  DDR2_PHY_REG_44_DATA  0b00000000101010101010010111000011
+	// param_phyd_piwdqlvl_dq_pattern_1:[15:0]=0b1010010111000011
+	// param_phyd_piwdqlvl_byte_invert_2:[23:16]=0b10101010
+#define  DDR2_PHY_REG_45_DATA  0b00000000101010101111000011110000
+	// param_phyd_piwdqlvl_dq_pattern_2:[15:0]=0b1111000011110000
+	// param_phyd_piwdqlvl_byte_invert_3:[23:16]=0b10101010
+#define  DDR2_PHY_REG_46_DATA  0b00011110000000000000111100001111
+	// param_phyd_piwdqlvl_dq_pattern_3:[15:0]=0b0000111100001111
+	// param_phyd_piwdqlvl_data_mask:[24:16]=0b000000000
+	// param_phyd_piwdqlvl_pattern_sel:[28:25]=0b1111
+#define  DDR2_PHY_REG_47_DATA  0b00000000000010000011111000010011
+	// param_phyd_piwdqlvl_tdfi_phy_wrdata:[2:0]=0b011
+	// param_phyd_piwdqlvl_oenz_lead_cnt:[6:3]=0b0010
+	// param_phyd_piwdqlvl_sw:[7:7]=0b0
+	// param_phyd_piwdqlvl_sw_upd_req:[8:8]=0b0
+	// param_phyd_piwdqlvl_sw_resp:[10:9]=0b11
+	// param_phyd_piwdqlvl_sw_result:[11:11]=0b1
+	// param_phyd_piwdqlvl_dq_mode:[12:12]=0b1
+	// param_phyd_piwdqlvl_dm_mode:[13:13]=0b1
+	// param_phyd_piwdqlvl_found_cnt_limite:[23:16]=0b00001000
+#define  DDR2_PHY_REG_60_DATA  0b00000000000000000000000000000000
+	// param_phyd_patch_revision:[31:0]=0b00000000000000000000000000000000
+#define  DDR2_PHY_REG_61_DATA  0b00000000000000110000000000110011
+	// param_phyd_ca_shift_gating_en:[0:0]=0b1
+	// param_phyd_cs_shift_gating_en:[1:1]=0b1
+	// param_phyd_cke_shift_gating_en:[2:2]=0b0
+	// param_phyd_resetz_shift_gating_en:[3:3]=0b0
+	// param_phyd_tx_byte0_shift_gating_en:[4:4]=0b1
+	// param_phyd_tx_byte1_shift_gating_en:[5:5]=0b1
+	// param_phyd_rx_byte0_shift_gating_en:[16:16]=0b1
+	// param_phyd_rx_byte1_shift_gating_en:[17:17]=0b1
+#define  DDR2_PHY_REG_62_DATA  0b00000000001000010000000000101100
+	// param_phyd_lb_lfsr_seed0:[8:0]=0b000101100
+	// param_phyd_lb_lfsr_seed1:[24:16]=0b000100001
+#define  DDR2_PHY_REG_63_DATA  0b00000000001101110000000000010110
+	// param_phyd_lb_lfsr_seed2:[8:0]=0b000010110
+	// param_phyd_lb_lfsr_seed3:[24:16]=0b000110111
+#define  DDR2_PHY_REG_64_DATA  0b00000100000000000000000000000000
+	// param_phyd_lb_dq_en:[0:0]=0b0
+	// param_phyd_lb_dq_go:[1:1]=0b0
+	// param_phyd_lb_sw_en:[2:2]=0b0
+	// param_phyd_lb_sw_rx_en:[3:3]=0b0
+	// param_phyd_lb_sw_rx_mask:[4:4]=0b0
+	// param_phyd_lb_sw_odt_en:[5:5]=0b0
+	// param_phyd_lb_sw_ca_clkpattern:[6:6]=0b0
+	// param_phyd_lb_sync_len:[31:16]=0b0000010000000000
+#define  DDR2_PHY_REG_65_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_dout0:[8:0]=0b000000000
+	// param_phyd_lb_sw_dout1:[24:16]=0b000000000
+#define  DDR2_PHY_REG_67_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_oenz_dout0:[0:0]=0b0
+	// param_phyd_lb_sw_oenz_dout1:[1:1]=0b0
+	// param_phyd_lb_sw_dqsn0:[4:4]=0b0
+	// param_phyd_lb_sw_dqsn1:[5:5]=0b0
+	// param_phyd_lb_sw_dqsp0:[8:8]=0b0
+	// param_phyd_lb_sw_dqsp1:[9:9]=0b0
+	// param_phyd_lb_sw_oenz_dqs_dout0:[12:12]=0b0
+	// param_phyd_lb_sw_oenz_dqs_dout1:[13:13]=0b0
+#define  DDR2_PHY_REG_68_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_ca_dout:[22:0]=0b00000000000000000000000
+#define  DDR2_PHY_REG_69_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_clkn0_dout:[0:0]=0b0
+	// param_phyd_lb_sw_clkp0_dout:[4:4]=0b0
+	// param_phyd_lb_sw_cke0_dout:[8:8]=0b0
+	// param_phyd_lb_sw_resetz_dout:[12:12]=0b0
+	// param_phyd_lb_sw_csb0_dout:[16:16]=0b0
+#define  DDR2_PHY_REG_70_DATA  0b00000000000000000000000000000000
+	// param_phyd_clkctrl_init_complete:[0:0]=0b0
+#define  DDR2_PHY_REG_71_DATA  0b00000000000000000110101000010000
+	// param_phyd_reg_resetz_dqs_rd_en:[4:4]=0b1
+	// param_phyd_rx_upd_tx_sel:[9:8]=0b10
+	// param_phyd_tx_upd_rx_sel:[11:10]=0b10
+	// param_phyd_rx_en_ext_win:[15:12]=0b0110
+	// param_phyd_fifo_rst_sel:[18:16]=0b000
+	// param_phyd_fifo_sw_rst:[20:20]=0b0
+#define  DDR2_PHY_REG_72_DATA  0b00000000000000000000000000000000
+	// param_phyd_phy_int_ack:[31:0]=0b00000000000000000000000000000000
+#define  DDR2_PHY_REG_73_DATA  0b11111111111111111111111011110111
+	// param_phyd_phy_int_mask:[31:0]=0b11111111111111111111111011110111
+#define  DDR2_PHY_REG_74_DATA  0b00000000000000000000000000011111
+	// param_phyd_calvl_rst_n:[0:0]=0b1
+	// param_phyd_pigtlvl_rst_n:[1:1]=0b1
+	// param_phyd_pirdlvl_rst_n:[2:2]=0b1
+	// param_phyd_piwdqlvl_rst_n:[3:3]=0b1
+	// param_phyd_wrlvl_rst_n:[4:4]=0b1
+#define  DDR2_PHY_REG_75_DATA  0b00000000000000000000000000000001
+	// param_phyd_clk0_pol:[0:0]=0b1
+#define  DDR2_PHY_REG_76_DATA  0b00000000000000000000000100000001
+	// param_phyd_tx_ca_oenz:[0:0]=0b1
+	// param_phyd_tx_ca_clk0_oenz:[8:8]=0b1
+#define  DDR2_PHY_REG_77_DATA  0b00000000000000000000000100000000
+	// param_phya_reg_en_test:[0:0]=0b0
+	// param_phya_reg_tx_ca_test_en:[1:1]=0b0
+	// param_phya_reg_tx_ca_en_ca_loop_back:[2:2]=0b0
+	// param_phya_reg_tx_sel_4bit_mode_tx:[8:8]=0b1
+	// param_phya_reg_tx_gpio_in:[16:16]=0b0
+#define  DDR2_PHY_REG_78_DATA  0b00000000000000000000000000010100
+	// param_phya_reg_rx_en_ca_train_mode:[0:0]=0b0
+	// param_phya_reg_rx_en_pream_train_mode:[1:1]=0b0
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode:[2:2]=0b1
+	// param_phya_reg_rx_en_rec_offset:[3:3]=0b0
+	// param_phya_reg_rx_sel_4bit_mode_rx:[4:4]=0b1
+#define  DDR2_PHY_REG_80_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_rx_ddrdll_enautok:[0:0]=0b0
+	// param_phya_reg_rx_ddrdll_rstb:[1:1]=0b0
+	// param_phya_reg_rx_ddrdll_selckout:[5:4]=0b00
+	// param_phya_reg_rx_ddrdll_test:[7:6]=0b00
+	// param_phya_reg_rx_ddrdll_sel:[15:8]=0b00000000
+	// param_phya_reg_tx_ddrdll_enautok:[16:16]=0b0
+	// param_phya_reg_tx_ddrdll_rstb:[17:17]=0b0
+	// param_phya_reg_tx_ddrdll_selckout:[21:20]=0b00
+	// param_phya_reg_tx_ddrdll_test:[23:22]=0b00
+	// param_phya_reg_tx_ddrdll_sel:[31:24]=0b00000000
+#define  DDR2_PHY_REG_81_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_tx_zq_cmp_en:[0:0]=0b0
+	// param_phya_reg_tx_zq_cmp_offset_cal_en:[1:1]=0b0
+	// param_phya_reg_tx_zq_ph_en:[2:2]=0b0
+	// param_phya_reg_tx_zq_pl_en:[3:3]=0b0
+	// param_phya_reg_tx_zq_step2_en:[4:4]=0b0
+	// param_phya_reg_tx_zq_cmp_offset:[12:8]=0b00000
+	// param_phya_reg_tx_zq_sel_vref:[20:16]=0b00000
+#define  DDR2_PHY_REG_82_DATA  0b00000000000000000000100000001000
+	// param_phya_reg_tx_zq_golden_drvn:[4:0]=0b01000
+	// param_phya_reg_tx_zq_golden_drvp:[12:8]=0b01000
+	// param_phya_reg_tx_zq_drvn:[20:16]=0b00000
+	// param_phya_reg_tx_zq_drvp:[28:24]=0b00000
+#define  DDR2_PHY_REG_83_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_tx_zq_en_test_aux:[0:0]=0b0
+	// param_phya_reg_tx_zq_en_test_mux:[1:1]=0b0
+	// param_phya_reg_sel_zq_high_swing:[2:2]=0b0
+	// param_phya_reg_zq_sel_test_out0:[7:4]=0b0000
+	// param_phya_reg_zq_sel_test_out1:[11:8]=0b0000
+	// param_phya_reg_tx_zq_sel_test_ana_in:[15:12]=0b0000
+	// param_phya_reg_tx_zq_sel_gpio_in:[17:16]=0b00
+#define  DDR2_PHY_REG_84_DATA  0b00000000000000000000000000000101
+	// param_phya_reg_tune_damp_r:[3:0]=0b0101
+#define  DDR2_PHY_REG_85_DATA  0b00000000000000000000000100000001
+	// param_phyd_sel_cke_oenz:[0:0]=0b1
+	// param_phyd_tx_dqsn_default_value:[8:8]=0b1
+	// param_phyd_tx_dqsp_default_value:[12:12]=0b0
+	// param_phyd_ddr4_2t_preamble:[16:16]=0b0
+#define  DDR2_PHY_REG_86_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_zqcal_done:[0:0]=0b0
+#define  DDR2_PHY_REG_87_DATA  0b00000000000000000000000000000000
+	// param_phyd_dbg_sel:[7:0]=0b00000000
+	// param_phyd_dbg_sel_en:[16:16]=0b0
+#define  DDR2_PHY_REG_89_DATA  0b00000000000000000000000000000000
+	// param_phyd_reg_dfs_sel:[0:0]=0b0
+#define  DDR2_PHY_REG_90_DATA  0b00000000001100110011001100110001
+	// param_phyd_ca_sw_dline_en:[0:0]=0b1
+	// param_phyd_byte0_wr_sw_dline_en:[4:4]=0b1
+	// param_phyd_byte1_wr_sw_dline_en:[5:5]=0b1
+	// param_phyd_byte0_wdqs_sw_dline_en:[8:8]=0b1
+	// param_phyd_byte1_wdqs_sw_dline_en:[9:9]=0b1
+	// param_phyd_byte0_rd_sw_dline_en:[12:12]=0b1
+	// param_phyd_byte1_rd_sw_dline_en:[13:13]=0b1
+	// param_phyd_byte0_rdg_sw_dline_en:[16:16]=0b1
+	// param_phyd_byte1_rdg_sw_dline_en:[17:17]=0b1
+	// param_phyd_byte0_rdqs_sw_dline_en:[20:20]=0b1
+	// param_phyd_byte1_rdqs_sw_dline_en:[21:21]=0b1
+#define  DDR2_PHY_REG_91_DATA  0b00000000000000000000000000000000
+	// param_phyd_ca_raw_dline_upd:[0:0]=0b0
+	// param_phyd_byte0_wr_raw_dline_upd:[4:4]=0b0
+	// param_phyd_byte1_wr_raw_dline_upd:[5:5]=0b0
+	// param_phyd_byte0_wdqs_raw_dline_upd:[8:8]=0b0
+	// param_phyd_byte1_wdqs_raw_dline_upd:[9:9]=0b0
+	// param_phyd_byte0_rd_raw_dline_upd:[12:12]=0b0
+	// param_phyd_byte1_rd_raw_dline_upd:[13:13]=0b0
+	// param_phyd_byte0_rdg_raw_dline_upd:[16:16]=0b0
+	// param_phyd_byte1_rdg_raw_dline_upd:[17:17]=0b0
+	// param_phyd_byte0_rdqs_raw_dline_upd:[20:20]=0b0
+	// param_phyd_byte1_rdqs_raw_dline_upd:[21:21]=0b0
+#define  DDR2_PHY_REG_92_DATA  0b00000000000000000000000000000000
+	// param_phyd_sw_dline_upd_req:[0:0]=0b0
+#define  DDR2_PHY_REG_93_DATA  0b00000000000000000000000100000000
+	// param_phyd_sw_dfi_phyupd_req:[0:0]=0b0
+	// param_phyd_sw_dfi_phyupd_req_clr:[4:4]=0b0
+	// param_phyd_sw_phyupd_dline:[8:8]=0b1
+#define  DDR2_PHY_REG_96_DATA  0b00000000000000100000000000010000
+	// param_phyd_dfi_wrlvl_req:[0:0]=0b0
+	// param_phyd_dfi_wrlvl_odt_en:[4:4]=0b1
+	// param_phyd_dfi_wrlvl_strobe_cnt:[19:16]=0b0010
+#define  DDR2_PHY_REG_97_DATA  0b00000000000000000000000000000000
+	// param_phyd_dfi_rdglvl_req:[0:0]=0b0
+	// param_phyd_dfi_rdglvl_ddr3_mpr:[4:4]=0b0
+#define  DDR2_PHY_REG_98_DATA  0b00000000000000000000000000000000
+	// param_phyd_dfi_rdlvl_req:[0:0]=0b0
+	// param_phyd_dfi_rdlvl_ddr3_mpr:[4:4]=0b0
+#define  DDR2_PHY_REG_99_DATA  0b00000000000001010000010000000000
+	// param_phyd_dfi_wdqlvl_req:[0:0]=0b0
+	// param_phyd_dfi_wdqlvl_bist_data_en:[4:4]=0b0
+	// param_phyd_dfi_wdqlvl_vref_train_en:[10:10]=0b1
+	// param_phyd_dfi_wdqlvl_vref_wait_cnt:[23:16]=0b00000101
+#define  DDR2_PHY_REG_100_DATA  0b00000000000000100001001000001110
+	// param_phyd_dfi_wdqlvl_vref_start:[6:0]=0b0001110
+	// param_phyd_dfi_wdqlvl_vref_end:[14:8]=0b0010010
+	// param_phyd_dfi_wdqlvl_vref_step:[19:16]=0b0010
+#define  DDR2_PHY_REG_128_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_byte0_test_en:[0:0]=0b0
+	// param_phya_reg_tx_byte0_ddr_test:[15:8]=0b00000000
+	// param_phya_reg_rx_byte0_sel_test_in0:[19:16]=0b0000
+	// param_phya_reg_rx_byte0_sel_test_in1:[23:20]=0b0000
+#define  DDR2_PHY_REG_129_DATA  0b00000000000000000000010001000000
+	// param_phya_reg_tx_byte0_en_rx_awys_on:[0:0]=0b0
+	// param_phya_reg_tx_byte0_sel_en_rx_dly:[5:4]=0b00
+	// param_phya_reg_rx_byte0_sel_en_rx_gen_rst:[6:6]=0b1
+	// param_phya_reg_byte0_mask_oenz:[8:8]=0b0
+	// param_phya_reg_tx_byte0_en_mask:[10:10]=0b1
+	// param_phya_reg_rx_byte0_sel_cnt_mode:[13:12]=0b00
+	// param_phya_reg_tx_byte0_sel_int_loop_back:[14:14]=0b0
+	// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated:[17:16]=0b00
+	// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline:[18:18]=0b0
+#define  DDR2_PHY_REG_130_DATA  0b00000000000000000000000000000000
+	// param_phyd_reg_reserved_byte0:[31:0]=0b00000000000000000000000000000000
+#define  DDR2_PHY_REG_136_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_byte1_test_en:[0:0]=0b0
+	// param_phya_reg_tx_byte1_ddr_test:[15:8]=0b00000000
+	// param_phya_reg_rx_byte1_sel_test_in0:[19:16]=0b0000
+	// param_phya_reg_rx_byte1_sel_test_in1:[23:20]=0b0000
+#define  DDR2_PHY_REG_137_DATA  0b00000000000000000000010001000000
+	// param_phya_reg_tx_byte1_en_rx_awys_on:[0:0]=0b0
+	// param_phya_reg_tx_byte1_sel_en_rx_dly:[5:4]=0b00
+	// param_phya_reg_rx_byte1_sel_en_rx_gen_rst:[6:6]=0b1
+	// param_phya_reg_byte1_mask_oenz:[8:8]=0b0
+	// param_phya_reg_tx_byte1_en_mask:[10:10]=0b1
+	// param_phya_reg_rx_byte1_sel_cnt_mode:[13:12]=0b00
+	// param_phya_reg_tx_byte1_sel_int_loop_back:[14:14]=0b0
+	// param_phya_reg_rx_byte1_sel_dqs_dly_for_gated:[17:16]=0b00
+	// param_phya_reg_tx_byte1_en_extend_oenz_gated_dline:[18:18]=0b0
+#define  DDR2_PHY_REG_138_DATA  0b00000000000000000000000000000000
+	// param_phyd_reg_reserved_byte1:[31:0]=0b00000000000000000000000000000000
+#define  DDR2_PHY_REG_0_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_ca_sel_lpddr4_pmos_ph_ca:[3:3]=0b0
+	// f0_param_phya_reg_tx_clk_sel_lpddr4_pmos_ph_clk:[4:4]=0b0
+	// f0_param_phya_reg_tx_sel_lpddr4_pmos_ph:[5:5]=0b0
+#define  DDR2_PHY_REG_1_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_ca_drvn_de:[1:0]=0b00
+	// f0_param_phya_reg_tx_ca_drvp_de:[5:4]=0b00
+	// f0_param_phya_reg_tx_clk0_drvn_de:[9:8]=0b00
+	// f0_param_phya_reg_tx_clk0_drvp_de:[13:12]=0b00
+	// f0_param_phya_reg_tx_csb_drvn_de:[17:16]=0b00
+	// f0_param_phya_reg_tx_csb_drvp_de:[21:20]=0b00
+	// f0_param_phya_reg_tx_ca_en_tx_de:[24:24]=0b0
+	// f0_param_phya_reg_tx_clk0_en_tx_de:[28:28]=0b0
+	// f0_param_phya_reg_tx_csb_en_tx_de:[30:30]=0b0
+#define  DDR2_PHY_REG_2_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_ca_sel_dly1t_ca:[22:0]=0b00000000000000000000000
+#define  DDR2_PHY_REG_3_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_clk_sel_dly1t_clk0:[0:0]=0b0
+	// f0_param_phya_reg_tx_ca_sel_dly1t_cke0:[8:8]=0b0
+	// f0_param_phya_reg_tx_ca_sel_dly1t_csb0:[16:16]=0b0
+#define  DDR2_PHY_REG_4_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_vref_en_free_offset:[0:0]=0b0
+	// f0_param_phya_reg_tx_vref_en_rangex2:[1:1]=0b0
+	// f0_param_phya_reg_tx_vref_sel_lpddr4divby2p5:[2:2]=0b0
+	// f0_param_phya_reg_tx_vref_sel_lpddr4divby3:[3:3]=0b0
+	// f0_param_phya_reg_tx_vref_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_tx_vref_sel:[20:16]=0b10000
+#define  DDR2_PHY_REG_5_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_vrefca_en_free_offset:[0:0]=0b0
+	// f0_param_phya_reg_tx_vrefca_en_rangex2:[1:1]=0b0
+	// f0_param_phya_reg_tx_vrefca_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_tx_vrefca_sel:[20:16]=0b10000
+#define  DDR2_PHY_REG_6_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_tx_byte_dqs_extend:[2:0]=0b000
+#define  DDR2_PHY_REG_7_F0_DATA  0b00000000000000000100000001000000
+	// f0_param_phya_reg_rx_byte0_odt_reg:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte0_sel_odt_reg_mode:[6:6]=0b1
+	// f0_param_phya_reg_rx_byte1_odt_reg:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte1_sel_odt_reg_mode:[14:14]=0b1
+#define  DDR2_PHY_REG_64_F0_DATA  0b00000000000001000001000000000001
+	// f0_param_phya_reg_rx_byte0_en_lsmode:[0:0]=0b1
+	// f0_param_phya_reg_rx_byte0_hystr:[5:4]=0b00
+	// f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f0_param_phya_reg_rx_byte0_sel_odt_center_tap:[10:10]=0b0
+	// f0_param_phya_reg_byte0_en_rec_vol_mode:[12:12]=0b1
+	// f0_param_phya_reg_tx_byte0_force_en_lvstl_ph:[14:14]=0b0
+	// f0_param_phya_reg_rx_byte0_force_en_lvstl_odt:[16:16]=0b0
+	// f0_param_phya_reg_rx_byte0_en_trig_lvl_rangex2:[18:18]=0b1
+	// f0_param_phya_reg_rx_byte0_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR2_PHY_REG_65_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_byte0_drvn_de_dq:[1:0]=0b00
+	// f0_param_phya_reg_tx_byte0_drvp_de_dq:[5:4]=0b00
+	// f0_param_phya_reg_tx_byte0_drvn_de_dqs:[9:8]=0b00
+	// f0_param_phya_reg_tx_byte0_drvp_de_dqs:[13:12]=0b00
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dq:[16:16]=0b0
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs:[20:20]=0b1
+#define  DDR2_PHY_REG_66_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte0_sel_dly1t_dq:[8:0]=0b000000000
+	// f0_param_phya_reg_tx_byte0_sel_dly1t_dqs:[12:12]=0b0
+	// f0_param_phya_reg_tx_byte0_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR2_PHY_REG_67_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR2_PHY_REG_68_F0_DATA  0b00000000000000000000000000000100
+	// f0_param_phyd_reg_rx_byte0_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR2_PHY_REG_69_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte0_dq0_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte0_dq1_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte0_dq2_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte0_dq3_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_70_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte0_dq4_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte0_dq5_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte0_dq6_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte0_dq7_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_71_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte0_dm_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte0_dqsn_offset:[19:16]=0b0000
+	// f0_param_phyd_reg_byte0_dqsp_offset:[27:24]=0b0000
+#define  DDR2_PHY_REG_72_F0_DATA  0b00000000000000000000000000000011
+	// f0_param_phyd_tx_byte0_tx_oenz_extend:[2:0]=0b011
+#define  DDR2_PHY_REG_80_F0_DATA  0b00000000000001000001000000000001
+	// f0_param_phya_reg_rx_byte1_en_lsmode:[0:0]=0b1
+	// f0_param_phya_reg_rx_byte1_hystr:[5:4]=0b00
+	// f0_param_phya_reg_rx_byte1_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f0_param_phya_reg_rx_byte1_sel_odt_center_tap:[10:10]=0b0
+	// f0_param_phya_reg_byte1_en_rec_vol_mode:[12:12]=0b1
+	// f0_param_phya_reg_tx_byte1_force_en_lvstl_ph:[14:14]=0b0
+	// f0_param_phya_reg_rx_byte1_force_en_lvstl_odt:[16:16]=0b0
+	// f0_param_phya_reg_rx_byte1_en_trig_lvl_rangex2:[18:18]=0b1
+	// f0_param_phya_reg_rx_byte1_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR2_PHY_REG_81_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_byte1_drvn_de_dq:[1:0]=0b00
+	// f0_param_phya_reg_tx_byte1_drvp_de_dq:[5:4]=0b00
+	// f0_param_phya_reg_tx_byte1_drvn_de_dqs:[9:8]=0b00
+	// f0_param_phya_reg_tx_byte1_drvp_de_dqs:[13:12]=0b00
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dq:[16:16]=0b0
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs:[20:20]=0b1
+#define  DDR2_PHY_REG_82_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte1_sel_dly1t_dq:[8:0]=0b000000000
+	// f0_param_phya_reg_tx_byte1_sel_dly1t_dqs:[12:12]=0b0
+	// f0_param_phya_reg_tx_byte1_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR2_PHY_REG_83_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR2_PHY_REG_84_F0_DATA  0b00000000000000000000000000000100
+	// f0_param_phyd_reg_rx_byte1_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR2_PHY_REG_85_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte1_dq0_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte1_dq1_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte1_dq2_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte1_dq3_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_86_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte1_dq4_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte1_dq5_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte1_dq6_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte1_dq7_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_87_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte1_dm_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte1_dqsn_offset:[19:16]=0b0000
+	// f0_param_phyd_reg_byte1_dqsp_offset:[27:24]=0b0000
+#define  DDR2_PHY_REG_88_F0_DATA  0b00000000000000000000000000000011
+	// f0_param_phyd_tx_byte1_tx_oenz_extend:[2:0]=0b011
+#define  DDR2_PHY_REG_320_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_ca0_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_ca0_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_331_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_tx_ca22_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_332_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_cke0_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_cke0_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_333_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_csb0_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_cs0_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_334_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_resetz_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_reset_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_336_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_ca0_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_348_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_cke0_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_349_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_csb0_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_350_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_resetz_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_351_F0_DATA  0b00001000000010000000010000000100
+	// f0_param_phya_reg_tx_ca_drvn_ca:[4:0]=0b00100
+	// f0_param_phya_reg_tx_ca_drvp_ca:[12:8]=0b00100
+	// f0_param_phya_reg_tx_ca_drvn_csb:[20:16]=0b01000
+	// f0_param_phya_reg_tx_ca_drvp_csb:[28:24]=0b01000
+#define  DDR2_PHY_REG_352_F0_DATA  0b00001000000010000000100000001000
+	// f0_param_phya_reg_tx_clk_drvn_clkn0:[4:0]=0b01000
+	// f0_param_phya_reg_tx_clk_drvp_clkn0:[12:8]=0b01000
+	// f0_param_phya_reg_tx_clk_drvn_clkp0:[20:16]=0b01000
+	// f0_param_phya_reg_tx_clk_drvp_clkp0:[28:24]=0b01000
+#define  DDR2_PHY_REG_384_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit0_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit1_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_385_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit2_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit3_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_386_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit4_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit5_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_387_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit6_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit7_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_388_F0_DATA  0b00000000000000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit8_data_shift:[13:8]=0b000110
+#define  DDR2_PHY_REG_389_F0_DATA  0b00001101000000000000000000000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f0_param_phyd_tx_byte0_dqs_shift:[29:24]=0b001101
+#define  DDR2_PHY_REG_390_F0_DATA  0b00001010000000000000101100000000
+	// f0_param_phyd_tx_byte0_oenz_dqs_shift:[13:8]=0b001011
+	// f0_param_phyd_tx_byte0_oenz_shift:[29:24]=0b001010
+#define  DDR2_PHY_REG_391_F0_DATA  0b00000000000001000000010000000000
+	// f0_param_phyd_tx_byte0_oenz_dqs_extend:[11:8]=0b0100
+	// f0_param_phyd_tx_byte0_oenz_extend:[19:16]=0b0100
+#define  DDR2_PHY_REG_392_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_393_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_394_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_395_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_396_F0_DATA  0b00000000000000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR2_PHY_REG_397_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR2_PHY_REG_398_F0_DATA  0b00000000000000000000100000001000
+	// f0_param_phya_reg_tx_byte0_drvn_dq:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvp_dq:[12:8]=0b01000
+#define  DDR2_PHY_REG_399_F0_DATA  0b00001000000010000000100000001000
+	// f0_param_phya_reg_tx_byte0_drvn_dqsn:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvp_dqsn:[12:8]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvn_dqsp:[20:16]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvp_dqsp:[28:24]=0b01000
+#define  DDR2_PHY_REG_400_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit0_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit1_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_401_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit2_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit3_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_402_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit4_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit5_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_403_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit6_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit7_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_404_F0_DATA  0b00000000000000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit8_data_shift:[13:8]=0b000110
+#define  DDR2_PHY_REG_405_F0_DATA  0b00001101000000000000000000000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f0_param_phyd_tx_byte1_dqs_shift:[29:24]=0b001101
+#define  DDR2_PHY_REG_406_F0_DATA  0b00001010000000000000101100000000
+	// f0_param_phyd_tx_byte1_oenz_dqs_shift:[13:8]=0b001011
+	// f0_param_phyd_tx_byte1_oenz_shift:[29:24]=0b001010
+#define  DDR2_PHY_REG_407_F0_DATA  0b00000000000001000000010000000000
+	// f0_param_phyd_tx_byte1_oenz_dqs_extend:[11:8]=0b0100
+	// f0_param_phyd_tx_byte1_oenz_extend:[19:16]=0b0100
+#define  DDR2_PHY_REG_408_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_409_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_410_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_411_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_412_F0_DATA  0b00000000000000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR2_PHY_REG_413_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR2_PHY_REG_414_F0_DATA  0b00000000000000000000100000001000
+	// f0_param_phya_reg_tx_byte1_drvn_dq:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvp_dq:[12:8]=0b01000
+#define  DDR2_PHY_REG_415_F0_DATA  0b00001000000010000000100000001000
+	// f0_param_phya_reg_tx_byte1_drvn_dqsn:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvp_dqsn:[12:8]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvn_dqsp:[20:16]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvp_dqsp:[28:24]=0b01000
+#define  DDR2_PHY_REG_448_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_449_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_450_F0_DATA  0b00000000010000000100000000000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f0_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR2_PHY_REG_451_F0_DATA  0b00000000000000000000100100000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_mask_ranka_sw:[6:0]=0b0000000
+	// f0_param_phyd_rx_byte0_mask_shift:[13:8]=0b001001
+#define  DDR2_PHY_REG_452_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_rx_byte0_en_shift:[13:8]=0b000000
+	// f0_param_phyd_rx_byte0_odt_en_shift:[29:24]=0b000000
+#define  DDR2_PHY_REG_453_F0_DATA  0b00000000000001110000111000001110
+	// f0_param_phyd_rx_byte0_en_extend:[3:0]=0b1110
+	// f0_param_phyd_rx_byte0_odt_en_extend:[11:8]=0b1110
+	// f0_param_phyd_rx_byte0_rden_to_rdvld:[20:16]=0b00111
+#define  DDR2_PHY_REG_454_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte0_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_455_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte0_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_456_F0_DATA  0b01000000010000000000000000000000
+	// f0_param_phya_reg_rx_byte0_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_tx_byte0_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f0_param_phya_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR2_PHY_REG_457_F0_DATA  0b00000000000100000000000000010000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dq:[4:0]=0b10000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dqs:[20:16]=0b10000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dqs_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_460_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_461_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_462_F0_DATA  0b00000000010000000100000000000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f0_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR2_PHY_REG_463_F0_DATA  0b00000000000000000000100100000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_mask_ranka_sw:[6:0]=0b0000000
+	// f0_param_phyd_rx_byte1_mask_shift:[13:8]=0b001001
+#define  DDR2_PHY_REG_464_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_rx_byte1_en_shift:[13:8]=0b000000
+	// f0_param_phyd_rx_byte1_odt_en_shift:[29:24]=0b000000
+#define  DDR2_PHY_REG_465_F0_DATA  0b00000000000001110000111000001110
+	// f0_param_phyd_rx_byte1_en_extend:[3:0]=0b1110
+	// f0_param_phyd_rx_byte1_odt_en_extend:[11:8]=0b1110
+	// f0_param_phyd_rx_byte1_rden_to_rdvld:[20:16]=0b00111
+#define  DDR2_PHY_REG_466_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte1_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_467_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte1_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_468_F0_DATA  0b01000000010000000000000000000000
+	// f0_param_phya_reg_rx_byte1_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_tx_byte1_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f0_param_phya_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR2_PHY_REG_469_F0_DATA  0b00000000000100000000000000010000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dq:[4:0]=0b10000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dqs:[20:16]=0b10000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dqs_offset:[30:24]=0b0000000
+#ifdef F1_TEST
+#define  DDR2_PHY_REG_0_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_ca_sel_lpddr4_pmos_ph_ca:[3:3]=0b0
+	// f1_param_phya_reg_tx_clk_sel_lpddr4_pmos_ph_clk:[4:4]=0b0
+	// f1_param_phya_reg_tx_sel_lpddr4_pmos_ph:[5:5]=0b0
+#define  DDR2_PHY_REG_1_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_ca_drvn_de:[1:0]=0b00
+	// f1_param_phya_reg_tx_ca_drvp_de:[5:4]=0b00
+	// f1_param_phya_reg_tx_clk0_drvn_de:[9:8]=0b00
+	// f1_param_phya_reg_tx_clk0_drvp_de:[13:12]=0b00
+	// f1_param_phya_reg_tx_csb_drvn_de:[17:16]=0b00
+	// f1_param_phya_reg_tx_csb_drvp_de:[21:20]=0b00
+	// f1_param_phya_reg_tx_ca_en_tx_de:[24:24]=0b0
+	// f1_param_phya_reg_tx_clk0_en_tx_de:[28:28]=0b0
+	// f1_param_phya_reg_tx_csb_en_tx_de:[30:30]=0b0
+#define  DDR2_PHY_REG_2_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_ca_sel_dly1t_ca:[22:0]=0b00000000000000000000000
+#define  DDR2_PHY_REG_3_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_clk_sel_dly1t_clk0:[0:0]=0b0
+	// f1_param_phya_reg_tx_ca_sel_dly1t_cke0:[8:8]=0b0
+	// f1_param_phya_reg_tx_ca_sel_dly1t_csb0:[16:16]=0b0
+#define  DDR2_PHY_REG_4_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_vref_en_free_offset:[0:0]=0b0
+	// f1_param_phya_reg_tx_vref_en_rangex2:[1:1]=0b0
+	// f1_param_phya_reg_tx_vref_sel_lpddr4divby2p5:[2:2]=0b0
+	// f1_param_phya_reg_tx_vref_sel_lpddr4divby3:[3:3]=0b0
+	// f1_param_phya_reg_tx_vref_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_tx_vref_sel:[20:16]=0b10000
+#define  DDR2_PHY_REG_5_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_vrefca_en_free_offset:[0:0]=0b0
+	// f1_param_phya_reg_tx_vrefca_en_rangex2:[1:1]=0b0
+	// f1_param_phya_reg_tx_vrefca_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_tx_vrefca_sel:[20:16]=0b10000
+#define  DDR2_PHY_REG_6_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_tx_byte_dqs_extend:[2:0]=0b000
+#define  DDR2_PHY_REG_7_F1_DATA  0b00000000000000000100000001000000
+	// f1_param_phya_reg_rx_byte0_odt_reg:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte0_sel_odt_reg_mode:[6:6]=0b1
+	// f1_param_phya_reg_rx_byte1_odt_reg:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte1_sel_odt_reg_mode:[14:14]=0b1
+#define  DDR2_PHY_REG_64_F1_DATA  0b00000000000000000001000000000001
+	// f1_param_phya_reg_rx_byte0_en_lsmode:[0:0]=0b1
+	// f1_param_phya_reg_rx_byte0_hystr:[5:4]=0b00
+	// f1_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f1_param_phya_reg_rx_byte0_sel_odt_center_tap:[10:10]=0b0
+	// f1_param_phya_reg_byte0_en_rec_vol_mode:[12:12]=0b1
+	// f1_param_phya_reg_tx_byte0_force_en_lvstl_ph:[14:14]=0b0
+	// f1_param_phya_reg_rx_byte0_force_en_lvstl_odt:[16:16]=0b0
+	// f1_param_phya_reg_rx_byte0_en_trig_lvl_rangex2:[18:18]=0b0
+	// f1_param_phya_reg_rx_byte0_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR2_PHY_REG_65_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_byte0_drvn_de_dq:[1:0]=0b00
+	// f1_param_phya_reg_tx_byte0_drvp_de_dq:[5:4]=0b00
+	// f1_param_phya_reg_tx_byte0_drvn_de_dqs:[9:8]=0b00
+	// f1_param_phya_reg_tx_byte0_drvp_de_dqs:[13:12]=0b00
+	// f1_param_phya_reg_tx_byte0_en_tx_de_dq:[16:16]=0b0
+	// f1_param_phya_reg_tx_byte0_en_tx_de_dqs:[20:20]=0b1
+#define  DDR2_PHY_REG_66_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte0_sel_dly1t_dq:[8:0]=0b000000000
+	// f1_param_phya_reg_tx_byte0_sel_dly1t_dqs:[12:12]=0b0
+	// f1_param_phya_reg_tx_byte0_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR2_PHY_REG_67_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR2_PHY_REG_68_F1_DATA  0b00000000000000000000000000000100
+	// f1_param_phyd_reg_rx_byte0_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR2_PHY_REG_69_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte0_dq0_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte0_dq1_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte0_dq2_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte0_dq3_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_70_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte0_dq4_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte0_dq5_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte0_dq6_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte0_dq7_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_71_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte0_dm_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte0_dqsn_offset:[19:16]=0b0000
+	// f1_param_phyd_reg_byte0_dqsp_offset:[27:24]=0b0000
+#define  DDR2_PHY_REG_72_F1_DATA  0b00000000000000000000000000000011
+	// f1_param_phyd_tx_byte0_tx_oenz_extend:[2:0]=0b011
+#define  DDR2_PHY_REG_80_F1_DATA  0b00000000000000000001000000000001
+	// f1_param_phya_reg_rx_byte1_en_lsmode:[0:0]=0b1
+	// f1_param_phya_reg_rx_byte1_hystr:[5:4]=0b00
+	// f1_param_phya_reg_rx_byte1_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f1_param_phya_reg_rx_byte1_sel_odt_center_tap:[10:10]=0b0
+	// f1_param_phya_reg_byte1_en_rec_vol_mode:[12:12]=0b1
+	// f1_param_phya_reg_tx_byte1_force_en_lvstl_ph:[14:14]=0b0
+	// f1_param_phya_reg_rx_byte1_force_en_lvstl_odt:[16:16]=0b0
+	// f1_param_phya_reg_rx_byte1_en_trig_lvl_rangex2:[18:18]=0b0
+	// f1_param_phya_reg_rx_byte1_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR2_PHY_REG_81_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_byte1_drvn_de_dq:[1:0]=0b00
+	// f1_param_phya_reg_tx_byte1_drvp_de_dq:[5:4]=0b00
+	// f1_param_phya_reg_tx_byte1_drvn_de_dqs:[9:8]=0b00
+	// f1_param_phya_reg_tx_byte1_drvp_de_dqs:[13:12]=0b00
+	// f1_param_phya_reg_tx_byte1_en_tx_de_dq:[16:16]=0b0
+	// f1_param_phya_reg_tx_byte1_en_tx_de_dqs:[20:20]=0b1
+#define  DDR2_PHY_REG_82_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte1_sel_dly1t_dq:[8:0]=0b000000000
+	// f1_param_phya_reg_tx_byte1_sel_dly1t_dqs:[12:12]=0b0
+	// f1_param_phya_reg_tx_byte1_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR2_PHY_REG_83_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR2_PHY_REG_84_F1_DATA  0b00000000000000000000000000000100
+	// f1_param_phyd_reg_rx_byte1_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR2_PHY_REG_85_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte1_dq0_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte1_dq1_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte1_dq2_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte1_dq3_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_86_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte1_dq4_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte1_dq5_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte1_dq6_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte1_dq7_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_87_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte1_dm_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte1_dqsn_offset:[19:16]=0b0000
+	// f1_param_phyd_reg_byte1_dqsp_offset:[27:24]=0b0000
+#define  DDR2_PHY_REG_88_F1_DATA  0b00000000000000000000000000000011
+	// f1_param_phyd_tx_byte1_tx_oenz_extend:[2:0]=0b011
+#define  DDR2_PHY_REG_320_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_ca0_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_ca0_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_331_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_tx_ca22_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_332_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_cke0_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_cke0_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_333_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_csb0_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_cs0_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_334_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_resetz_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_reset_shift_sel:[13:8]=0b000100
+#define  DDR2_PHY_REG_336_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_ca0_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_348_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_cke0_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_349_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_csb0_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_350_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_resetz_raw:[6:0]=0b0000000
+#define  DDR2_PHY_REG_351_F1_DATA  0b00001000000010000000010000000100
+	// f1_param_phya_reg_tx_ca_drvn_ca:[4:0]=0b00100
+	// f1_param_phya_reg_tx_ca_drvp_ca:[12:8]=0b00100
+	// f1_param_phya_reg_tx_ca_drvn_csb:[20:16]=0b01000
+	// f1_param_phya_reg_tx_ca_drvp_csb:[28:24]=0b01000
+#define  DDR2_PHY_REG_352_F1_DATA  0b00001000000010000000100000001000
+	// f1_param_phya_reg_tx_clk_drvn_clkn0:[4:0]=0b01000
+	// f1_param_phya_reg_tx_clk_drvp_clkn0:[12:8]=0b01000
+	// f1_param_phya_reg_tx_clk_drvn_clkp0:[20:16]=0b01000
+	// f1_param_phya_reg_tx_clk_drvp_clkp0:[28:24]=0b01000
+#define  DDR2_PHY_REG_384_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit0_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit1_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_385_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit2_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit3_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_386_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit4_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit5_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_387_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit6_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit7_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_388_F1_DATA  0b00000000000000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit8_data_shift:[13:8]=0b000110
+#define  DDR2_PHY_REG_389_F1_DATA  0b00001101000000000000000000000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f1_param_phyd_tx_byte0_dqs_shift:[29:24]=0b001101
+#define  DDR2_PHY_REG_390_F1_DATA  0b00001010000000000000101100000000
+	// f1_param_phyd_tx_byte0_oenz_dqs_shift:[13:8]=0b001011
+	// f1_param_phyd_tx_byte0_oenz_shift:[29:24]=0b001010
+#define  DDR2_PHY_REG_391_F1_DATA  0b00000000000001000000010000000000
+	// f1_param_phyd_tx_byte0_oenz_dqs_extend:[11:8]=0b0100
+	// f1_param_phyd_tx_byte0_oenz_extend:[19:16]=0b0100
+#define  DDR2_PHY_REG_392_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_393_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_394_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_395_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_396_F1_DATA  0b00000000000000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR2_PHY_REG_397_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR2_PHY_REG_398_F1_DATA  0b00000000000000000000100000001000
+	// f1_param_phya_reg_tx_byte0_drvn_dq:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvp_dq:[12:8]=0b01000
+#define  DDR2_PHY_REG_399_F1_DATA  0b00001000000010000000100000001000
+	// f1_param_phya_reg_tx_byte0_drvn_dqsn:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvp_dqsn:[12:8]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvn_dqsp:[20:16]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvp_dqsp:[28:24]=0b01000
+#define  DDR2_PHY_REG_400_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit0_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit1_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_401_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit2_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit3_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_402_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit4_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit5_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_403_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit6_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit7_data_shift:[29:24]=0b000110
+#define  DDR2_PHY_REG_404_F1_DATA  0b00000000000000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit8_data_shift:[13:8]=0b000110
+#define  DDR2_PHY_REG_405_F1_DATA  0b00001101000000000000000000000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f1_param_phyd_tx_byte1_dqs_shift:[29:24]=0b001101
+#define  DDR2_PHY_REG_406_F1_DATA  0b00001010000000000000101100000000
+	// f1_param_phyd_tx_byte1_oenz_dqs_shift:[13:8]=0b001011
+	// f1_param_phyd_tx_byte1_oenz_shift:[29:24]=0b001010
+#define  DDR2_PHY_REG_407_F1_DATA  0b00000000000001000000010000000000
+	// f1_param_phyd_tx_byte1_oenz_dqs_extend:[11:8]=0b0100
+	// f1_param_phyd_tx_byte1_oenz_extend:[19:16]=0b0100
+#define  DDR2_PHY_REG_408_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_409_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_410_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_411_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR2_PHY_REG_412_F1_DATA  0b00000000000000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR2_PHY_REG_413_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR2_PHY_REG_414_F1_DATA  0b00000000000000000000100000001000
+	// f1_param_phya_reg_tx_byte1_drvn_dq:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvp_dq:[12:8]=0b01000
+#define  DDR2_PHY_REG_415_F1_DATA  0b00001000000010000000100000001000
+	// f1_param_phya_reg_tx_byte1_drvn_dqsn:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvp_dqsn:[12:8]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvn_dqsp:[20:16]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvp_dqsp:[28:24]=0b01000
+#define  DDR2_PHY_REG_448_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_449_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_450_F1_DATA  0b00000000010000000100000000000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f1_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR2_PHY_REG_451_F1_DATA  0b00000000000000000000100100000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_mask_ranka_sw:[6:0]=0b0000000
+	// f1_param_phyd_rx_byte0_mask_shift:[13:8]=0b001001
+#define  DDR2_PHY_REG_452_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_rx_byte0_en_shift:[13:8]=0b000000
+	// f1_param_phyd_rx_byte0_odt_en_shift:[29:24]=0b000000
+#define  DDR2_PHY_REG_453_F1_DATA  0b00000000000001110000111000001110
+	// f1_param_phyd_rx_byte0_en_extend:[3:0]=0b1110
+	// f1_param_phyd_rx_byte0_odt_en_extend:[11:8]=0b1110
+	// f1_param_phyd_rx_byte0_rden_to_rdvld:[20:16]=0b00111
+#define  DDR2_PHY_REG_454_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte0_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_455_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte0_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_456_F1_DATA  0b01000000010000000000000000000000
+	// f1_param_phya_reg_rx_byte0_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_tx_byte0_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f1_param_phya_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR2_PHY_REG_457_F1_DATA  0b00000000000100000000000000010000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dq:[4:0]=0b10000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dqs:[20:16]=0b10000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dqs_offset:[30:24]=0b0000000
+#define  DDR2_PHY_REG_460_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_461_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR2_PHY_REG_462_F1_DATA  0b00000000010000000100000000000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f1_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR2_PHY_REG_463_F1_DATA  0b00000000000000000000100100000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_mask_ranka_sw:[6:0]=0b0000000
+	// f1_param_phyd_rx_byte1_mask_shift:[13:8]=0b001001
+#define  DDR2_PHY_REG_464_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_rx_byte1_en_shift:[13:8]=0b000000
+	// f1_param_phyd_rx_byte1_odt_en_shift:[29:24]=0b000000
+#define  DDR2_PHY_REG_465_F1_DATA  0b00000000000001110000111000001110
+	// f1_param_phyd_rx_byte1_en_extend:[3:0]=0b1110
+	// f1_param_phyd_rx_byte1_odt_en_extend:[11:8]=0b1110
+	// f1_param_phyd_rx_byte1_rden_to_rdvld:[20:16]=0b00111
+#define  DDR2_PHY_REG_466_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte1_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_467_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte1_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR2_PHY_REG_468_F1_DATA  0b01000000010000000000000000000000
+	// f1_param_phya_reg_rx_byte1_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_tx_byte1_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f1_param_phya_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR2_PHY_REG_469_F1_DATA  0b00000000000100000000000000010000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dq:[4:0]=0b10000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dqs:[20:16]=0b10000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dqs_offset:[30:24]=0b0000000
+#endif //F1_TEST
+void ddrc_init(void);
+void phy_init(void);
+void ctrl_init_high_patch(void);
+void ctrl_init_low_patch(void);
+//void ctrl_init_detect_dram_size(uint8_t * dram_cap_in_mbyte);
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte);
+
+#endif /* __DDR_PI_PHY_H__ */
diff --git a/firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr3_1866_init.h b/firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr3_1866_init.h
new file mode 100644
index 0000000..58bacab
--- /dev/null
+++ b/firmware/plat/cv180x/include/ddr/ddr_config/ddr_auto_x16/ddr3_1866_init.h
@@ -0,0 +1,1157 @@
+#ifndef __DDR_PI_PHY_H__
+#define __DDR_PI_PHY_H__
+
+extern uint32_t ddr_data_rate;
+// $Module: reg_cv_phy_param_ddr3_1866 $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: KC TSAI $
+// $Date: Fri, 11 Mar 2022 03:31:16 PM $
+//
+
+#define  DDR_PHY_REG_0_DATA  0b00000011000000100000000100000000
+	// param_phyd_swap_ca0:[4:0]=0b00000
+	// param_phyd_swap_ca1:[12:8]=0b00001
+	// param_phyd_swap_ca2:[20:16]=0b00010
+	// param_phyd_swap_ca3:[28:24]=0b00011
+#define  DDR_PHY_REG_1_DATA  0b00000111000001100000010100000100
+	// param_phyd_swap_ca4:[4:0]=0b00100
+	// param_phyd_swap_ca5:[12:8]=0b00101
+	// param_phyd_swap_ca6:[20:16]=0b00110
+	// param_phyd_swap_ca7:[28:24]=0b00111
+#define  DDR_PHY_REG_2_DATA  0b00001011000010100000100100001000
+	// param_phyd_swap_ca8:[4:0]=0b01000
+	// param_phyd_swap_ca9:[12:8]=0b01001
+	// param_phyd_swap_ca10:[20:16]=0b01010
+	// param_phyd_swap_ca11:[28:24]=0b01011
+#define  DDR_PHY_REG_3_DATA  0b00001111000011100000110100001100
+	// param_phyd_swap_ca12:[4:0]=0b01100
+	// param_phyd_swap_ca13:[12:8]=0b01101
+	// param_phyd_swap_ca14:[20:16]=0b01110
+	// param_phyd_swap_ca15:[28:24]=0b01111
+#define  DDR_PHY_REG_4_DATA  0b00010011000100100001000100010000
+	// param_phyd_swap_ca16:[4:0]=0b10000
+	// param_phyd_swap_ca17:[12:8]=0b10001
+	// param_phyd_swap_ca18:[20:16]=0b10010
+	// param_phyd_swap_ca19:[28:24]=0b10011
+#define  DDR_PHY_REG_5_DATA  0b00000000000101100001010100010100
+	// param_phyd_swap_ca20:[4:0]=0b10100
+	// param_phyd_swap_ca21:[12:8]=0b10101
+	// param_phyd_swap_ca22:[20:16]=0b10110
+#define  DDR_PHY_REG_6_DATA  0b00000000000000000000000000000000
+	// param_phyd_swap_cke0:[0:0]=0b0
+	// param_phyd_swap_cs0:[4:4]=0b0
+#define  DDR_PHY_REG_7_DATA  0b00000000000000000000000100000000
+	// param_phyd_data_byte_swap_slice0:[1:0]=0b00
+	// param_phyd_data_byte_swap_slice1:[9:8]=0b01
+#define  DDR_PHY_REG_8_DATA  0b01110110010101000011001000010000
+	// param_phyd_swap_byte0_dq0_mux:[3:0]=0b0000
+	// param_phyd_swap_byte0_dq1_mux:[7:4]=0b0001
+	// param_phyd_swap_byte0_dq2_mux:[11:8]=0b0010
+	// param_phyd_swap_byte0_dq3_mux:[15:12]=0b0011
+	// param_phyd_swap_byte0_dq4_mux:[19:16]=0b0100
+	// param_phyd_swap_byte0_dq5_mux:[23:20]=0b0101
+	// param_phyd_swap_byte0_dq6_mux:[27:24]=0b0110
+	// param_phyd_swap_byte0_dq7_mux:[31:28]=0b0111
+#define  DDR_PHY_REG_9_DATA  0b00000000000000000000000000001000
+	// param_phyd_swap_byte0_dm_mux:[3:0]=0b1000
+#define  DDR_PHY_REG_10_DATA  0b01110110010101000011001000010000
+	// param_phyd_swap_byte1_dq0_mux:[3:0]=0b0000
+	// param_phyd_swap_byte1_dq1_mux:[7:4]=0b0001
+	// param_phyd_swap_byte1_dq2_mux:[11:8]=0b0010
+	// param_phyd_swap_byte1_dq3_mux:[15:12]=0b0011
+	// param_phyd_swap_byte1_dq4_mux:[19:16]=0b0100
+	// param_phyd_swap_byte1_dq5_mux:[23:20]=0b0101
+	// param_phyd_swap_byte1_dq6_mux:[27:24]=0b0110
+	// param_phyd_swap_byte1_dq7_mux:[31:28]=0b0111
+#define  DDR_PHY_REG_11_DATA  0b00000000000000000000000000001000
+	// param_phyd_swap_byte1_dm_mux:[3:0]=0b1000
+#define  DDR_PHY_REG_16_DATA  0b00000000000000000000000000000000
+	// param_phyd_dll_rx_sw_mode:[0:0]=0b0
+	// param_phyd_dll_rx_start_cal:[1:1]=0b0
+	// param_phyd_dll_rx_cntr_mode:[2:2]=0b0
+	// param_phyd_dll_rx_hwrst_time:[3:3]=0b0
+	// param_phyd_dll_tx_sw_mode:[16:16]=0b0
+	// param_phyd_dll_tx_start_cal:[17:17]=0b0
+	// param_phyd_dll_tx_cntr_mode:[18:18]=0b0
+	// param_phyd_dll_tx_hwrst_time:[19:19]=0b0
+#define  DDR_PHY_REG_17_DATA  0b00000000011111110000000000001101
+	// param_phyd_dll_slave_delay_en:[0:0]=0b1
+	// param_phyd_dll_rw_en:[1:1]=0b0
+	// param_phyd_dll_avg_mode:[2:2]=0b1
+	// param_phyd_dll_upd_wait:[6:3]=0b0001
+	// param_phyd_dll_sw_clr:[7:7]=0b0
+	// param_phyd_dll_sw_code_mode:[8:8]=0b0
+	// param_phyd_dll_sw_code:[23:16]=0b01111111
+#define  DDR_PHY_REG_18_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_tx_clk_tx_dline_code_clkn0:[6:0]=0b0000000
+	// param_phya_reg_tx_clk_tx_dline_code_clkp0:[14:8]=0b0000000
+#define  DDR_PHY_REG_19_DATA  0b00000000000000000000000000001000
+	// param_phya_reg_sel_ddr4_mode:[0:0]=0b0
+	// param_phya_reg_sel_lpddr3_mode:[1:1]=0b0
+	// param_phya_reg_sel_lpddr4_mode:[2:2]=0b0
+	// param_phya_reg_sel_ddr3_mode:[3:3]=0b1
+	// param_phya_reg_sel_ddr2_mode:[4:4]=0b0
+#define  DDR_PHY_REG_20_DATA  0b00000000000000000000000000000110
+	// param_phyd_dram_class:[3:0]=0b0110
+#define  DDR_PHY_REG_21_DATA  0b00001100000000000000101100000000
+	// param_phyd_wrlvl_start_delay_code:[6:0]=0b0000000
+	// param_phyd_wrlvl_start_shift_code:[13:8]=0b001011
+	// param_phyd_wrlvl_end_delay_code:[22:16]=0b0000000
+	// param_phyd_wrlvl_end_shift_code:[29:24]=0b001100
+#define  DDR_PHY_REG_22_DATA  0b00001001000101100000000001001111
+	// param_phyd_wrlvl_capture_cnt:[3:0]=0b1111
+	// param_phyd_wrlvl_dly_step:[7:4]=0b0100
+	// param_phyd_wrlvl_disable:[11:8]=0b0000
+	// param_phyd_wrlvl_resp_wait_cnt:[21:16]=0b010110
+	// param_phyd_oenz_lead_cnt:[26:23]=0b0010
+	// param_phyd_wrlvl_mode:[27:27]=0b1
+#define  DDR_PHY_REG_23_DATA  0b00000000000000000000000000000000
+	// param_phyd_wrlvl_sw:[0:0]=0b0
+	// param_phyd_wrlvl_sw_upd_req:[1:1]=0b0
+	// param_phyd_wrlvl_sw_resp:[2:2]=0b0
+	// param_phyd_wrlvl_data_mask:[23:16]=0b00000000
+#define  DDR_PHY_REG_24_DATA  0b00000100000000000000001101110000
+	// param_phyd_pigtlvl_back_step:[7:0]=0b01110000
+	// param_phyd_pigtlvl_capture_cnt:[11:8]=0b0011
+	// param_phyd_pigtlvl_disable:[19:16]=0b0000
+	// param_phyd_pigtlvl_dly_step:[27:24]=0b0100
+#define  DDR_PHY_REG_25_DATA  0b00010000000000000000110000000000
+	// param_phyd_pigtlvl_start_delay_code:[6:0]=0b0000000
+	// param_phyd_pigtlvl_start_shift_code:[13:8]=0b001100
+	// param_phyd_pigtlvl_end_delay_code:[22:16]=0b0000000
+	// param_phyd_pigtlvl_end_shift_code:[29:24]=0b010000
+#define  DDR_PHY_REG_26_DATA  0b00000000100000000000000000000000
+	// param_phyd_pigtlvl_resp_wait_cnt:[5:0]=0b000000
+	// param_phyd_pigtlvl_sw:[8:8]=0b0
+	// param_phyd_pigtlvl_sw_resp:[13:12]=0b00
+	// param_phyd_pigtlvl_sw_upd_req:[16:16]=0b0
+	// param_phyd_rx_en_lead_cnt:[23:20]=0b1000
+#define  DDR_PHY_REG_28_DATA  0b00000000000000000000000100001000
+	// param_phyd_rgtrack_threshold:[4:0]=0b01000
+	// param_phyd_rgtrack_dly_step:[11:8]=0b0001
+	// param_phyd_rgtrack_disable:[19:16]=0b0000
+#define  DDR_PHY_REG_29_DATA  0b00000000000001110010000000000000
+	// param_phyd_zqcal_wait_count:[3:0]=0b0000
+	// param_phyd_zqcal_cycle_count:[15:8]=0b00100000
+	// param_phyd_zqcal_hw_mode:[18:16]=0b111
+#define  DDR_PHY_REG_32_DATA  0b00011111000000001110000000000000
+	// param_phyd_pirdlvl_dlie_code_start:[7:0]=0b00000000
+	// param_phyd_pirdlvl_dlie_code_end:[15:8]=0b11100000
+	// param_phyd_pirdlvl_deskew_start:[22:16]=0b0000000
+	// param_phyd_pirdlvl_deskew_end:[30:24]=0b0011111
+#define  DDR_PHY_REG_33_DATA  0b00000001000010110000110000001010
+	// param_phyd_pirdlvl_trig_lvl_start:[4:0]=0b01010
+	// param_phyd_pirdlvl_trig_lvl_end:[12:8]=0b01100
+	// param_phyd_pirdlvl_rdvld_start:[20:16]=0b01011
+	// param_phyd_pirdlvl_rdvld_end:[28:24]=0b00001
+#define  DDR_PHY_REG_34_DATA  0b00001010000000010000000100010100
+	// param_phyd_pirdlvl_dly_step:[3:0]=0b0100
+	// param_phyd_pirdlvl_ds_dly_step:[7:4]=0b0001
+	// param_phyd_pirdlvl_vref_step:[11:8]=0b0001
+	// param_phyd_pirdlvl_disable:[15:12]=0b0000
+	// param_phyd_pirdlvl_resp_wait_cnt:[21:16]=0b000001
+	// param_phyd_pirdlvl_vref_wait_cnt:[31:24]=0b00001010
+#define  DDR_PHY_REG_35_DATA  0b10101010101010100000000010001111
+	// param_phyd_pirdlvl_rx_prebit_deskew_en:[0:0]=0b1
+	// param_phyd_pirdlvl_rx_init_deskew_en:[1:1]=0b1
+	// param_phyd_pirdlvl_vref_training_en:[2:2]=0b1
+	// param_phyd_pirdlvl_rdvld_training_en:[3:3]=0b1
+	// param_phyd_pirdlvl_capture_cnt:[7:4]=0b1000
+	// param_phyd_pirdlvl_MR1520_BYTE:[15:8]=0b00000000
+	// param_phyd_pirdlvl_MR3240:[31:16]=0b1010101010101010
+#define  DDR_PHY_REG_36_DATA  0b00000000000000000011100000000000
+	// param_phyd_pirdlvl_data_mask:[8:0]=0b000000000
+	// param_phyd_pirdlvl_sw:[9:9]=0b0
+	// param_phyd_pirdlvl_sw_upd_req:[10:10]=0b0
+	// param_phyd_pirdlvl_sw_resp:[12:11]=0b11
+	// param_phyd_pirdlvl_trig_lvl_dqs_follow_dq:[13:13]=0b1
+#define  DDR_PHY_REG_37_DATA  0b00000000000000000000100000000001
+	// param_phyd_pirdlvl_rdvld_offset:[3:0]=0b0001
+	// param_phyd_pirdlvl_found_cnt_limite:[15:8]=0b00001000
+#define  DDR_PHY_REG_40_DATA  0b00000111010000000000010101000000
+	// param_phyd_piwdqlvl_start_delay_code:[6:0]=0b1000000
+	// param_phyd_piwdqlvl_start_shift_code:[13:8]=0b000101
+	// param_phyd_piwdqlvl_end_delay_code:[22:16]=0b1000000
+	// param_phyd_piwdqlvl_end_shift_code:[29:24]=0b000111
+#define  DDR_PHY_REG_41_DATA  0b00000001010000100000010100000100
+	// param_phyd_piwdqlvl_tx_vref_start:[4:0]=0b00100
+	// param_phyd_piwdqlvl_tx_vref_end:[12:8]=0b00101
+	// param_phyd_piwdqlvl_capture_cnt:[19:16]=0b0010
+	// param_phyd_piwdqlvl_dly_step:[23:20]=0b0100
+	// param_phyd_piwdqlvl_vref_step:[27:24]=0b0001
+	// param_phyd_piwdqlvl_disable:[31:28]=0b0000
+#define  DDR_PHY_REG_42_DATA  0b00000000010101010000000000001010
+	// param_phyd_piwdqlvl_vref_wait_cnt:[7:0]=0b00001010
+	// param_phyd_piwdqlvl_tx_vref_training_en:[8:8]=0b0
+	// param_phyd_piwdqlvl_byte_invert_0:[23:16]=0b01010101
+#define  DDR_PHY_REG_43_DATA  0b00000000010101010011110001011010
+	// param_phyd_piwdqlvl_dq_pattern_0:[15:0]=0b0011110001011010
+	// param_phyd_piwdqlvl_byte_invert_1:[23:16]=0b01010101
+#define  DDR_PHY_REG_44_DATA  0b00000000101010101010010111000011
+	// param_phyd_piwdqlvl_dq_pattern_1:[15:0]=0b1010010111000011
+	// param_phyd_piwdqlvl_byte_invert_2:[23:16]=0b10101010
+#define  DDR_PHY_REG_45_DATA  0b00000000101010101111000011110000
+	// param_phyd_piwdqlvl_dq_pattern_2:[15:0]=0b1111000011110000
+	// param_phyd_piwdqlvl_byte_invert_3:[23:16]=0b10101010
+#define  DDR_PHY_REG_46_DATA  0b00011110000000000000111100001111
+	// param_phyd_piwdqlvl_dq_pattern_3:[15:0]=0b0000111100001111
+	// param_phyd_piwdqlvl_data_mask:[24:16]=0b000000000
+	// param_phyd_piwdqlvl_pattern_sel:[28:25]=0b1111
+#define  DDR_PHY_REG_47_DATA  0b00000000000010000011111000010011
+	// param_phyd_piwdqlvl_tdfi_phy_wrdata:[2:0]=0b011
+	// param_phyd_piwdqlvl_oenz_lead_cnt:[6:3]=0b0010
+	// param_phyd_piwdqlvl_sw:[7:7]=0b0
+	// param_phyd_piwdqlvl_sw_upd_req:[8:8]=0b0
+	// param_phyd_piwdqlvl_sw_resp:[10:9]=0b11
+	// param_phyd_piwdqlvl_sw_result:[11:11]=0b1
+	// param_phyd_piwdqlvl_dq_mode:[12:12]=0b1
+	// param_phyd_piwdqlvl_dm_mode:[13:13]=0b1
+	// param_phyd_piwdqlvl_found_cnt_limite:[23:16]=0b00001000
+#define  DDR_PHY_REG_60_DATA  0b00000000000000000000000000000000
+	// param_phyd_patch_revision:[31:0]=0b00000000000000000000000000000000
+#define  DDR_PHY_REG_61_DATA  0b00000000000000110000000000110011
+	// param_phyd_ca_shift_gating_en:[0:0]=0b1
+	// param_phyd_cs_shift_gating_en:[1:1]=0b1
+	// param_phyd_cke_shift_gating_en:[2:2]=0b0
+	// param_phyd_resetz_shift_gating_en:[3:3]=0b0
+	// param_phyd_tx_byte0_shift_gating_en:[4:4]=0b1
+	// param_phyd_tx_byte1_shift_gating_en:[5:5]=0b1
+	// param_phyd_rx_byte0_shift_gating_en:[16:16]=0b1
+	// param_phyd_rx_byte1_shift_gating_en:[17:17]=0b1
+#define  DDR_PHY_REG_62_DATA  0b00000000001000010000000000101100
+	// param_phyd_lb_lfsr_seed0:[8:0]=0b000101100
+	// param_phyd_lb_lfsr_seed1:[24:16]=0b000100001
+#define  DDR_PHY_REG_63_DATA  0b00000000001101110000000000010110
+	// param_phyd_lb_lfsr_seed2:[8:0]=0b000010110
+	// param_phyd_lb_lfsr_seed3:[24:16]=0b000110111
+#define  DDR_PHY_REG_64_DATA  0b00000100000000000000000000000000
+	// param_phyd_lb_dq_en:[0:0]=0b0
+	// param_phyd_lb_dq_go:[1:1]=0b0
+	// param_phyd_lb_sw_en:[2:2]=0b0
+	// param_phyd_lb_sw_rx_en:[3:3]=0b0
+	// param_phyd_lb_sw_rx_mask:[4:4]=0b0
+	// param_phyd_lb_sw_odt_en:[5:5]=0b0
+	// param_phyd_lb_sw_ca_clkpattern:[6:6]=0b0
+	// param_phyd_lb_sync_len:[31:16]=0b0000010000000000
+#define  DDR_PHY_REG_65_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_dout0:[8:0]=0b000000000
+	// param_phyd_lb_sw_dout1:[24:16]=0b000000000
+#define  DDR_PHY_REG_67_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_oenz_dout0:[0:0]=0b0
+	// param_phyd_lb_sw_oenz_dout1:[1:1]=0b0
+	// param_phyd_lb_sw_dqsn0:[4:4]=0b0
+	// param_phyd_lb_sw_dqsn1:[5:5]=0b0
+	// param_phyd_lb_sw_dqsp0:[8:8]=0b0
+	// param_phyd_lb_sw_dqsp1:[9:9]=0b0
+	// param_phyd_lb_sw_oenz_dqs_dout0:[12:12]=0b0
+	// param_phyd_lb_sw_oenz_dqs_dout1:[13:13]=0b0
+#define  DDR_PHY_REG_68_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_ca_dout:[22:0]=0b00000000000000000000000
+#define  DDR_PHY_REG_69_DATA  0b00000000000000000000000000000000
+	// param_phyd_lb_sw_clkn0_dout:[0:0]=0b0
+	// param_phyd_lb_sw_clkp0_dout:[4:4]=0b0
+	// param_phyd_lb_sw_cke0_dout:[8:8]=0b0
+	// param_phyd_lb_sw_resetz_dout:[12:12]=0b0
+	// param_phyd_lb_sw_csb0_dout:[16:16]=0b0
+#define  DDR_PHY_REG_70_DATA  0b00000000000000000000000000000000
+	// param_phyd_clkctrl_init_complete:[0:0]=0b0
+#define  DDR_PHY_REG_71_DATA  0b00000000000000000110101000010000
+	// param_phyd_reg_resetz_dqs_rd_en:[4:4]=0b1
+	// param_phyd_rx_upd_tx_sel:[9:8]=0b10
+	// param_phyd_tx_upd_rx_sel:[11:10]=0b10
+	// param_phyd_rx_en_ext_win:[15:12]=0b0110
+	// param_phyd_fifo_rst_sel:[18:16]=0b000
+	// param_phyd_fifo_sw_rst:[20:20]=0b0
+#define  DDR_PHY_REG_72_DATA  0b00000000000000000000000000000000
+	// param_phyd_phy_int_ack:[31:0]=0b00000000000000000000000000000000
+#define  DDR_PHY_REG_73_DATA  0b11111111111111111111111011110111
+	// param_phyd_phy_int_mask:[31:0]=0b11111111111111111111111011110111
+#define  DDR_PHY_REG_74_DATA  0b00000000000000000000000000011111
+	// param_phyd_calvl_rst_n:[0:0]=0b1
+	// param_phyd_pigtlvl_rst_n:[1:1]=0b1
+	// param_phyd_pirdlvl_rst_n:[2:2]=0b1
+	// param_phyd_piwdqlvl_rst_n:[3:3]=0b1
+	// param_phyd_wrlvl_rst_n:[4:4]=0b1
+#define  DDR_PHY_REG_75_DATA  0b00000000000000000000000000000001
+	// param_phyd_clk0_pol:[0:0]=0b1
+#define  DDR_PHY_REG_76_DATA  0b00000000000000000000000100000001
+	// param_phyd_tx_ca_oenz:[0:0]=0b1
+	// param_phyd_tx_ca_clk0_oenz:[8:8]=0b1
+#define  DDR_PHY_REG_77_DATA  0b00000000000000000000000100000000
+	// param_phya_reg_en_test:[0:0]=0b0
+	// param_phya_reg_tx_ca_test_en:[1:1]=0b0
+	// param_phya_reg_tx_ca_en_ca_loop_back:[2:2]=0b0
+	// param_phya_reg_tx_sel_4bit_mode_tx:[8:8]=0b1
+	// param_phya_reg_tx_gpio_in:[16:16]=0b0
+#define  DDR_PHY_REG_78_DATA  0b00000000000000000000000000010100
+	// param_phya_reg_rx_en_ca_train_mode:[0:0]=0b0
+	// param_phya_reg_rx_en_pream_train_mode:[1:1]=0b0
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode:[2:2]=0b1
+	// param_phya_reg_rx_en_rec_offset:[3:3]=0b0
+	// param_phya_reg_rx_sel_4bit_mode_rx:[4:4]=0b1
+#define  DDR_PHY_REG_80_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_rx_ddrdll_enautok:[0:0]=0b0
+	// param_phya_reg_rx_ddrdll_rstb:[1:1]=0b0
+	// param_phya_reg_rx_ddrdll_selckout:[5:4]=0b00
+	// param_phya_reg_rx_ddrdll_test:[7:6]=0b00
+	// param_phya_reg_rx_ddrdll_sel:[15:8]=0b00000000
+	// param_phya_reg_tx_ddrdll_enautok:[16:16]=0b0
+	// param_phya_reg_tx_ddrdll_rstb:[17:17]=0b0
+	// param_phya_reg_tx_ddrdll_selckout:[21:20]=0b00
+	// param_phya_reg_tx_ddrdll_test:[23:22]=0b00
+	// param_phya_reg_tx_ddrdll_sel:[31:24]=0b00000000
+#define  DDR_PHY_REG_81_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_tx_zq_cmp_en:[0:0]=0b0
+	// param_phya_reg_tx_zq_cmp_offset_cal_en:[1:1]=0b0
+	// param_phya_reg_tx_zq_ph_en:[2:2]=0b0
+	// param_phya_reg_tx_zq_pl_en:[3:3]=0b0
+	// param_phya_reg_tx_zq_step2_en:[4:4]=0b0
+	// param_phya_reg_tx_zq_cmp_offset:[12:8]=0b00000
+	// param_phya_reg_tx_zq_sel_vref:[20:16]=0b00000
+#define  DDR_PHY_REG_82_DATA  0b00000000000000000000100000001000
+	// param_phya_reg_tx_zq_golden_drvn:[4:0]=0b01000
+	// param_phya_reg_tx_zq_golden_drvp:[12:8]=0b01000
+	// param_phya_reg_tx_zq_drvn:[20:16]=0b00000
+	// param_phya_reg_tx_zq_drvp:[28:24]=0b00000
+#define  DDR_PHY_REG_83_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_tx_zq_en_test_aux:[0:0]=0b0
+	// param_phya_reg_tx_zq_en_test_mux:[1:1]=0b0
+	// param_phya_reg_sel_zq_high_swing:[2:2]=0b0
+	// param_phya_reg_zq_sel_test_out0:[7:4]=0b0000
+	// param_phya_reg_zq_sel_test_out1:[11:8]=0b0000
+	// param_phya_reg_tx_zq_sel_test_ana_in:[15:12]=0b0000
+	// param_phya_reg_tx_zq_sel_gpio_in:[17:16]=0b00
+#define  DDR_PHY_REG_84_DATA  0b00000000000000000000000000000101
+	// param_phya_reg_tune_damp_r:[3:0]=0b0101
+#define  DDR_PHY_REG_85_DATA  0b00000000000000000000000100000001
+	// param_phyd_sel_cke_oenz:[0:0]=0b1
+	// param_phyd_tx_dqsn_default_value:[8:8]=0b1
+	// param_phyd_tx_dqsp_default_value:[12:12]=0b0
+	// param_phyd_ddr4_2t_preamble:[16:16]=0b0
+#define  DDR_PHY_REG_86_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_zqcal_done:[0:0]=0b0
+#define  DDR_PHY_REG_87_DATA  0b00000000000000000000000000000000
+	// param_phyd_dbg_sel:[7:0]=0b00000000
+	// param_phyd_dbg_sel_en:[16:16]=0b0
+#define  DDR_PHY_REG_89_DATA  0b00000000000000000000000000000000
+	// param_phyd_reg_dfs_sel:[0:0]=0b0
+#define  DDR_PHY_REG_90_DATA  0b00000000001100110011001100110001
+	// param_phyd_ca_sw_dline_en:[0:0]=0b1
+	// param_phyd_byte0_wr_sw_dline_en:[4:4]=0b1
+	// param_phyd_byte1_wr_sw_dline_en:[5:5]=0b1
+	// param_phyd_byte0_wdqs_sw_dline_en:[8:8]=0b1
+	// param_phyd_byte1_wdqs_sw_dline_en:[9:9]=0b1
+	// param_phyd_byte0_rd_sw_dline_en:[12:12]=0b1
+	// param_phyd_byte1_rd_sw_dline_en:[13:13]=0b1
+	// param_phyd_byte0_rdg_sw_dline_en:[16:16]=0b1
+	// param_phyd_byte1_rdg_sw_dline_en:[17:17]=0b1
+	// param_phyd_byte0_rdqs_sw_dline_en:[20:20]=0b1
+	// param_phyd_byte1_rdqs_sw_dline_en:[21:21]=0b1
+#define  DDR_PHY_REG_91_DATA  0b00000000000000000000000000000000
+	// param_phyd_ca_raw_dline_upd:[0:0]=0b0
+	// param_phyd_byte0_wr_raw_dline_upd:[4:4]=0b0
+	// param_phyd_byte1_wr_raw_dline_upd:[5:5]=0b0
+	// param_phyd_byte0_wdqs_raw_dline_upd:[8:8]=0b0
+	// param_phyd_byte1_wdqs_raw_dline_upd:[9:9]=0b0
+	// param_phyd_byte0_rd_raw_dline_upd:[12:12]=0b0
+	// param_phyd_byte1_rd_raw_dline_upd:[13:13]=0b0
+	// param_phyd_byte0_rdg_raw_dline_upd:[16:16]=0b0
+	// param_phyd_byte1_rdg_raw_dline_upd:[17:17]=0b0
+	// param_phyd_byte0_rdqs_raw_dline_upd:[20:20]=0b0
+	// param_phyd_byte1_rdqs_raw_dline_upd:[21:21]=0b0
+#define  DDR_PHY_REG_92_DATA  0b00000000000000000000000000000000
+	// param_phyd_sw_dline_upd_req:[0:0]=0b0
+#define  DDR_PHY_REG_93_DATA  0b00000000000000000000000100000000
+	// param_phyd_sw_dfi_phyupd_req:[0:0]=0b0
+	// param_phyd_sw_dfi_phyupd_req_clr:[4:4]=0b0
+	// param_phyd_sw_phyupd_dline:[8:8]=0b1
+#define  DDR_PHY_REG_96_DATA  0b00000000000000100000000000010000
+	// param_phyd_dfi_wrlvl_req:[0:0]=0b0
+	// param_phyd_dfi_wrlvl_odt_en:[4:4]=0b1
+	// param_phyd_dfi_wrlvl_strobe_cnt:[19:16]=0b0010
+#define  DDR_PHY_REG_97_DATA  0b00000000000000000000000000000000
+	// param_phyd_dfi_rdglvl_req:[0:0]=0b0
+	// param_phyd_dfi_rdglvl_ddr3_mpr:[4:4]=0b0
+#define  DDR_PHY_REG_98_DATA  0b00000000000000000000000000000000
+	// param_phyd_dfi_rdlvl_req:[0:0]=0b0
+	// param_phyd_dfi_rdlvl_ddr3_mpr:[4:4]=0b0
+#define  DDR_PHY_REG_99_DATA  0b00000000000010010000010000000000
+	// param_phyd_dfi_wdqlvl_req:[0:0]=0b0
+	// param_phyd_dfi_wdqlvl_bist_data_en:[4:4]=0b0
+	// param_phyd_dfi_wdqlvl_vref_train_en:[10:10]=0b1
+	// param_phyd_dfi_wdqlvl_vref_wait_cnt:[23:16]=0b00001001
+#define  DDR_PHY_REG_100_DATA  0b00000000000000100001001000001110
+	// param_phyd_dfi_wdqlvl_vref_start:[6:0]=0b0001110
+	// param_phyd_dfi_wdqlvl_vref_end:[14:8]=0b0010010
+	// param_phyd_dfi_wdqlvl_vref_step:[19:16]=0b0010
+#define  DDR_PHY_REG_128_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_byte0_test_en:[0:0]=0b0
+	// param_phya_reg_tx_byte0_ddr_test:[15:8]=0b00000000
+	// param_phya_reg_rx_byte0_sel_test_in0:[19:16]=0b0000
+	// param_phya_reg_rx_byte0_sel_test_in1:[23:20]=0b0000
+#define  DDR_PHY_REG_129_DATA  0b00000000000000000000010001000000
+	// param_phya_reg_tx_byte0_en_rx_awys_on:[0:0]=0b0
+	// param_phya_reg_tx_byte0_sel_en_rx_dly:[5:4]=0b00
+	// param_phya_reg_rx_byte0_sel_en_rx_gen_rst:[6:6]=0b1
+	// param_phya_reg_byte0_mask_oenz:[8:8]=0b0
+	// param_phya_reg_tx_byte0_en_mask:[10:10]=0b1
+	// param_phya_reg_rx_byte0_sel_cnt_mode:[13:12]=0b00
+	// param_phya_reg_tx_byte0_sel_int_loop_back:[14:14]=0b0
+	// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated:[17:16]=0b00
+	// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline:[18:18]=0b0
+#define  DDR_PHY_REG_130_DATA  0b00000000000000000000000000000000
+	// param_phyd_reg_reserved_byte0:[31:0]=0b00000000000000000000000000000000
+#define  DDR_PHY_REG_136_DATA  0b00000000000000000000000000000000
+	// param_phya_reg_byte1_test_en:[0:0]=0b0
+	// param_phya_reg_tx_byte1_ddr_test:[15:8]=0b00000000
+	// param_phya_reg_rx_byte1_sel_test_in0:[19:16]=0b0000
+	// param_phya_reg_rx_byte1_sel_test_in1:[23:20]=0b0000
+#define  DDR_PHY_REG_137_DATA  0b00000000000000000000010001000000
+	// param_phya_reg_tx_byte1_en_rx_awys_on:[0:0]=0b0
+	// param_phya_reg_tx_byte1_sel_en_rx_dly:[5:4]=0b00
+	// param_phya_reg_rx_byte1_sel_en_rx_gen_rst:[6:6]=0b1
+	// param_phya_reg_byte1_mask_oenz:[8:8]=0b0
+	// param_phya_reg_tx_byte1_en_mask:[10:10]=0b1
+	// param_phya_reg_rx_byte1_sel_cnt_mode:[13:12]=0b00
+	// param_phya_reg_tx_byte1_sel_int_loop_back:[14:14]=0b0
+	// param_phya_reg_rx_byte1_sel_dqs_dly_for_gated:[17:16]=0b00
+	// param_phya_reg_tx_byte1_en_extend_oenz_gated_dline:[18:18]=0b0
+#define  DDR_PHY_REG_138_DATA  0b00000000000000000000000000000000
+	// param_phyd_reg_reserved_byte1:[31:0]=0b00000000000000000000000000000000
+#define  DDR_PHY_REG_0_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_ca_sel_lpddr4_pmos_ph_ca:[3:3]=0b0
+	// f0_param_phya_reg_tx_clk_sel_lpddr4_pmos_ph_clk:[4:4]=0b0
+	// f0_param_phya_reg_tx_sel_lpddr4_pmos_ph:[5:5]=0b0
+#define  DDR_PHY_REG_1_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_ca_drvn_de:[1:0]=0b00
+	// f0_param_phya_reg_tx_ca_drvp_de:[5:4]=0b00
+	// f0_param_phya_reg_tx_clk0_drvn_de:[9:8]=0b00
+	// f0_param_phya_reg_tx_clk0_drvp_de:[13:12]=0b00
+	// f0_param_phya_reg_tx_csb_drvn_de:[17:16]=0b00
+	// f0_param_phya_reg_tx_csb_drvp_de:[21:20]=0b00
+	// f0_param_phya_reg_tx_ca_en_tx_de:[24:24]=0b0
+	// f0_param_phya_reg_tx_clk0_en_tx_de:[28:28]=0b0
+	// f0_param_phya_reg_tx_csb_en_tx_de:[30:30]=0b0
+#define  DDR_PHY_REG_2_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_ca_sel_dly1t_ca:[22:0]=0b00000000000000000000000
+#define  DDR_PHY_REG_3_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_clk_sel_dly1t_clk0:[0:0]=0b0
+	// f0_param_phya_reg_tx_ca_sel_dly1t_cke0:[8:8]=0b0
+	// f0_param_phya_reg_tx_ca_sel_dly1t_csb0:[16:16]=0b0
+#define  DDR_PHY_REG_4_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_vref_en_free_offset:[0:0]=0b0
+	// f0_param_phya_reg_tx_vref_en_rangex2:[1:1]=0b0
+	// f0_param_phya_reg_tx_vref_sel_lpddr4divby2p5:[2:2]=0b0
+	// f0_param_phya_reg_tx_vref_sel_lpddr4divby3:[3:3]=0b0
+	// f0_param_phya_reg_tx_vref_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_tx_vref_sel:[20:16]=0b10000
+#define  DDR_PHY_REG_5_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_vrefca_en_free_offset:[0:0]=0b0
+	// f0_param_phya_reg_tx_vrefca_en_rangex2:[1:1]=0b0
+	// f0_param_phya_reg_tx_vrefca_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_tx_vrefca_sel:[20:16]=0b10000
+#define  DDR_PHY_REG_6_F0_DATA  0b00000000000000000000000000000010
+	// f0_param_phyd_tx_byte_dqs_extend:[2:0]=0b010
+#define  DDR_PHY_REG_7_F0_DATA  0b00000000000000000100000001000000
+	// f0_param_phya_reg_rx_byte0_odt_reg:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte0_sel_odt_reg_mode:[6:6]=0b1
+	// f0_param_phya_reg_rx_byte1_odt_reg:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte1_sel_odt_reg_mode:[14:14]=0b1
+#define  DDR_PHY_REG_64_F0_DATA  0b00000000000001000001000000000001
+	// f0_param_phya_reg_rx_byte0_en_lsmode:[0:0]=0b1
+	// f0_param_phya_reg_rx_byte0_hystr:[5:4]=0b00
+	// f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f0_param_phya_reg_rx_byte0_sel_odt_center_tap:[10:10]=0b0
+	// f0_param_phya_reg_byte0_en_rec_vol_mode:[12:12]=0b1
+	// f0_param_phya_reg_tx_byte0_force_en_lvstl_ph:[14:14]=0b0
+	// f0_param_phya_reg_rx_byte0_force_en_lvstl_odt:[16:16]=0b0
+	// f0_param_phya_reg_rx_byte0_en_trig_lvl_rangex2:[18:18]=0b1
+	// f0_param_phya_reg_rx_byte0_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR_PHY_REG_65_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_byte0_drvn_de_dq:[1:0]=0b00
+	// f0_param_phya_reg_tx_byte0_drvp_de_dq:[5:4]=0b00
+	// f0_param_phya_reg_tx_byte0_drvn_de_dqs:[9:8]=0b00
+	// f0_param_phya_reg_tx_byte0_drvp_de_dqs:[13:12]=0b00
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dq:[16:16]=0b0
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs:[20:20]=0b1
+#define  DDR_PHY_REG_66_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte0_sel_dly1t_dq:[8:0]=0b000000000
+	// f0_param_phya_reg_tx_byte0_sel_dly1t_dqs:[12:12]=0b0
+	// f0_param_phya_reg_tx_byte0_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR_PHY_REG_67_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f0_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR_PHY_REG_68_F0_DATA  0b00000000000000000000000000000100
+	// f0_param_phyd_reg_rx_byte0_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR_PHY_REG_69_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte0_dq0_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte0_dq1_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte0_dq2_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte0_dq3_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_70_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte0_dq4_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte0_dq5_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte0_dq6_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte0_dq7_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_71_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte0_dm_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte0_dqsn_offset:[19:16]=0b0000
+	// f0_param_phyd_reg_byte0_dqsp_offset:[27:24]=0b0000
+#define  DDR_PHY_REG_72_F0_DATA  0b00000000000000000000000000000011
+	// f0_param_phyd_tx_byte0_tx_oenz_extend:[2:0]=0b011
+#define  DDR_PHY_REG_80_F0_DATA  0b00000000000001000001000000000001
+	// f0_param_phya_reg_rx_byte1_en_lsmode:[0:0]=0b1
+	// f0_param_phya_reg_rx_byte1_hystr:[5:4]=0b00
+	// f0_param_phya_reg_rx_byte1_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f0_param_phya_reg_rx_byte1_sel_odt_center_tap:[10:10]=0b0
+	// f0_param_phya_reg_byte1_en_rec_vol_mode:[12:12]=0b1
+	// f0_param_phya_reg_tx_byte1_force_en_lvstl_ph:[14:14]=0b0
+	// f0_param_phya_reg_rx_byte1_force_en_lvstl_odt:[16:16]=0b0
+	// f0_param_phya_reg_rx_byte1_en_trig_lvl_rangex2:[18:18]=0b1
+	// f0_param_phya_reg_rx_byte1_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR_PHY_REG_81_F0_DATA  0b00000000000100000000000000000000
+	// f0_param_phya_reg_tx_byte1_drvn_de_dq:[1:0]=0b00
+	// f0_param_phya_reg_tx_byte1_drvp_de_dq:[5:4]=0b00
+	// f0_param_phya_reg_tx_byte1_drvn_de_dqs:[9:8]=0b00
+	// f0_param_phya_reg_tx_byte1_drvp_de_dqs:[13:12]=0b00
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dq:[16:16]=0b0
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs:[20:20]=0b1
+#define  DDR_PHY_REG_82_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte1_sel_dly1t_dq:[8:0]=0b000000000
+	// f0_param_phya_reg_tx_byte1_sel_dly1t_dqs:[12:12]=0b0
+	// f0_param_phya_reg_tx_byte1_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR_PHY_REG_83_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f0_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR_PHY_REG_84_F0_DATA  0b00000000000000000000000000000100
+	// f0_param_phyd_reg_rx_byte1_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR_PHY_REG_85_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte1_dq0_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte1_dq1_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte1_dq2_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte1_dq3_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_86_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte1_dq4_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte1_dq5_offset:[14:8]=0b0000000
+	// f0_param_phyd_reg_byte1_dq6_offset:[22:16]=0b0000000
+	// f0_param_phyd_reg_byte1_dq7_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_87_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_byte1_dm_offset:[6:0]=0b0000000
+	// f0_param_phyd_reg_byte1_dqsn_offset:[19:16]=0b0000
+	// f0_param_phyd_reg_byte1_dqsp_offset:[27:24]=0b0000
+#define  DDR_PHY_REG_88_F0_DATA  0b00000000000000000000000000000011
+	// f0_param_phyd_tx_byte1_tx_oenz_extend:[2:0]=0b011
+#define  DDR_PHY_REG_320_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_ca0_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_ca0_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_331_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_tx_ca22_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_332_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_cke0_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_cke0_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_333_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_csb0_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_cs0_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_334_F0_DATA  0b00000000000000000000010000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_resetz_sw:[6:0]=0b0000000
+	// f0_param_phyd_tx_reset_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_336_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_ca0_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_348_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_cke0_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_349_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_csb0_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_350_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_ca_tx_dline_code_resetz_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_351_F0_DATA  0b00001000000010000000010000000100
+	// f0_param_phya_reg_tx_ca_drvn_ca:[4:0]=0b00100
+	// f0_param_phya_reg_tx_ca_drvp_ca:[12:8]=0b00100
+	// f0_param_phya_reg_tx_ca_drvn_csb:[20:16]=0b01000
+	// f0_param_phya_reg_tx_ca_drvp_csb:[28:24]=0b01000
+#define  DDR_PHY_REG_352_F0_DATA  0b00001000000010000000100000001000
+	// f0_param_phya_reg_tx_clk_drvn_clkn0:[4:0]=0b01000
+	// f0_param_phya_reg_tx_clk_drvp_clkn0:[12:8]=0b01000
+	// f0_param_phya_reg_tx_clk_drvn_clkp0:[20:16]=0b01000
+	// f0_param_phya_reg_tx_clk_drvp_clkp0:[28:24]=0b01000
+#define  DDR_PHY_REG_384_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit0_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit1_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_385_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit2_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit3_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_386_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit4_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit5_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_387_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit6_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte0_bit7_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_388_F0_DATA  0b00000000000000000000011001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte0_bit8_data_shift:[13:8]=0b000110
+#define  DDR_PHY_REG_389_F0_DATA  0b00001011000000000000000000000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f0_param_phyd_tx_byte0_dqs_shift:[29:24]=0b001011
+#define  DDR_PHY_REG_390_F0_DATA  0b00001010000000000000100100000000
+	// f0_param_phyd_tx_byte0_oenz_dqs_shift:[13:8]=0b001001
+	// f0_param_phyd_tx_byte0_oenz_shift:[29:24]=0b001010
+#define  DDR_PHY_REG_391_F0_DATA  0b00000000000001000000011000000000
+	// f0_param_phyd_tx_byte0_oenz_dqs_extend:[11:8]=0b0110
+	// f0_param_phyd_tx_byte0_oenz_extend:[19:16]=0b0100
+#define  DDR_PHY_REG_392_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_393_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_394_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_395_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_396_F0_DATA  0b00000000000000000000000001000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR_PHY_REG_397_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR_PHY_REG_398_F0_DATA  0b00000000000000000000100000001000
+	// f0_param_phya_reg_tx_byte0_drvn_dq:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvp_dq:[12:8]=0b01000
+#define  DDR_PHY_REG_399_F0_DATA  0b00001000000010000000100000001000
+	// f0_param_phya_reg_tx_byte0_drvn_dqsn:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvp_dqsn:[12:8]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvn_dqsp:[20:16]=0b01000
+	// f0_param_phya_reg_tx_byte0_drvp_dqsp:[28:24]=0b01000
+#define  DDR_PHY_REG_400_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit0_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit1_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_401_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit2_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit3_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_402_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit4_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit5_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_403_F0_DATA  0b00000110010000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit6_data_shift:[13:8]=0b000110
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f0_param_phyd_tx_byte1_bit7_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_404_F0_DATA  0b00000000000000000000011001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f0_param_phyd_tx_byte1_bit8_data_shift:[13:8]=0b000110
+#define  DDR_PHY_REG_405_F0_DATA  0b00001011000000000000000000000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f0_param_phyd_tx_byte1_dqs_shift:[29:24]=0b001011
+#define  DDR_PHY_REG_406_F0_DATA  0b00001010000000000000100100000000
+	// f0_param_phyd_tx_byte1_oenz_dqs_shift:[13:8]=0b001001
+	// f0_param_phyd_tx_byte1_oenz_shift:[29:24]=0b001010
+#define  DDR_PHY_REG_407_F0_DATA  0b00000000000001000000011000000000
+	// f0_param_phyd_tx_byte1_oenz_dqs_extend:[11:8]=0b0110
+	// f0_param_phyd_tx_byte1_oenz_extend:[19:16]=0b0100
+#define  DDR_PHY_REG_408_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_409_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_410_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_411_F0_DATA  0b00000000010000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_412_F0_DATA  0b00000000000000000000000001000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR_PHY_REG_413_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR_PHY_REG_414_F0_DATA  0b00000000000000000000100000001000
+	// f0_param_phya_reg_tx_byte1_drvn_dq:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvp_dq:[12:8]=0b01000
+#define  DDR_PHY_REG_415_F0_DATA  0b00001000000010000000100000001000
+	// f0_param_phya_reg_tx_byte1_drvn_dqsn:[4:0]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvp_dqsn:[12:8]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvn_dqsp:[20:16]=0b01000
+	// f0_param_phya_reg_tx_byte1_drvp_dqsp:[28:24]=0b01000
+#define  DDR_PHY_REG_448_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_449_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_450_F0_DATA  0b00000000010000000100000000000000
+	// f0_param_phyd_reg_rx_byte0_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f0_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR_PHY_REG_451_F0_DATA  0b00000000000000000000101101000000
+	// f0_param_phyd_reg_tx_byte0_tx_dline_code_mask_ranka_sw:[6:0]=0b1000000
+	// f0_param_phyd_rx_byte0_mask_shift:[13:8]=0b001011
+#define  DDR_PHY_REG_452_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_rx_byte0_en_shift:[13:8]=0b000000
+	// f0_param_phyd_rx_byte0_odt_en_shift:[29:24]=0b000000
+#define  DDR_PHY_REG_453_F0_DATA  0b00000000000010000000111000001110
+	// f0_param_phyd_rx_byte0_en_extend:[3:0]=0b1110
+	// f0_param_phyd_rx_byte0_odt_en_extend:[11:8]=0b1110
+	// f0_param_phyd_rx_byte0_rden_to_rdvld:[20:16]=0b01000
+#define  DDR_PHY_REG_454_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte0_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_455_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte0_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte0_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_456_F0_DATA  0b01000000010000000000000000000000
+	// f0_param_phya_reg_rx_byte0_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_tx_byte0_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f0_param_phya_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR_PHY_REG_457_F0_DATA  0b00000000000100000000000000010000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dq:[4:0]=0b10000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dqs:[20:16]=0b10000
+	// f0_param_phya_reg_rx_byte0_trig_lvl_dqs_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_460_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_461_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_462_F0_DATA  0b00000000010000000100000000000000
+	// f0_param_phyd_reg_rx_byte1_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f0_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f0_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR_PHY_REG_463_F0_DATA  0b00000000000000000000101101000000
+	// f0_param_phyd_reg_tx_byte1_tx_dline_code_mask_ranka_sw:[6:0]=0b1000000
+	// f0_param_phyd_rx_byte1_mask_shift:[13:8]=0b001011
+#define  DDR_PHY_REG_464_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phyd_rx_byte1_en_shift:[13:8]=0b000000
+	// f0_param_phyd_rx_byte1_odt_en_shift:[29:24]=0b000000
+#define  DDR_PHY_REG_465_F0_DATA  0b00000000000010000000111000001110
+	// f0_param_phyd_rx_byte1_en_extend:[3:0]=0b1110
+	// f0_param_phyd_rx_byte1_odt_en_extend:[11:8]=0b1110
+	// f0_param_phyd_rx_byte1_rden_to_rdvld:[20:16]=0b01000
+#define  DDR_PHY_REG_466_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte1_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_467_F0_DATA  0b00000000000000000000000000000000
+	// f0_param_phya_reg_rx_byte1_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f0_param_phya_reg_rx_byte1_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_468_F0_DATA  0b01000000010000000000000000000000
+	// f0_param_phya_reg_rx_byte1_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f0_param_phya_reg_tx_byte1_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f0_param_phya_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR_PHY_REG_469_F0_DATA  0b00000000000100000000000000010000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dq:[4:0]=0b10000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dqs:[20:16]=0b10000
+	// f0_param_phya_reg_rx_byte1_trig_lvl_dqs_offset:[30:24]=0b0000000
+#ifdef F1_TEST
+#define  DDR_PHY_REG_0_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_ca_sel_lpddr4_pmos_ph_ca:[3:3]=0b0
+	// f1_param_phya_reg_tx_clk_sel_lpddr4_pmos_ph_clk:[4:4]=0b0
+	// f1_param_phya_reg_tx_sel_lpddr4_pmos_ph:[5:5]=0b0
+#define  DDR_PHY_REG_1_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_ca_drvn_de:[1:0]=0b00
+	// f1_param_phya_reg_tx_ca_drvp_de:[5:4]=0b00
+	// f1_param_phya_reg_tx_clk0_drvn_de:[9:8]=0b00
+	// f1_param_phya_reg_tx_clk0_drvp_de:[13:12]=0b00
+	// f1_param_phya_reg_tx_csb_drvn_de:[17:16]=0b00
+	// f1_param_phya_reg_tx_csb_drvp_de:[21:20]=0b00
+	// f1_param_phya_reg_tx_ca_en_tx_de:[24:24]=0b0
+	// f1_param_phya_reg_tx_clk0_en_tx_de:[28:28]=0b0
+	// f1_param_phya_reg_tx_csb_en_tx_de:[30:30]=0b0
+#define  DDR_PHY_REG_2_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_ca_sel_dly1t_ca:[22:0]=0b00000000000000000000000
+#define  DDR_PHY_REG_3_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_clk_sel_dly1t_clk0:[0:0]=0b0
+	// f1_param_phya_reg_tx_ca_sel_dly1t_cke0:[8:8]=0b0
+	// f1_param_phya_reg_tx_ca_sel_dly1t_csb0:[16:16]=0b0
+#define  DDR_PHY_REG_4_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_vref_en_free_offset:[0:0]=0b0
+	// f1_param_phya_reg_tx_vref_en_rangex2:[1:1]=0b0
+	// f1_param_phya_reg_tx_vref_sel_lpddr4divby2p5:[2:2]=0b0
+	// f1_param_phya_reg_tx_vref_sel_lpddr4divby3:[3:3]=0b0
+	// f1_param_phya_reg_tx_vref_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_tx_vref_sel:[20:16]=0b10000
+#define  DDR_PHY_REG_5_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_vrefca_en_free_offset:[0:0]=0b0
+	// f1_param_phya_reg_tx_vrefca_en_rangex2:[1:1]=0b0
+	// f1_param_phya_reg_tx_vrefca_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_tx_vrefca_sel:[20:16]=0b10000
+#define  DDR_PHY_REG_6_F1_DATA  0b00000000000000000000000000000010
+	// f1_param_phyd_tx_byte_dqs_extend:[2:0]=0b010
+#define  DDR_PHY_REG_7_F1_DATA  0b00000000000000000100000001000000
+	// f1_param_phya_reg_rx_byte0_odt_reg:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte0_sel_odt_reg_mode:[6:6]=0b1
+	// f1_param_phya_reg_rx_byte1_odt_reg:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte1_sel_odt_reg_mode:[14:14]=0b1
+#define  DDR_PHY_REG_64_F1_DATA  0b00000000000000000001000000000001
+	// f1_param_phya_reg_rx_byte0_en_lsmode:[0:0]=0b1
+	// f1_param_phya_reg_rx_byte0_hystr:[5:4]=0b00
+	// f1_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f1_param_phya_reg_rx_byte0_sel_odt_center_tap:[10:10]=0b0
+	// f1_param_phya_reg_byte0_en_rec_vol_mode:[12:12]=0b1
+	// f1_param_phya_reg_tx_byte0_force_en_lvstl_ph:[14:14]=0b0
+	// f1_param_phya_reg_rx_byte0_force_en_lvstl_odt:[16:16]=0b0
+	// f1_param_phya_reg_rx_byte0_en_trig_lvl_rangex2:[18:18]=0b0
+	// f1_param_phya_reg_rx_byte0_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR_PHY_REG_65_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_byte0_drvn_de_dq:[1:0]=0b00
+	// f1_param_phya_reg_tx_byte0_drvp_de_dq:[5:4]=0b00
+	// f1_param_phya_reg_tx_byte0_drvn_de_dqs:[9:8]=0b00
+	// f1_param_phya_reg_tx_byte0_drvp_de_dqs:[13:12]=0b00
+	// f1_param_phya_reg_tx_byte0_en_tx_de_dq:[16:16]=0b0
+	// f1_param_phya_reg_tx_byte0_en_tx_de_dqs:[20:20]=0b1
+#define  DDR_PHY_REG_66_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte0_sel_dly1t_dq:[8:0]=0b000000000
+	// f1_param_phya_reg_tx_byte0_sel_dly1t_dqs:[12:12]=0b0
+	// f1_param_phya_reg_tx_byte0_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR_PHY_REG_67_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f1_param_phya_reg_tx_byte0_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR_PHY_REG_68_F1_DATA  0b00000000000000000000000000000100
+	// f1_param_phyd_reg_rx_byte0_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR_PHY_REG_69_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte0_dq0_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte0_dq1_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte0_dq2_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte0_dq3_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_70_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte0_dq4_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte0_dq5_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte0_dq6_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte0_dq7_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_71_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte0_dm_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte0_dqsn_offset:[19:16]=0b0000
+	// f1_param_phyd_reg_byte0_dqsp_offset:[27:24]=0b0000
+#define  DDR_PHY_REG_72_F1_DATA  0b00000000000000000000000000000011
+	// f1_param_phyd_tx_byte0_tx_oenz_extend:[2:0]=0b011
+#define  DDR_PHY_REG_80_F1_DATA  0b00000000000000000001000000000001
+	// f1_param_phya_reg_rx_byte1_en_lsmode:[0:0]=0b1
+	// f1_param_phya_reg_rx_byte1_hystr:[5:4]=0b00
+	// f1_param_phya_reg_rx_byte1_sel_dqs_rec_vref_mode:[8:8]=0b0
+	// f1_param_phya_reg_rx_byte1_sel_odt_center_tap:[10:10]=0b0
+	// f1_param_phya_reg_byte1_en_rec_vol_mode:[12:12]=0b1
+	// f1_param_phya_reg_tx_byte1_force_en_lvstl_ph:[14:14]=0b0
+	// f1_param_phya_reg_rx_byte1_force_en_lvstl_odt:[16:16]=0b0
+	// f1_param_phya_reg_rx_byte1_en_trig_lvl_rangex2:[18:18]=0b0
+	// f1_param_phya_reg_rx_byte1_trig_lvl_en_free_offset:[20:20]=0b0
+#define  DDR_PHY_REG_81_F1_DATA  0b00000000000100000000000000000000
+	// f1_param_phya_reg_tx_byte1_drvn_de_dq:[1:0]=0b00
+	// f1_param_phya_reg_tx_byte1_drvp_de_dq:[5:4]=0b00
+	// f1_param_phya_reg_tx_byte1_drvn_de_dqs:[9:8]=0b00
+	// f1_param_phya_reg_tx_byte1_drvp_de_dqs:[13:12]=0b00
+	// f1_param_phya_reg_tx_byte1_en_tx_de_dq:[16:16]=0b0
+	// f1_param_phya_reg_tx_byte1_en_tx_de_dqs:[20:20]=0b1
+#define  DDR_PHY_REG_82_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte1_sel_dly1t_dq:[8:0]=0b000000000
+	// f1_param_phya_reg_tx_byte1_sel_dly1t_dqs:[12:12]=0b0
+	// f1_param_phya_reg_tx_byte1_sel_dly1t_mask_ranka:[16:16]=0b0
+#define  DDR_PHY_REG_83_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4divby2p5:[0:0]=0b0
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4divby3:[4:4]=0b0
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p5:[8:8]=0b0
+	// f1_param_phya_reg_tx_byte1_vref_sel_lpddr4x_voh0p6:[12:12]=0b0
+#define  DDR_PHY_REG_84_F1_DATA  0b00000000000000000000000000000100
+	// f1_param_phyd_reg_rx_byte1_resetz_dqs_offset:[3:0]=0b0100
+#define  DDR_PHY_REG_85_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte1_dq0_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte1_dq1_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte1_dq2_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte1_dq3_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_86_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte1_dq4_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte1_dq5_offset:[14:8]=0b0000000
+	// f1_param_phyd_reg_byte1_dq6_offset:[22:16]=0b0000000
+	// f1_param_phyd_reg_byte1_dq7_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_87_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_byte1_dm_offset:[6:0]=0b0000000
+	// f1_param_phyd_reg_byte1_dqsn_offset:[19:16]=0b0000
+	// f1_param_phyd_reg_byte1_dqsp_offset:[27:24]=0b0000
+#define  DDR_PHY_REG_88_F1_DATA  0b00000000000000000000000000000011
+	// f1_param_phyd_tx_byte1_tx_oenz_extend:[2:0]=0b011
+#define  DDR_PHY_REG_320_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_ca0_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_ca0_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_331_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_tx_ca22_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_332_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_cke0_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_cke0_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_333_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_csb0_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_cs0_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_334_F1_DATA  0b00000000000000000000010000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_resetz_sw:[6:0]=0b0000000
+	// f1_param_phyd_tx_reset_shift_sel:[13:8]=0b000100
+#define  DDR_PHY_REG_336_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_ca0_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_348_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_cke0_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_349_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_csb0_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_350_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_ca_tx_dline_code_resetz_raw:[6:0]=0b0000000
+#define  DDR_PHY_REG_351_F1_DATA  0b00001000000010000000010000000100
+	// f1_param_phya_reg_tx_ca_drvn_ca:[4:0]=0b00100
+	// f1_param_phya_reg_tx_ca_drvp_ca:[12:8]=0b00100
+	// f1_param_phya_reg_tx_ca_drvn_csb:[20:16]=0b01000
+	// f1_param_phya_reg_tx_ca_drvp_csb:[28:24]=0b01000
+#define  DDR_PHY_REG_352_F1_DATA  0b00001000000010000000100000001000
+	// f1_param_phya_reg_tx_clk_drvn_clkn0:[4:0]=0b01000
+	// f1_param_phya_reg_tx_clk_drvp_clkn0:[12:8]=0b01000
+	// f1_param_phya_reg_tx_clk_drvn_clkp0:[20:16]=0b01000
+	// f1_param_phya_reg_tx_clk_drvp_clkp0:[28:24]=0b01000
+#define  DDR_PHY_REG_384_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit0_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit1_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_385_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit2_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit3_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_386_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit4_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit5_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_387_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit6_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte0_bit7_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_388_F1_DATA  0b00000000000000000000011001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte0_bit8_data_shift:[13:8]=0b000110
+#define  DDR_PHY_REG_389_F1_DATA  0b00001011000000000000000000000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f1_param_phyd_tx_byte0_dqs_shift:[29:24]=0b001011
+#define  DDR_PHY_REG_390_F1_DATA  0b00001010000000000000100100000000
+	// f1_param_phyd_tx_byte0_oenz_dqs_shift:[13:8]=0b001001
+	// f1_param_phyd_tx_byte0_oenz_shift:[29:24]=0b001010
+#define  DDR_PHY_REG_391_F1_DATA  0b00000000000001000000011000000000
+	// f1_param_phyd_tx_byte0_oenz_dqs_extend:[11:8]=0b0110
+	// f1_param_phyd_tx_byte0_oenz_extend:[19:16]=0b0100
+#define  DDR_PHY_REG_392_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_393_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_394_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_395_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_396_F1_DATA  0b00000000000000000000000001000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR_PHY_REG_397_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR_PHY_REG_398_F1_DATA  0b00000000000000000000100000001000
+	// f1_param_phya_reg_tx_byte0_drvn_dq:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvp_dq:[12:8]=0b01000
+#define  DDR_PHY_REG_399_F1_DATA  0b00001000000010000000100000001000
+	// f1_param_phya_reg_tx_byte0_drvn_dqsn:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvp_dqsn:[12:8]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvn_dqsp:[20:16]=0b01000
+	// f1_param_phya_reg_tx_byte0_drvp_dqsp:[28:24]=0b01000
+#define  DDR_PHY_REG_400_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq0_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit0_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq1_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit1_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_401_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq2_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit2_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq3_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit3_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_402_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq4_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit4_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq5_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit5_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_403_F1_DATA  0b00000110010000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq6_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit6_data_shift:[13:8]=0b000110
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq7_sw:[22:16]=0b1000000
+	// f1_param_phyd_tx_byte1_bit7_data_shift:[29:24]=0b000110
+#define  DDR_PHY_REG_404_F1_DATA  0b00000000000000000000011001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq8_sw:[6:0]=0b1000000
+	// f1_param_phyd_tx_byte1_bit8_data_shift:[13:8]=0b000110
+#define  DDR_PHY_REG_405_F1_DATA  0b00001011000000000000000000000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_sw:[22:16]=0b0000000
+	// f1_param_phyd_tx_byte1_dqs_shift:[29:24]=0b001011
+#define  DDR_PHY_REG_406_F1_DATA  0b00001010000000000000100100000000
+	// f1_param_phyd_tx_byte1_oenz_dqs_shift:[13:8]=0b001001
+	// f1_param_phyd_tx_byte1_oenz_shift:[29:24]=0b001010
+#define  DDR_PHY_REG_407_F1_DATA  0b00000000000001000000011000000000
+	// f1_param_phyd_tx_byte1_oenz_dqs_extend:[11:8]=0b0110
+	// f1_param_phyd_tx_byte1_oenz_extend:[19:16]=0b0100
+#define  DDR_PHY_REG_408_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq0_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq1_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_409_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq2_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq3_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_410_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq4_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq5_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_411_F1_DATA  0b00000000010000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq6_raw:[6:0]=0b1000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq7_raw:[22:16]=0b1000000
+#define  DDR_PHY_REG_412_F1_DATA  0b00000000000000000000000001000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dq8_raw:[6:0]=0b1000000
+#define  DDR_PHY_REG_413_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsn_raw:[6:0]=0b0000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_dqsp_raw:[22:16]=0b0000000
+#define  DDR_PHY_REG_414_F1_DATA  0b00000000000000000000100000001000
+	// f1_param_phya_reg_tx_byte1_drvn_dq:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvp_dq:[12:8]=0b01000
+#define  DDR_PHY_REG_415_F1_DATA  0b00001000000010000000100000001000
+	// f1_param_phya_reg_tx_byte1_drvn_dqsn:[4:0]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvp_dqsn:[12:8]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvn_dqsp:[20:16]=0b01000
+	// f1_param_phya_reg_tx_byte1_drvp_dqsp:[28:24]=0b01000
+#define  DDR_PHY_REG_448_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_449_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_450_F1_DATA  0b00000000010000000100000000000000
+	// f1_param_phyd_reg_rx_byte0_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f1_param_phyd_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR_PHY_REG_451_F1_DATA  0b00000000000000000000101101000000
+	// f1_param_phyd_reg_tx_byte0_tx_dline_code_mask_ranka_sw:[6:0]=0b1000000
+	// f1_param_phyd_rx_byte0_mask_shift:[13:8]=0b001011
+#define  DDR_PHY_REG_452_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_rx_byte0_en_shift:[13:8]=0b000000
+	// f1_param_phyd_rx_byte0_odt_en_shift:[29:24]=0b000000
+#define  DDR_PHY_REG_453_F1_DATA  0b00000000000010000000111000001110
+	// f1_param_phyd_rx_byte0_en_extend:[3:0]=0b1110
+	// f1_param_phyd_rx_byte0_odt_en_extend:[11:8]=0b1110
+	// f1_param_phyd_rx_byte0_rden_to_rdvld:[20:16]=0b01000
+#define  DDR_PHY_REG_454_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte0_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_455_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte0_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte0_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_456_F1_DATA  0b01000000010000000000000000000000
+	// f1_param_phya_reg_rx_byte0_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_tx_byte0_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte0_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f1_param_phya_reg_rx_byte0_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR_PHY_REG_457_F1_DATA  0b00000000000100000000000000010000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dq:[4:0]=0b10000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dqs:[20:16]=0b10000
+	// f1_param_phya_reg_rx_byte0_trig_lvl_dqs_offset:[30:24]=0b0000000
+#define  DDR_PHY_REG_460_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq0_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq1_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq2_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq3_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_461_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq4_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq5_deskew_sw:[14:8]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq6_deskew_sw:[22:16]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq7_deskew_sw:[30:24]=0b0000000
+#define  DDR_PHY_REG_462_F1_DATA  0b00000000010000000100000000000000
+	// f1_param_phyd_reg_rx_byte1_rx_dq8_deskew_sw:[6:0]=0b0000000
+	// f1_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_sw:[15:8]=0b01000000
+	// f1_param_phyd_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_sw:[23:16]=0b01000000
+#define  DDR_PHY_REG_463_F1_DATA  0b00000000000000000000101101000000
+	// f1_param_phyd_reg_tx_byte1_tx_dline_code_mask_ranka_sw:[6:0]=0b1000000
+	// f1_param_phyd_rx_byte1_mask_shift:[13:8]=0b001011
+#define  DDR_PHY_REG_464_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phyd_rx_byte1_en_shift:[13:8]=0b000000
+	// f1_param_phyd_rx_byte1_odt_en_shift:[29:24]=0b000000
+#define  DDR_PHY_REG_465_F1_DATA  0b00000000000010000000111000001110
+	// f1_param_phyd_rx_byte1_en_extend:[3:0]=0b1110
+	// f1_param_phyd_rx_byte1_odt_en_extend:[11:8]=0b1110
+	// f1_param_phyd_rx_byte1_rden_to_rdvld:[20:16]=0b01000
+#define  DDR_PHY_REG_466_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte1_rx_dq0_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq1_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq2_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq3_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_467_F1_DATA  0b00000000000000000000000000000000
+	// f1_param_phya_reg_rx_byte1_rx_dq4_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq5_deskew_raw:[12:8]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq6_deskew_raw:[20:16]=0b00000
+	// f1_param_phya_reg_rx_byte1_rx_dq7_deskew_raw:[28:24]=0b00000
+#define  DDR_PHY_REG_468_F1_DATA  0b01000000010000000000000000000000
+	// f1_param_phya_reg_rx_byte1_rx_dq8_deskew_raw:[4:0]=0b00000
+	// f1_param_phya_reg_tx_byte1_tx_dline_code_mask_ranka_raw:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte1_rx_dqs_dlie_code_neg_ranka_raw:[22:16]=0b1000000
+	// f1_param_phya_reg_rx_byte1_rx_dqs_dlie_code_pos_ranka_raw:[30:24]=0b1000000
+#define  DDR_PHY_REG_469_F1_DATA  0b00000000000100000000000000010000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dq:[4:0]=0b10000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dq_offset:[14:8]=0b0000000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dqs:[20:16]=0b10000
+	// f1_param_phya_reg_rx_byte1_trig_lvl_dqs_offset:[30:24]=0b0000000
+#endif //F1_TEST
+
+void ddrc_init(void);
+void phy_init(void);
+void ctrl_init_high_patch(void);
+void ctrl_init_low_patch(void);
+//void ctrl_init_detect_dram_size(uint8_t * dram_cap_in_mbyte);
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte);
+
+#endif /* __DDR_PI_PHY_H__ */
diff --git a/firmware/plat/cv180x/include/ddr/ddr_pkg_info.h b/firmware/plat/cv180x/include/ddr/ddr_pkg_info.h
index e237e1e..b53d87a 100644
--- a/firmware/plat/cv180x/include/ddr/ddr_pkg_info.h
+++ b/firmware/plat/cv180x/include/ddr/ddr_pkg_info.h
@@ -29,6 +29,8 @@
 #define DDR_TYPE_DDR2			1
 #define DDR_TYPE_DDR3			2
 
+extern uint32_t ddr_data_rate;
+
 void read_ddr_pkg_info(void);
 uint8_t get_ddr_vendor(void);
 uint8_t get_ddr_capacity(void);
diff --git a/firmware/plat/cv180x/include/ddr/ddr_sys.h b/firmware/plat/cv180x/include/ddr/ddr_sys.h
index b35a686..120f8fa 100644
--- a/firmware/plat/cv180x/include/ddr/ddr_sys.h
+++ b/firmware/plat/cv180x/include/ddr/ddr_sys.h
@@ -90,6 +90,7 @@ enum train_mode {
 
 // void check_rd32(uintptr_t addr, uint32_t expected); //unused
 void ddr_debug_num_write(void);
+void ddr_patch_set(void);
 void cvx16_rdvld_train(void);
 void ddr_sys_suspend(void);
 void ddr_sys_resume(void);
diff --git a/firmware/plat/cv180x/include/ddr/regconfig.h b/firmware/plat/cv180x/include/ddr/regconfig.h
index b109cc5..dd3c35c 100644
--- a/firmware/plat/cv180x/include/ddr/regconfig.h
+++ b/firmware/plat/cv180x/include/ddr/regconfig.h
@@ -21,8 +21,14 @@ struct regpatch {
 // #define DDR_CFG_TYPE_DDR2	2
 // #define DDR_CFG_TYPE_DDR3_AUTO	3
 // #define DDR_CFG_TYPE_DDR2_AUTO	4
-
+#ifdef DDR2_3
+extern struct regpatch ddr3_1866_patch_regs[];
+extern uint32_t ddr3_1866_patch_regs_count;
+extern struct regpatch ddr2_1333_patch_regs[];
+extern uint32_t ddr2_1333_patch_regs_count;
+#else
 extern struct regpatch ddr_patch_regs[];
 extern uint32_t ddr_patch_regs_count;
+#endif
 
 #endif /* __REG_CFG_H__ */
diff --git a/firmware/plat/cv180x/include/rom_api.h b/firmware/plat/cv180x/include/rom_api.h
deleted file mode 100644
index 870cfae..0000000
--- a/firmware/plat/cv180x/include/rom_api.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#ifndef __ROM_SPI_H__
-#define __ROM_SPI_H__
-
-enum rsa_size {
-	RSA_2048_BITS,
-	RSA_4096_BITS,
-};
-
-// called from BL2
-int p_rom_api_load_image(void *buf, uint32_t offset, size_t image_size, int retry_num);
-uint32_t p_rom_api_image_crc(const void *buf, int len);
-int p_rom_api_flash_init(void);
-
-enum boot_src p_rom_api_get_boot_src(void);
-void p_rom_api_set_boot_src(enum boot_src src);
-int p_rom_api_get_number_of_retries(void);
-
-int p_rom_api_verify_rsa(void *message, size_t n, void *sig, enum rsa_size rsa_size);
-int p_rom_api_cryptodma_aes_decrypt(void *plain, const void *encrypted, uint64_t len, uint8_t *key, uint8_t *iv);
-
-#endif /* __ROM_SPI_H__ */
diff --git a/firmware/plat/cv180x/include/rom_api.h b/firmware/plat/cv180x/include/rom_api.h
new file mode 120000
index 0000000..3620024
--- /dev/null
+++ b/firmware/plat/cv180x/include/rom_api.h
@@ -0,0 +1 @@
+../../cv181x/include/rom_api.h
\ No newline at end of file
diff --git a/firmware/plat/cv180x/include/rtc.h b/firmware/plat/cv180x/include/rtc.h
deleted file mode 100644
index 67bb343..0000000
--- a/firmware/plat/cv180x/include/rtc.h
+++ /dev/null
@@ -1,49 +0,0 @@
-#ifndef __RTC_H__
-#define __RTC_H__
-
-#include "mmio.h"
-
-#define RTC_SYS_BASE 0x05000000
-#define RTC_MACRO_BASE (RTC_SYS_BASE + 0x00026400)
-#define RTC_CORE_SRAM_BASE (RTC_SYS_BASE + 0x00026800)
-#define RTC_CORE_SRAM_SIZE 0x0800 // 2KB
-#define RTC_IO_BASE (RTC_SYS_BASE + 0x00027000)
-
-#define REG_RTC_CTRL_BASE (RTC_SYS_BASE + 0x00025000)
-#define RTC_CTRL0_UNLOCKKEY 0x4
-#define RTC_CTRL0 0x8
-#define RTC_CTRL0_STATUS0 0xC
-#define RTCSYS_RST_CTRL 0x18
-#define RTC_FC_COARSE_EN 0x40
-#define RTC_FC_COARSE_CAL 0x44
-#define RTC_FC_FINE_EN 0x48
-#define RTC_FC_FINE_CAL 0x50
-#define RTC_POR_RST_CTRL 0xAC
-
-#define REG_RTC_BASE (RTC_SYS_BASE + 0x00026000)
-#define RTC_ANA_CALIB 0x0
-#define RTC_SEC_PULSE_GEN 0x4
-#define RTC_EN_PWR_WAKEUP 0xBC
-#define RTC_EN_SHDN_REQ 0xC0
-#define RTC_EN_PWR_CYC_REQ 0xC8
-#define RTC_EN_WARM_RST_REQ 0xCC
-#define RTC_EN_PWR_VBAT_DET 0xD0
-#define RTC_EN_WDT_RST_REQ 0xE0
-#define RTC_EN_SUSPEND_REQ 0xE4
-#define RTC_PG_REG 0xF0
-#define RTC_ST_ON_REASON 0xF8
-#define RTC_ST_OFF_REASON 0xFC
-
-#define RTC_INFO0 (REG_RTC_BASE + 0x1C)
-#define RTC_INFO1 (REG_RTC_BASE + 0x20)
-#define RTC_INFO2 (REG_RTC_BASE + 0x24)
-#define RTC_INFO3 (REG_RTC_BASE + 0x28)
-
-#define REG_RTC_ST_ON_REASON (REG_RTC_BASE + RTC_ST_ON_REASON)
-
-#define RTCSYS_F32KLESS_BASE (RTC_SYS_BASE + 0x0002A000)
-
-#define RTC_INTERNAL_32K 0
-#define RTC_EXTERNAL_32K 1
-
-#endif /* __RTC_H__ */
diff --git a/firmware/plat/cv180x/include/rtc.h b/firmware/plat/cv180x/include/rtc.h
new file mode 120000
index 0000000..d9f1fde
--- /dev/null
+++ b/firmware/plat/cv180x/include/rtc.h
@@ -0,0 +1 @@
+../../cv181x/include/rtc.h
\ No newline at end of file
diff --git a/firmware/plat/cv180x/multi.its b/firmware/plat/cv180x/multi.its
deleted file mode 100644
index 6c5cbe7..0000000
--- a/firmware/plat/cv180x/multi.its
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * U-Boot uImage source file with multiple kernels, ramdisks and FDT blobs
- */
-/dts-v1/;
-/ {
-  description = "Various kernels, ramdisks and FDT blobs";
-  #address-cells = <2>;
-  images {
-    kernel-1 {
-      description = "cvitek kernel";
-      data = /incbin/("./Image.lzma");
-      type = "kernel";
-      arch = "riscv";
-      os = "linux";
-      compression = "lzma";
-      load = <0x0 0x80200000>;
-      entry = <0x0 0x80200000>;
-      hash-2 {
-        algo = "crc32";
-      };
-    };
-    /*FDT*/
-    fdt-cv1800b_milkv_duo_sd {
-        description = "cvitek device tree - cv1800b_milkv_duo_sd";
-        data = /incbin/("./cv1800b_milkv_duo_sd.dtb");
-        type = "flat_dt";
-        arch = "riscv";
-        compression = "none";
-        hash-1 {
-            algo = "sha256";
-        };
-    };
-  };
-  /*CFG*/
-    configurations {
-        config-cv1800b_milkv_duo_sd {
-            description = "boot cvitek system with board cv1800b_milkv_duo_sd";
-            kernel = "kernel-1";
-            fdt = "fdt-cv1800b_milkv_duo_sd";
-        };
-    };
-};
\ No newline at end of file
diff --git a/firmware/plat/cv180x/platform.c b/firmware/plat/cv180x/platform.c
new file mode 100644
index 0000000..5ce3e69
--- /dev/null
+++ b/firmware/plat/cv180x/platform.c
@@ -0,0 +1,467 @@
+#include <cpu.h>
+#include <mmio.h>
+#include <debug.h>
+#include <assert.h>
+#include <errno.h>
+#include <bl_common.h>
+#include <platform.h>
+#include <delay_timer.h>
+#include <console.h>
+#include <string.h>
+#include <rom_api.h>
+
+#include "ddr_pkg_info.h"
+#include "rtc.h"
+
+void panic_handler(void)
+{
+	void *ra;
+
+	ATF_ERR = ATF_ERR_PLAT_PANIC;
+
+	ra = __builtin_return_address(0);
+	mmio_write_32(ATF_ERR_INFO0, ((uint64_t)ra) & 0xFFFFFFFFUL);
+
+	ERROR("ra=0x%lx\n", (uint64_t)ra);
+
+	__system_reset("panic", -1);
+	__builtin_unreachable();
+}
+
+void __system_reset(const char *file, unsigned int line)
+{
+	ATF_ERR = ATF_ERR_PLAT_SYSTEM_RESET;
+	ERROR("RESET:%s:%d\n", file, line);
+
+	console_flush();
+
+	ATF_STATE = ATF_STATE_RESET_WAIT;
+	mdelay(5000);
+
+	// enable rtc wdt reset
+	mmio_write_32(0x050260E0, 0x0001); //enable rtc_core wathdog reset enable
+	mmio_write_32(0x050260C8, 0x0001); //enable rtc_core power cycle   enable
+
+	// sw delay 100us
+	ATF_STATE = ATF_STATE_RESET_RTC_WAIT;
+	udelay(100);
+
+	// mmio_write_32(0x05025018,0x00FFFFFF); //Mercury rtcsys_rstn_src_sel
+	mmio_write_32(0x050250AC, 0x00000000); //cv181x rtcsys_rstn_src_sel
+	mmio_write_32(0x05025004, 0x0000AB18);
+	mmio_write_32(0x05025008, 0x00400040); //enable rtc_ctrl wathdog reset enable
+
+	// printf("Enable TOP_WDT\n");
+	// mmio_write_32(0x03010004,0x00000000); //config watch dog 2.6ms
+	// mmio_write_32(0x03010004,0x00000022); //config watch dog 166ms
+	mmio_write_32(0x03010004, 0x00000066); //config watch dog 166ms
+	mmio_write_32(0x0301001c, 0x00000020);
+	mmio_write_32(0x0301000c, 0x00000076);
+	mmio_write_32(0x03010000, 0x00000011);
+
+	// ROM_PWR_CYC
+	if (get_sw_info()->reset_type == 1) {
+		ATF_ERR = ATF_ERR_PLAT_SYSTEM_PWR_CYC;
+		// printf("Issue RTCSYS_PWR_CYC\n");
+
+		// wait pmu state to ON
+		while (mmio_read_32(0x050260D4) != 0x00000003) {
+			;
+		}
+
+		mmio_write_32(0x05025008, 0x00080008);
+	}
+
+	while (1)
+		;
+
+	__builtin_unreachable();
+}
+
+void reset_c906l(uintptr_t reset_address)
+{
+	NOTICE("RSC.\n");
+
+	mmio_clrbits_32(0x3003024, 1 << 6);
+
+	mmio_setbits_32(SEC_SYS_BASE + 0x04, 1 << 13);
+	mmio_write_32(SEC_SYS_BASE + 0x20, reset_address);
+	mmio_write_32(SEC_SYS_BASE + 0x24, reset_address >> 32);
+
+	mmio_setbits_32(0x3003024, 1 << 6);
+}
+
+void setup_dl_flag(void)
+{
+	uint32_t v = p_rom_api_get_boot_src();
+
+	switch (v) {
+	case BOOT_SRC_SD:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, MAGIC_NUM_SD_DL);
+		break;
+	case BOOT_SRC_USB:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, MAGIC_NUM_USB_DL);
+		break;
+	default:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, v);
+		break;
+	}
+}
+
+void config_core_power(uint32_t low_period)
+{
+	/*
+	 * low_period = 0x42; // 0.90V
+	 * low_period = 0x48; // 0.93V
+	 * low_period = 0x4F; // 0.96V
+	 * low_period = 0x58; // 1.00V
+	 * low_period = 0x5C; // 1.02V
+	 * low_period = 0x62; // 1.05V
+	 * low_period = 0x62; // 1.05V
+	 */
+	mmio_write_32(PWM0_BASE + PWM_HLPERIOD0, low_period);
+	mmio_write_32(PWM0_BASE + PWM_PERIOD0, 0x64);
+	mmio_write_32(PINMUX_BASE + 0xA4, 0x0); // set pinmux for pwm0
+	mmio_write_32(PWM0_BASE + PWM_START, 0x1); // enable bit0:pwm0
+	mmio_write_32(PWM0_BASE + PWM_OE, 0x1); // output enable bit0:pwm0
+	mdelay(10);
+}
+
+void sys_switch_all_to_pll(void)
+{
+	// Switch all clocks to PLL
+	mmio_write_32(0x03002030, 0x0); // REG_CLK_BYPASS_SEL0_REG
+	mmio_write_32(0x03002034, 0x0); // REG_CLK_BYPASS_SEL1_REG
+}
+
+// #ifdef OD_CLK_SEL
+void sys_pll_od(void)
+{
+	// OD clk setting
+	uint32_t value;
+	uint32_t byp0_value;
+
+	uint32_t pll_syn_set[] = {
+		614400000, // set apll synthesizer  98.304 M
+		610080582, // set disp synthesizer  99 M
+		610080582, // set cam0 synthesizer  99 M
+		//586388132, // set cam1 synthesizer  103 M
+		615164587, // set cam1 synthesizer  98.18181818 M
+	};
+
+	uint32_t pll_csr[] = {
+		0x00208201, // set apll *16/2 (786.432 MHz)
+		0x00188101, // set disp *12/1 (1188 MHz)
+		// 0x00188101, // set cam0 *12/1 (1188 MHz)
+		0x00308201, // set cam0 *24/2 (1188 MHz)
+		//0x00148101, // set cam1 *10/1 (1030 MHz)
+		0x00168101, // set cam1 *11/1 (1080 MHz)
+	};
+
+	NOTICE("PLLS/OD.\n");
+
+	// set vddc for OD clock
+	config_core_power(0x58); //1.00V
+
+	// store byp0 value
+	byp0_value = mmio_read_32(0x03002030);
+
+	// switch clock to xtal
+	mmio_write_32(0x03002030, 0xffffffff);
+	mmio_write_32(0x03002034, 0x0000003f);
+
+	//set mipipll = 900MHz
+	mmio_write_32(0x03002808, 0x05488101);
+
+	// set synthersizer clock
+	mmio_write_32(REG_PLL_G2_SSC_SYN_CTRL, 0x3F); // enable synthesizer clock enable,
+		// [0]: 1: MIPIMPLL(900)/1=900MHz,
+		//      0: MIPIMPLL(900)/2=450MHz
+
+	for (uint32_t i = 0; i < 4; i++) {
+		mmio_write_32(REG_APLL_SSC_SYN_SET + 0x10 * i, pll_syn_set[i]); // set pll_syn_set
+
+		value = mmio_read_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i);
+		value |= 1; // [0]: sw update (w1t: write one toggle)
+		value &= ~(1 << 4); // [4]: bypass = 0
+		mmio_write_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i, value);
+
+		mmio_write_32(REG_APLL0_CSR + 4 * i, pll_csr[i]); // set pll_csr
+	}
+
+	value = mmio_read_32(REG_PLL_G2_CTRL);
+	value = value & (~0x00011111);
+	mmio_write_32(REG_PLL_G2_CTRL, value); //clear all pll PD
+
+#ifdef __riscv
+	// set mpll = 1050MHz
+	mmio_write_32(0x03002908, 0x05548101);
+
+	// set clk_sel_23: [23] clk_sel for clk_c906_0 = 1 (DIV_IN0_SRC_MUX)
+	// set clk_sel_24: [24] clk_sel for clk_c906_1 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x01800000);
+
+	// set div, src_mux of clk_c906_0: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll), 1050/1 = 1050MHz
+	mmio_write_32(0x03002130, 0x00010309);
+
+	// set div, src_mux of clk_c906_1: [20:16]div_factor=1, [9:8]clk_src = 1 (a0pll), 786.432/1 = 786.432MHz
+	mmio_write_32(0x03002138, 0x00010109);
+#else
+	// set mpll = 1000MHz
+	mmio_write_32(0x03002908, 0x05508101);
+
+	// set clk_sel_0: [0] clk_sel for clk_a53 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x00000001);
+
+	// set div, src_mux of clk_a53: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll)
+	mmio_write_32(0x03002040, 0x00010309);
+#endif
+
+	// set tpll = 1400MHz
+	mmio_write_32(0x0300290C, 0x07708101);
+
+	mmio_write_32(0x03002048, 0x00020109); //clk_cpu_axi0 = DISPPLL(1188) / 2
+	mmio_write_32(0x03002054, 0x00020009); //clk_tpu = TPLL(1400) / 2 = 700MHz
+	mmio_write_32(0x03002064, 0x00080009); //clk_emmc = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002088, 0x00080009); //clk_spi_nand = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002098, 0x00200009); //clk_sdma_aud0 = APLL(786.432) / 32 = 24.576MHz
+	mmio_write_32(0x03002120, 0x000F0009); //clk_pwm_src = FPLL(1500) / 15 = 100MHz
+	mmio_write_32(0x030020A8, 0x00010009); //clk_uart -> clk_cam0_200 = XTAL(25) / 1 = 25MHz
+	mmio_write_32(0x030020E4, 0x00030209); //clk_axi_video_codec = CAM1PLL(1080) / 3 = 360MHz
+	mmio_write_32(0x030020EC, 0x00020109); //clk_vc_src0 = MIPIPLL(900) / 2 = 450MHz
+	mmio_write_32(0x030020C8, 0x00030009); //clk_axi_vip = MIPIPLL(900) / 3 = 300MHz
+	mmio_write_32(0x030020D0, 0x00060309); //clk_src_vip_sys_0 = FPLL(1500) / 6 = 250MHz
+	mmio_write_32(0x030020D8, 0x00040209); //clk_src_vip_sys_1 = DISPPLL(1188)/ 4 = 297MHz
+	mmio_write_32(0x03002110, 0x00020209); //clk_src_vip_sys_2 = DISPPLL(1188) / 2 = 594MHz
+	//mmio_write_32(0x03002140, 0x00020009); //clk_src_vip_sys_3 = MIPIPLL(900) / 2 = 450MHz
+	mmio_write_32(0x03002144, 0x00030309); //clk_src_vip_sys_4 = FPLL(1500) / 3 = 500MHz
+
+	// set hsperi clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x030020B8, 0x00050009); //--> CLK_AXI4
+
+	// set rtcsys clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x0300212C, 0x00050009); // CLK_SRC_RTC_SYS_0
+
+	// disable powerdown, mipimpll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028A0, 0x4);
+
+	// disable powerdown, cam0pll_d2_pd[1]/cam0pll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028AC, 0x6);
+
+	//wait for pll stable
+	udelay(200);
+
+	// switch clock to PLL from xtal except clk_axi4 & clk_spi_nand
+	byp0_value &= (1 << 8 | //clk_spi_nand
+		       1 << 19 //clk_axi4
+	);
+	mmio_write_32(0x03002030, byp0_value); // REG_CLK_BYPASS_SEL0_REG
+	mmio_write_32(0x03002034, 0x0); // REG_CLK_BYPASS_SEL1_REG
+}
+// #endif
+
+void sys_pll_nd(void)
+{
+	// ND clk setting
+	uint32_t value;
+	uint32_t byp0_value;
+
+	uint32_t pll_syn_set[] = {
+		614400000, // set apll synthesizer  98.304 M
+		610080582, // set disp synthesizer  99 M
+		610080582, // set cam0 synthesizer  99 M
+		615164587, // set cam1 synthesizer  98.18181818 M
+	};
+
+	uint32_t pll_csr[] = {
+		0x00128201, // set apll *9/2 (442.368 MHz)
+		0x00188101, // set disp *12/1 (1188 MHz)
+		// 0x00188101, // set cam0 *12/1 (1188 MHz)
+		0x00308201, // set cam0 *24/2 (1188 MHz)
+		0x00168101, // set cam1 *11/1 (1080 MHz)
+	};
+
+	NOTICE("PLLS.\n");
+
+	// store byp0 value
+	byp0_value = mmio_read_32(0x03002030);
+
+	// switch clock to xtal
+	mmio_write_32(0x03002030, 0xffffffff);
+	mmio_write_32(0x03002034, 0x0000003f);
+
+	//set mipipll = 900MHz
+	mmio_write_32(0x03002808, 0x05488101);
+
+	// set synthersizer clock
+	mmio_write_32(REG_PLL_G2_SSC_SYN_CTRL, 0x3F); // enable synthesizer clock enable,
+		// [0]: 1: MIPIMPLL(900)/1=900MHz,
+		//      0: MIPIMPLL(900)/2=450MHz
+
+	for (uint32_t i = 0; i < 4; i++) {
+		mmio_write_32(REG_APLL_SSC_SYN_SET + 0x10 * i, pll_syn_set[i]); // set pll_syn_set
+
+		value = mmio_read_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i);
+		value |= 1; // [0]: sw update (w1t: write one toggle)
+		value &= ~(1 << 4); // [4]: bypass = 0
+		mmio_write_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i, value);
+
+		mmio_write_32(REG_APLL0_CSR + 4 * i, pll_csr[i]); // set pll_csr
+	}
+
+	value = mmio_read_32(REG_PLL_G2_CTRL);
+	value = value & (~0x00011111);
+	mmio_write_32(REG_PLL_G2_CTRL, value); //clear all pll PD
+
+#ifdef __riscv
+	// set mpll = 850MHz
+	mmio_write_32(0x03002908, 0x00448101);
+
+	// set clk_sel_23: [23] clk_sel for clk_c906_0 = 1 (DIV_IN0_SRC_MUX)
+	// set clk_sel_24: [24] clk_sel for clk_c906_1 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x01800000);
+
+	// set div, src_mux of clk_c906_0: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll), 850/1 = 850MHz
+	mmio_write_32(0x03002130, 0x00010309);
+
+	// set div, src_mux of clk_c906_1: [20:16]div_factor=2, [9:8]clk_src = 2 (disppll), 1188/2 = 594MHz
+	mmio_write_32(0x03002138, 0x00020209);
+#else
+	// set mpll = 800MHz
+	mmio_write_32(0x03002908, 0x00408101);
+
+	// set clk_sel_0: [0] clk_sel for clk_a53 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x00000001);
+
+	// set div, src_mux of clk_a53: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll)
+	mmio_write_32(0x03002040, 0x00010309);
+#endif
+
+	// set tpll = 850MHz
+	mmio_write_32(0x0300290C, 0x00448101);
+
+	mmio_write_32(0x03002048, 0x00030009); //clk_cpu_axi0 = FPLL(1500) / 3
+	mmio_write_32(0x03002054, 0x00030309); //clk_tpu = FPLL(1500) / 3 = 500MHz
+	mmio_write_32(0x03002064, 0x00080009); //clk_emmc = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002088, 0x00080009); //clk_spi_nand = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002098, 0x00120009); //clk_sdma_aud0 = APLL(442.368) / 18 = 24.576MHz
+	mmio_write_32(0x03002120, 0x000F0009); //clk_pwm_src = FPLL(1500) / 15 = 100MHz
+	mmio_write_32(0x030020A8, 0x00010009); //clk_uart -> clk_cam0_200 = XTAL(25) / 1 = 25MHz
+	mmio_write_32(0x030020E4, 0x00030109); //clk_axi_video_codec = MIPIPLL(900) / 3 = 300MHz
+	mmio_write_32(0x030020EC, 0x00040309); //clk_vc_src0 = FPLL(1500) / 4 = 375MHz
+	mmio_write_32(0x030020C8, 0x00030009); //clk_axi_vip = MIPIPLL(900) / 3 = 300MHz
+	mmio_write_32(0x030020D0, 0x00060209); //clk_src_vip_sys_0 = DISPPLL(1188) / 6 = 198MHz
+	mmio_write_32(0x030020D8, 0x00060209); //clk_src_vip_sys_1 = DISPPLL(1188) / 6 = 198MHz
+	mmio_write_32(0x03002110, 0x00020209); //clk_src_vip_sys_2 = DISPPLL(1188) / 2 = 594MHz
+	//mmio_write_32(0x03002140, 0x00030009); //clk_src_vip_sys_3 = MIPIPLL(900) / 3 = 300MHz
+	mmio_write_32(0x03002144, 0x00030209); //clk_src_vip_sys_4 = DISPPLL(1188) / 3 = 396MHz
+
+	// set hsperi clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x030020B8, 0x00050009); //--> CLK_AXI4
+
+	// set rtcsys clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x0300212C, 0x00050009); // CLK_SRC_RTC_SYS_0
+
+	// disable powerdown, mipimpll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028A0, 0x4);
+
+	// disable powerdown, cam0pll_d2_pd[1]/cam0pll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028AC, 0x6);
+
+	//wait for pll stable
+	udelay(200);
+
+	// switch clock to PLL from xtal except clk_axi4 & clk_spi_nand
+	byp0_value &= (1 << 8 | //clk_spi_nand
+		       1 << 19 //clk_axi4
+	);
+	mmio_write_32(0x03002030, byp0_value); // REG_CLK_BYPASS_SEL0_REG
+	mmio_write_32(0x03002034, 0x0); // REG_CLK_BYPASS_SEL1_REG
+}
+
+void sys_pll_init(void)
+{
+	sys_pll_nd();
+	NOTICE("PLLE.\n");
+}
+
+void sys_pll_init_od_sel(void)
+{
+	uint8_t pkg = get_pkg();
+
+	switch (pkg) {
+	case PKG_QFN88:
+		NOTICE("pkg QFN88\n");
+		sys_pll_od();
+		break;
+	case PKG_QFN68:
+		NOTICE("QFN68: OD UNSUPPORTED!\n");
+		sys_pll_nd();
+		break;
+	default:
+		NOTICE("unknown pkg=%d\n", pkg);
+		sys_pll_od();
+	}
+	NOTICE("PLLE.\n");
+}
+
+void switch_rtc_mode_1st_stage(void)
+{
+	// TBD
+}
+
+void switch_rtc_mode_2nd_stage(void)
+{
+	uint32_t read_data;
+	uint32_t write_data;
+	// TBD
+	// mdelay(50);
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0_STATUS0);
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	// reg_rtc_mode = rtc_ctrl0[10]
+	write_data = 0x0C000000 | (read_data & 0xfffffbff);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data);
+	//DA_SOC_READY = 1
+	mmio_write_32(RTC_MACRO_BASE + 0x8C, 0x01);
+	//DA_SOC_READY = 0
+	mmio_write_32(RTC_MACRO_BASE + 0x8C, 0x00);
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	// reg_clk32k_cg_en = rtc_ctrl0[11] -> 1
+	write_data = 0x0C000000 | (read_data & 0xffffffff) | (0x1 << 11);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data); //rtc_ctrl0
+	NOTICE("Use internal 32k\n");
+}
+
+void set_rtc_en_registers(void)
+{
+	uint32_t write_data;
+	uint32_t read_data;
+
+	read_data = mmio_read_32(REG_RTC_BASE + RTC_ST_ON_REASON);
+	NOTICE("st_on_reason=%x\n", read_data);
+	read_data = mmio_read_32(REG_RTC_BASE + RTC_ST_OFF_REASON);
+	NOTICE("st_off_reason=%x\n", read_data);
+
+	mmio_write_32(REG_RTC_BASE + RTC_EN_SHDN_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_SHDN_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_BASE + RTC_EN_PWR_CYC_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_PWR_CYC_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WDT_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WDT_RST_REQ) != 0x01)
+		;
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_POR_RST_CTRL, 0X1);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	write_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	write_data = 0xffff0000 | write_data | (0x1 << 11) | (0x01 << 6);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data);
+	mmio_clrbits_32(REG_RTC_BASE + RTC_EN_PWR_VBAT_DET, BIT(2));
+}
+
+void apply_analog_trimming_data(void)
+{
+}
diff --git a/firmware/plat/cv180x/platform.mk b/firmware/plat/cv180x/platform.mk
index fcfae0e..5fcc2d3 100644
--- a/firmware/plat/cv180x/platform.mk
+++ b/firmware/plat/cv180x/platform.mk
@@ -48,7 +48,7 @@ INCLUDES += \
 	${STDLIB_INCLUDES} \
 	${CRYPT_INCLUDES}
 
-#BL_COMMON_SOURCES = \
+BL_COMMON_SOURCES = \
 	${CPU_SOURCES} \
 	lib/tf_printf/tf_printf.c \
 	plat/${CHIP_ARCH}/platform.c \
@@ -56,12 +56,12 @@ INCLUDES += \
 	${STDLIB_SRCS} \
 	${CRYPT_SOURCES}
 
-#DECOMPRESSION_SOURCES = \
+DECOMPRESSION_SOURCES = \
 	lib/lzma/LzmaDec.c \
 	lib/lz4/lz4_all.c \
 	lib/lz4/xxhash.c
 
-#BL2_SRCS = \
+BL2_SRCS = \
 	${BL_COMMON_SOURCES} \
 	plat/${CHIP_ARCH}/platform_device.c \
 	plat/${CHIP_ARCH}/bl2/bl2_opt.c \
@@ -79,7 +79,7 @@ BL2_SOURCES = \
 	${BL2_SRCS} \
 	plat/${CHIP_ARCH}/bl2/bl2_main.c
 
-#include plat/${CHIP_ARCH}/ddr/ddr.mk
+include plat/${CHIP_ARCH}/ddr/ddr.mk
 
 BL2_LINKERFILE := plat/${CHIP_ARCH}/bl2/bl2.ld.S
-BL2_RLS_OBJS := plat/${CHIP_ARCH}/bl2_objs/${PROJECT_FULLNAME}/bl2/*.o
+#BL2_RLS_OBJS := plat/${CHIP_ARCH}/bl2_objs/${PROJECT_FULLNAME}/bl2/*.o
diff --git a/firmware/plat/cv180x/platform_device.c b/firmware/plat/cv180x/platform_device.c
new file mode 100644
index 0000000..35ca90a
--- /dev/null
+++ b/firmware/plat/cv180x/platform_device.c
@@ -0,0 +1,115 @@
+#include <cpu.h>
+#include <mmio.h>
+#include <debug.h>
+#include <assert.h>
+#include <errno.h>
+#include <bl_common.h>
+#include <platform.h>
+#include <delay_timer.h>
+#include <console.h>
+#include <string.h>
+
+#include <cv180x_pinlist_swconfig.h>
+#include <cv180x_reg_fmux_gpio.h>
+// #include <cv180x_reg_ioblk_G7.h>
+// #include <cv180x_reg_ioblk_G10.h>
+
+#include <security/security.h>
+
+// #include <cv_spinor.h>
+// #include <cv_spi_nand.h>
+// #include <spi_nand.h>
+#include <cv_usb.h>
+// #include <cv_sd.h>
+#include <cv_usb.h>
+// #include <sd.h>
+// #include <ff.h>
+
+#define PINMUX_MASK(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_MASK
+#define PINMUX_OFFSET(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_OFFSET
+#define PINMUX_VALUE(PIN_NAME, FUNC_NAME) PIN_NAME##__##FUNC_NAME
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME)                                                                             \
+	mmio_clrsetbits_32(PINMUX_BASE + FMUX_GPIO_FUNCSEL_##PIN_NAME,                                                 \
+			   PINMUX_MASK(PIN_NAME) << PINMUX_OFFSET(PIN_NAME), PINMUX_VALUE(PIN_NAME, FUNC_NAME))
+
+
+// Field of EFUSE_CUSTOMER
+#define EC_FASTBOOT_SHIFT 0x0
+#define EC_FASTBOOT_MASK 0x7
+
+#define EC_GPIO_VALUE_SHIFT 0x4
+#define EC_GPIO_VALUE_MASK 0x1
+
+#define EC_FMUX_VALUE_SHIFT 0x5
+#define EC_FMUX_VALUE_MASK 0x7
+
+#define EC_FMUX_OFFSET_SHIFT 0x8
+#define EC_FMUX_OFFSET_MASK 0xFF
+
+#define EC_GPIO_OFFSET_SHIFT 0x10
+#define EC_GPIO_OFFSET_MASK 0x1F
+
+#define EC_GPIO_PORT_SHIFT 0x15
+#define EC_GPIO_PORT_MASK 0x7
+
+uint8_t gpio_in_value(uint32_t value)
+{
+	uint32_t fmux_value;
+	uint32_t fmux_offset;
+	uint32_t gpio_offset;
+	uint32_t gpio_port;
+	uint32_t gpio_reg_addr;
+	uint32_t gpio_value;
+	uint32_t select_value;
+
+	fmux_value = GET_FIELD(value, EC_FMUX_VALUE_MASK, EC_FMUX_VALUE_SHIFT);
+	fmux_offset = GET_FIELD(value, EC_FMUX_OFFSET_MASK, EC_FMUX_OFFSET_SHIFT);
+	gpio_offset = GET_FIELD(value, EC_GPIO_OFFSET_MASK, EC_GPIO_OFFSET_SHIFT);
+	gpio_port = GET_FIELD(value, EC_GPIO_PORT_MASK, EC_GPIO_PORT_SHIFT);
+	gpio_value = GET_FIELD(value, EC_GPIO_VALUE_MASK, EC_GPIO_VALUE_SHIFT);
+
+	mmio_write_32(PINMUX_BASE + fmux_offset * 4, fmux_value);
+	udelay(10);
+
+	if (gpio_port <= 3)
+		gpio_reg_addr = GPIO_BASE + gpio_port * 0x1000 + 0x50;
+	else
+		gpio_reg_addr = RTC_GPIO_BASE + 0x50;
+
+	select_value = (mmio_read_32(gpio_reg_addr) >> gpio_offset) & 0x1;
+
+	return gpio_value ? !select_value : select_value;
+}
+
+#define TOP_BASE 0x03000000
+#define EFUSE_BASE (TOP_BASE + 0x00050000)
+#define EFUSE_SHADOW_REG (EFUSE_BASE + 0x100)
+#define EFUSE_CUSTOMER (EFUSE_SHADOW_REG + 0x04)
+uint8_t usb_id_det(void)
+{
+	uint32_t value;
+	uint32_t fastboot;
+
+	value = mmio_read_32(EFUSE_CUSTOMER);
+	fastboot = GET_FIELD(value, EC_FASTBOOT_MASK, EC_FASTBOOT_SHIFT);
+	if ((fastboot & BIT(2)) == BIT(2))
+		return gpio_in_value(value);
+	else
+		return ((mmio_read_32(REG_TOP_CONF_INFO) & BIT_TOP_USB_ID) >> SHIFT_TOP_USB_ID);
+}
+
+static int is_download_gpio_set(void)
+{
+	return !usb_id_det();
+}
+
+int is_usb_dl_enabled(void)
+{
+	if (get_sw_info()->usd_dl == DOWNLOAD_DISABLE)
+		return 0;
+
+	if (get_sw_info()->usd_dl == DOWNLOAD_BUTTON)
+		return is_download_gpio_set();
+
+	return 1;
+}
diff --git a/firmware/plat/cv180x/security b/firmware/plat/cv180x/security
new file mode 120000
index 0000000..738224a
--- /dev/null
+++ b/firmware/plat/cv180x/security
@@ -0,0 +1 @@
+../cv181x/security/
\ No newline at end of file
diff --git a/firmware/plat/cv180x/uart b/firmware/plat/cv180x/uart
new file mode 120000
index 0000000..0485cfd
--- /dev/null
+++ b/firmware/plat/cv180x/uart
@@ -0,0 +1 @@
+../cv181x/uart/
\ No newline at end of file
diff --git a/firmware/plat/cv180x/usb/cps_cvi.c b/firmware/plat/cv180x/usb/cps_cvi.c
new file mode 100644
index 0000000..6f6fa42
--- /dev/null
+++ b/firmware/plat/cv180x/usb/cps_cvi.c
@@ -0,0 +1,87 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <dps.h>
+
+/* see dps.h */
+uint32_t DWC2_ReadReg32(volatile uint32_t *address)
+{
+	return *address;
+}
+
+/* see dps.h */
+void DWC2_WriteReg32(uint32_t value, volatile uint32_t *address)
+{
+	*address = value;
+}
+
+/* see dps.h */
+uint8_t DWC2_UncachedRead8(volatile uint8_t *address)
+{
+	return *address;
+}
+
+/* see dps.h */
+uint16_t DWC2_UncachedRead16(volatile uint16_t *address)
+{
+	return *address;
+}
+
+/* see dps.h */
+uint32_t DWC2_UncachedRead32(volatile uint32_t *address)
+{
+	return *address;
+}
+
+/* see dps.h */
+void DWC2_UncachedWrite8(uint8_t value, volatile uint8_t *address)
+{
+	*address = value;
+}
+
+/* see dps.h */
+void DWC2_UncachedWrite16(uint16_t value, volatile uint16_t *address)
+{
+	*address = value;
+}
+
+/* see dps.h */
+void DWC2_UncachedWrite32(uint32_t value, volatile uint32_t *address)
+{
+	*address = value;
+}
+
+/* see dps.h */
+void DWC2_WritePhysAddress32(uint32_t addrValue, volatile uint32_t *location)
+{
+	*location = addrValue;
+}
+
+/* see dps.h */
+void DWC2_BufferCopy(volatile uint8_t *dst, volatile uint8_t *src, uint32_t size)
+{
+	memcpy((void *)dst, (void *)src, size);
+}
+
+/* Since this is a bare-metal system, with no MMU in place, we expect that there will be no cache enabled */
+
+// void DWC2_CacheInvalidate(uintptr_t address, size_t size)
+// {
+// #ifdef TENSILICA
+//     xthal_dcache_region_invalidate(address, size);
+// #endif
+//     return;
+// }
+
+// void DWC2_CacheFlush(uintptr_t address, size_t size)
+// {
+// #ifdef TENSILICA
+//     xthal_dcache_region_writeback(address, size);
+// #endif
+//     return;
+// }
+
+void DWC2_DelayNs(uint32_t ns)
+{
+}
diff --git a/firmware/plat/cv180x/usb/cv_usb.c b/firmware/plat/cv180x/usb/cv_usb.c
new file mode 100644
index 0000000..c98b189
--- /dev/null
+++ b/firmware/plat/cv180x/usb/cv_usb.c
@@ -0,0 +1,29 @@
+/**********************************************************************
+ * main.c
+ *
+ * USB Core Driver
+ * main component function
+ ***********************************************************************/
+
+#include <stdint.h>
+#include <debug.h>
+#include "platform.h"
+#include "cv_usb.h"
+#include "mmio.h"
+#include "platform.h"
+#include "delay_timer.h"
+
+uint16_t cv_usb_vid = ID_VENDOR; // Cvitek
+
+int usb_polling(void *buf, uint32_t offset, uint32_t size)
+{
+	int r;
+
+	cv_usb_vid = get_sw_info()->usb_vid;
+	INFO("USBVID/%x.\n", cv_usb_vid);
+	// flush_dcache_range((uint64_t)buf, size);
+
+	r = AcmApp(buf, offset, size);
+
+	return r;
+}
diff --git a/firmware/plat/cv180x/usb/dwc2_udc_otg.c b/firmware/plat/cv180x/usb/dwc2_udc_otg.c
new file mode 100644
index 0000000..fc5df51
--- /dev/null
+++ b/firmware/plat/cv180x/usb/dwc2_udc_otg.c
@@ -0,0 +1,1146 @@
+/*
+ * drivers/usb/gadget/dwc2_udc_otg.c
+ * Designware DWC2 on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2008 for Samsung Electronics
+ *
+ * BSP Support for Samsung's UDC driver
+ * available at:
+ * git://git.kernel.org/pub/scm/linux/kernel/git/kki_ap/linux-2.6-samsung.git
+ *
+ * State machine bugfixes:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ *
+ * Ported to u-boot:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ * Lukasz Majewski <l.majewski@samsumg.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <list.h>
+#include <delay_timer.h>
+#include <debug.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "platform.h"
+#include <dwc2_ch9.h>
+#include <dwc2_drv_if.h>
+
+#include <byteorder.h>
+#include <dwc2_stdtypes.h>
+#include <dwc2_errno.h>
+#include "dwc2_udc_otg_regs.h"
+#include "dwc2_udc_otg_priv.h"
+#include <dwc2_udc.h>
+#include <dps.h>
+
+/***********************************************************/
+#define DRIVER_VERSION "15 March 2009"
+
+static const char ep0name[] = "ep0-control";
+static const char ep1name[] = "ep1in-bulk";
+static const char ep2name[] = "ep2out-bulk";
+static const char ep3name[] = "ep3in-int";
+
+struct dwc2_udc	*the_controller;
+
+static const char driver_name[] = "dwc2-udc";
+
+/* Max packet size*/
+/* Local declarations. */
+static int dwc2_ep_enable(struct usb_ep *ep,
+			 const CH9_UsbEndpointDescriptor *);
+static int dwc2_ep_disable(struct usb_ep *ep);
+static struct usb_request *dwc2_alloc_request(struct usb_ep *ep);
+static void dwc2_free_request(struct usb_ep *ep, struct usb_request *);
+
+static int dwc2_dequeue(struct usb_ep *ep, struct usb_request *);
+static int dwc2_fifo_status(struct usb_ep *ep);
+static void dwc2_fifo_flush(struct usb_ep *ep);
+static void stop_activity(struct dwc2_udc *dev,
+			  struct usb_gadget_driver *driver);
+static int udc_enable(struct dwc2_udc *dev);
+static void dwc2_usbd_init(struct dwc2_udc *dev);
+// void udc_reinit(struct dwc2_udc *dev);
+static int _dwc2_ep_disable(struct dwc2_ep *ep);
+
+#undef DWC2_LOG
+#undef DWC2_DBG
+
+#if defined(DWC2_LOG)
+
+#define DWC2_LOG_ENTRY_NUM	1024
+
+struct dwc2_log_s {
+	uint32_t time;
+	uint32_t tag;
+	uint32_t param1;
+	uint32_t param2;
+	uint32_t param3;
+	uint32_t param4;
+};
+
+static unsigned int log_idx;
+static struct dwc2_log_s dwc2_log[DWC2_LOG_ENTRY_NUM];
+
+void dwc2_log_write(uint32_t tag, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4)
+{
+	//if (log_idx == DWC2_LOG_ENTRY_NUM)
+	//	return;
+
+	dwc2_log[log_idx].tag = tag;
+	dwc2_log[log_idx].param1 = param1;
+	dwc2_log[log_idx].param2 = param2;
+	dwc2_log[log_idx].param3 = param3;
+	dwc2_log[log_idx].param4 = param4;
+	dwc2_log[log_idx].time = get_timer();
+
+	log_idx++;
+	log_idx = log_idx % DWC2_LOG_ENTRY_NUM;
+}
+
+void set_trigger_cnt(int cnt)
+{
+	static int test_reset;
+	uint32_t *test_ptr = (uint32_t *)0x83000000;
+
+	if (test_reset == cnt)
+		*test_ptr = 0xAAA;
+	test_reset++;
+}
+
+#else
+
+void dwc2_log_write(uint32_t tag, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4)
+{
+}
+
+void set_trigger_cnt(int cnt)
+{
+}
+
+#endif
+
+static struct usb_ep_ops dwc2_ep_ops = {
+	.enable = dwc2_ep_enable,
+	.disable = dwc2_ep_disable,
+
+	.alloc_request = dwc2_alloc_request,
+	.free_request = dwc2_free_request,
+
+	.queue = dwc2_queue,
+	.dequeue = dwc2_dequeue,
+
+	.set_halt = dwc2_udc_set_halt,
+	.fifo_status = dwc2_fifo_status,
+	.fifo_flush = dwc2_fifo_flush,
+};
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+/***********************************************************/
+
+const char *dwc2_get_ep0_name(void)
+{
+	return ep0name;
+}
+
+struct dwc2_usbotg_reg *reg;
+
+bool dfu_usb_get_reset(void)
+{
+	return !!(DWC2_UncachedRead32(&reg->gintsts) & INT_RESET);
+}
+
+void otg_phy_init(struct dwc2_udc *dev)
+{
+}
+void otg_phy_off(struct dwc2_udc *dev)
+{
+}
+
+/***********************************************************/
+
+//#include "dwc2_udc_otg_xfer_dma.c"
+
+/***********************************************************/
+/*
+ *	udc_disable - disable USB device controller
+ */
+static void udc_disable(struct dwc2_udc *dev)
+{
+	dwc2dbg_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);
+
+	dwc2_set_address(dev, 0);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = CH9_USB_SPEED_UNKNOWN;
+	dev->usb_address = 0;
+
+	otg_phy_off(dev);
+}
+
+/*
+ *	udc_reinit - initialize software state
+ */
+void udc_reinit(struct dwc2_udc *dev)
+{
+	unsigned int i;
+
+	dwc2dbg_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	/* basic endpoint records init */
+	for (i = 0; i < DWC2_MAX_ENDPOINTS; i++) {
+		struct dwc2_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->pio_irqs = 0;
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+
+#define BYTES2MAXP(x)	(x / 8)
+#define MAXP2BYTES(x)	(x * 8)
+
+/* until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static int udc_enable(struct dwc2_udc *dev)
+{
+	dwc2dbg_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);
+
+	otg_phy_init(dev);
+	dwc2_usbd_init(dev);
+	dwc2_reconfig_usbd(dev, 0);
+
+	dwc2dbg_cond(DEBUG_SETUP != 0,
+		   "DWC2 USB 2.0 OTG Controller Core Initialized : 0x%x\n",
+		    DWC2_UncachedRead32(&reg->gintmsk));
+
+	dev->gadget.speed = CH9_USB_SPEED_UNKNOWN;
+
+	return 0;
+}
+
+/*
+ * Register entry point for the peripheral controller driver.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct dwc2_udc *dev = the_controller;
+	int retval = 0;
+
+	dwc2dbg_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");
+
+	if (!driver
+	    || (driver->speed != CH9_USB_SPEED_FULL
+		&& driver->speed != CH9_USB_SPEED_HIGH)
+	    || !driver->bind || !driver->disconnect || !driver->setup || !driver->req_mem_alloc
+	    || !driver->req_mem_free)
+		return -EINVAL;
+	if (!dev)
+		return -ENODEV;
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first hook up the driver ... */
+	dev->driver = driver;
+
+	if (retval) { /* TODO */
+		tf_printf("target device_add failed, error %d\n", retval);
+		return retval;
+	}
+
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "%s: bind to driver --> error %d\n",
+			    dev->gadget.name, retval);
+		dev->driver = 0;
+		return retval;
+	}
+
+#if defined(USB_IRQ_MODE)
+	enable_irq(USB_IRQS_0);
+#endif
+	dwc2dbg_cond(DEBUG_SETUP != 0,
+		   "Registered gadget driver %s\n", dev->gadget.name);
+	udc_enable(dev);
+
+	return 0;
+}
+
+/*
+ * Unregister entry point for the peripheral controller driver.
+ */
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct dwc2_udc *dev = the_controller;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	dev->driver = 0;
+	stop_activity(dev, driver);
+
+	driver->unbind(&dev->gadget);
+
+#if defined(USB_IRQ_MODE)
+	disable_irq(USB_IRQS_0);
+#endif
+
+	udc_disable(dev);
+	return 0;
+}
+
+/*
+ *	dwc2_done - retire a request; caller blocked irqs
+ */
+void dwc2_done(struct dwc2_ep *ep, struct dwc2_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+
+	dwc2dbg("%s: %s %p, req = %p, stopped = %d\n",
+	      __func__, ep->ep.name, ep, &req->req, stopped);
+
+	list_del_init(&req->queue);
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN) {
+		dwc2dbg("complete %s req %p stat %d len %u/%u\n",
+		      ep->ep.name, &req->req, status,
+		      req->req.actual, req->req.length);
+	}
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+#ifdef DWC2_DBG
+	tf_printf("calling complete callback\n");
+	{
+		int i, len = req->req.length;
+
+		tf_printf("pkt[%d] = ", req->req.length);
+		if (len > 64)
+			len = 64;
+		for (i = 0; i < len; i++) {
+			tf_printf("%x", ((uint8_t *)req->req.buf)[i]);
+			if ((i & 7) == 7)
+				tf_printf(" ");
+		}
+		tf_printf("\n");
+	}
+#endif
+	req->req.complete(&ep->ep, &req->req);
+
+	dwc2dbg("callback completed\n");
+
+	ep->stopped = stopped;
+}
+
+/*
+ *	dwc2_nuke - dequeue ALL requests
+ */
+void dwc2_nuke(struct dwc2_ep *ep, int status)
+{
+	struct dwc2_request *req;
+
+	dwc2dbg("%s: %s %p\n", __func__, ep->ep.name, ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct dwc2_request, queue);
+		dwc2_done(ep, req, status);
+	}
+}
+
+static void stop_activity(struct dwc2_udc *dev,
+			  struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == CH9_USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = CH9_USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < DWC2_MAX_ENDPOINTS; i++) {
+		struct dwc2_ep *ep = &dev->ep[i];
+
+		ep->stopped = 1;
+		dwc2_nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		driver->disconnect(&dev->gadget);
+	}
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+static void dwc2_hsotg_init_fifo(struct dwc2_udc *dev)
+{
+	uint32_t rx_fifo_sz, tx_fifo_sz, np_tx_fifo_sz;
+	int timeout, i;
+	uint32_t val;
+
+	if (dwc2_hsotg_wait_bit_set(&reg->grstctl, AHBIDLE, 10000))
+		tf_printf("%s:  HANG! AHB Idle GRSCTL\n", __func__);
+
+	/* setup fifos */
+	rx_fifo_sz = RX_FIFO_SIZE;
+	np_tx_fifo_sz = NPTX_FIFO_SIZE;
+	tx_fifo_sz = PTX_FIFO_SIZE;
+
+	/* Set Rx FIFO Size (in 32-bit words) */
+	DWC2_UncachedWrite32(rx_fifo_sz, &reg->grxfsiz);
+
+	/* Set Non Periodic Tx FIFO Size (TXFIFO[0]) */
+	DWC2_UncachedWrite32((np_tx_fifo_sz << 16) | rx_fifo_sz,
+	       &reg->gnptxfsiz);
+
+	for (i = 1; i < DWC2_MAX_ENDPOINTS; i++)
+		DWC2_UncachedWrite32((rx_fifo_sz + np_tx_fifo_sz + tx_fifo_sz*(i-1)) |
+			tx_fifo_sz << 16, &reg->dieptxf[i-1]);
+
+	/* Flush all the FIFO's */
+	DWC2_UncachedWrite32(TX_FIFO_FLUSH_ALL |
+			TX_FIFO_FLUSH |
+			RX_FIFO_FLUSH,
+			&reg->grstctl);
+	timeout = 100;
+	while (1) {
+		val = DWC2_UncachedRead32(&reg->grstctl);
+
+		if ((val & (TX_FIFO_FLUSH | RX_FIFO_FLUSH)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			tf_printf("%s: timeout flushing fifos (grstctl = 0x%x)\n",
+					__func__, val);
+			break;
+		}
+		udelay(1);
+	}
+}
+
+static void dwc2_hsotg_txfifo_flush(struct dwc2_udc *dev, unsigned int idx)
+{
+	int timeout;
+	int val;
+
+	if (dwc2_hsotg_wait_bit_set(&reg->grstctl, AHBIDLE, 10000))
+		tf_printf("%s:  HANG! AHB Idle GRSCTL\n", __func__);
+
+	DWC2_UncachedWrite32(TX_FIFO_NUMBER(idx) | TX_FIFO_FLUSH, &reg->grstctl);
+
+	/* wait until the fifo is flushed */
+	timeout = 100;
+
+	while (1) {
+		val = DWC2_UncachedRead32(&reg->grstctl);
+
+		if ((val & (TX_FIFO_FLUSH)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			tf_printf("%s: timeout flushing fifo (GRSTCTL=%08x)\n",
+				__func__, val);
+			break;
+		}
+
+		udelay(1);
+	}
+
+	/* Wait for at least 3 PHY Clocks */
+	udelay(1);
+}
+
+static void kill_all_requests(struct dwc2_udc *dev, struct dwc2_ep *ep, int result)
+{
+	uint32_t ep_num = ep_index(ep);
+	uint32_t size_max = (ep_num == 0) ? (NPTX_FIFO_SIZE*4) : (PTX_FIFO_SIZE*4);
+	uint32_t size;
+
+	dwc2dbg("%s: %p\n", __func__, ep);
+
+	/* make sure it's actually queued on this endpoint */
+	dwc2_nuke(ep, result);
+
+	size = (DWC2_UncachedRead32(&reg->in_endp[ep_num].dtxfsts) & 0xFFFF) * 4;
+	if (size < size_max)
+		dwc2_hsotg_txfifo_flush(dev, ep->fifo_num);
+
+}
+
+void dwc2_disconnect(struct dwc2_udc *dev)
+{
+	int i;
+
+	if (!dev->connected)
+		return;
+
+	dev->connected = 0;
+
+	for (i = 1; i < DWC2_MAX_ENDPOINTS; i++) {
+		struct dwc2_ep *ep = &dev->ep[i];
+
+		if (ep->ep.name) {
+			kill_all_requests(dev, ep, -ESHUTDOWN);
+		}
+	}
+
+	/* HACK to let gadget detect disconnected state */
+	if (dev->driver->disconnect) {
+		dev->driver->disconnect(&dev->gadget);
+	}
+}
+
+void dwc2_reconfig_usbd(struct dwc2_udc *dev, int is_usb_reset)
+{
+	/* 2. Soft-reset OTG Core and then unreset again. */
+	unsigned int val;
+	uint32_t dflt_gusbcfg;
+	struct dwc2_plat_otg_data *pdata = (struct dwc2_plat_otg_data *)dev->pdata;
+	struct dwc2_ep *ep = &dev->ep[0];
+
+	dwc2dbg("Reseting OTG controller\n");
+
+	kill_all_requests(dev, ep, -ECONNRESET);
+	udc_reinit(dev);
+	if (!is_usb_reset) {
+		uint32_t greset;
+		int count = 0;
+		uint32_t snpsid = DWC2_UncachedRead32(&reg->gsnpsid) & DWC2_CORE_REV_MASK;
+
+		/* check snpsid */
+		if (snpsid < (DWC2_CORE_REV_4_20a & DWC2_CORE_REV_MASK)) {
+			/* Core Soft Reset */
+			DWC2_UncachedWrite32(CORE_SOFT_RESET, &reg->grstctl);
+			do {
+				udelay(1);
+				greset = DWC2_UncachedRead32(&reg->grstctl);
+				if (++count > 50) {
+					tf_printf("%s() HANG! Soft Reset GRSTCTL=%0x\n", __func__, greset);
+					return;
+				}
+			} while (greset & CORE_SOFT_RESET);
+		} else {
+			/* Core Soft Reset */
+			DWC2_UncachedWrite32(CORE_SOFT_RESET, &reg->grstctl);
+			do {
+				udelay(1);
+				greset = DWC2_UncachedRead32(&reg->grstctl);
+				if (++count > 50) {
+					tf_printf("%s() HANG! Soft 4.2 Reset GRSTCTL=%0x\n",
+						 __func__, greset);
+					return;
+				}
+			} while (!(greset & CSFTRST_DONE));
+			greset = DWC2_UncachedRead32(&reg->grstctl);
+			greset &= ~CORE_SOFT_RESET;
+			greset |= CSFTRST_DONE;
+			DWC2_UncachedWrite32(greset, &reg->grstctl);
+		}
+
+		/* Wait for AHB master IDLE state */
+		count = 0;
+		do {
+			udelay(1);
+			greset = DWC2_UncachedRead32(&reg->grstctl);
+			if (++count > 50) {
+				tf_printf("%s() HANG! AHB Idle GRSTCTL=%0x\n",
+					 __func__, greset);
+				return;
+			}
+		} while (!(greset & AHB_MASTER_IDLE));
+	} else {
+		int i;
+
+		for (i = 1; i < DWC2_MAX_ENDPOINTS; i++) {
+			struct dwc2_ep *ep = &dev->ep[i];
+
+			if (ep->ep.name)
+				_dwc2_ep_disable(ep);
+		}
+
+	}
+
+	dflt_gusbcfg =
+		1<<30		/* ForceDevMode.*/
+		|1<<19		/* 1'b1: PHY does not power down internal clock.*/
+		|0<<15		/* PHY Low Power Clock sel*/
+		|0<<14		/* Non-Periodic TxFIFO Rewind Enable*/
+		|0x5<<10	/* Turnaround time*/
+		|0<<9 | 0<<8	/* [0:HNP disable,1:HNP enable][ 0:SRP disable*/
+				/* 1:SRP enable] H1= 1,1*/
+		|0<<7		/* Ulpi DDR sel*/
+		|0<<6		/* 0: high speed utmi+, 1: full speed serial*/
+		|0<<4		/* 0: utmi+, 1:ulpi*/
+		|1<<3		/* phy i/f  0:8bit, 1:16bit*/
+		|0x7<<0;	/* HS/FS Timeout**/
+
+	if (pdata->usb_gusbcfg)
+		dflt_gusbcfg = pdata->usb_gusbcfg;
+
+	DWC2_UncachedWrite32(dflt_gusbcfg, &reg->gusbcfg);
+
+	dwc2_hsotg_init_fifo(dev);
+
+	if (!is_usb_reset) {
+		/* Put the OTG device core in the disconnected state.*/
+		val = DWC2_UncachedRead32(&reg->dctl);
+		val |= SOFT_DISCONNECT;
+		DWC2_UncachedWrite32(val, &reg->dctl);
+	}
+
+	/* Configure OTG Core to initial settings of device mode.*/
+	/* [1: full speed(30Mhz) 0:high speed]*/
+	DWC2_UncachedWrite32(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
+
+	/* Clear any pending OTG interrupts */
+	DWC2_UncachedWrite32(0xffffffff, &reg->gotgint);
+
+	/* Clear any pending interrupts */
+	DWC2_UncachedWrite32(0xffffffff, &reg->gintsts);
+
+	/* Unmask the core interrupts*/
+	DWC2_UncachedWrite32(GINTMSK_INIT, &reg->gintmsk);
+
+	/* Initialize ahbcfg.*/
+	DWC2_UncachedWrite32(GAHBCFG_INIT, &reg->gahbcfg);
+
+	/* Unmask device IN EP common interrupts*/
+	DWC2_UncachedWrite32(DIEPMSK_INIT, &reg->diepmsk);
+
+	/* Unmask device OUT EP common interrupts*/
+	DWC2_UncachedWrite32(DOEPMSK_INIT, &reg->doepmsk);
+
+	/* Unmask EPO interrupts*/
+	DWC2_UncachedWrite32(((1 << EP0_CON) << DAINT_OUT_BIT)
+	       | (1 << EP0_CON), &reg->daintmsk);
+
+	if (!is_usb_reset) {
+		val = DWC2_UncachedRead32(&reg->dctl);
+		val |= PWRONPRGDONE;
+		DWC2_UncachedWrite32(val, &reg->dctl);
+		udelay(10);  /* see openiboot */
+		val = DWC2_UncachedRead32(&reg->dctl);
+		val &= ~PWRONPRGDONE;
+		DWC2_UncachedWrite32(val, &reg->dctl);
+	}
+
+	/* prepare the setup */
+	dwc2_udc_pre_setup(dev);
+	/* enable, but don't activate EP0in */
+	DWC2_UncachedWrite32(DEPCTL_USBACTEP, &reg->in_endp[0].diepctl);
+
+	/* clear global NAKs */
+	val = CGOUTNAK | CGNPINNAK;
+	if (!is_usb_reset)
+		val |= SOFT_DISCONNECT;
+	val |= DWC2_UncachedRead32(&reg->dctl);
+	DWC2_UncachedWrite32(val, &reg->dctl);
+
+	/* must be at-least 3ms to allow bus to see disconnect */
+	mdelay(3);
+}
+#define USB20_PHY_WRAP (TOP_BASE + 0x00006000)
+
+#define ATF_STATE_USB_UTMI_RST_DONE 0xC000300B
+static void dwc2_usbd_init(struct dwc2_udc *dev)
+{
+	unsigned int uTemp;
+	uint32_t dflt_gusbcfg;
+	struct dwc2_plat_otg_data *pdata = (struct dwc2_plat_otg_data *)dev->pdata;
+	uint32_t *usb_phy_reg = (uint32_t *)(USB20_PHY_WRAP + 0x14);
+	uint32_t reg_data;
+
+	dwc2dbg("Init OTG controller\n");
+
+	/* Unmask subset of endpoint interrupts */
+	DWC2_UncachedWrite32(DOEPMSK_INIT, &reg->doepmsk);
+	DWC2_UncachedWrite32(DIEPMSK_INIT, &reg->diepmsk);
+	DWC2_UncachedWrite32(0, &reg->daintmsk);
+
+	/* Be in disconnected state until gadget is registered */
+	uTemp = DWC2_UncachedRead32(&reg->dctl);
+	uTemp |= SOFT_DISCONNECT;
+	DWC2_UncachedWrite32(uTemp, &reg->dctl);
+
+	/* setup fifo*/
+	dwc2_hsotg_init_fifo(dev);
+
+	dflt_gusbcfg =
+		1<<30		/* ForceDevMode.*/
+		|1<<19		/* 1'b1: PHY does not power down internal clock.*/
+		|0<<15		/* PHY Low Power Clock sel*/
+		|0<<14		/* Non-Periodic TxFIFO Rewind Enable*/
+		|0x5<<10	/* Turnaround time*/
+		|0<<9 | 0<<8	/* [0:HNP disable,1:HNP enable][ 0:SRP disable*/
+				/* 1:SRP enable] H1= 1,1*/
+		|0<<7		/* Ulpi DDR sel*/
+		|0<<6		/* 0: high speed utmi+, 1: full speed serial*/
+		|0<<4		/* 0: utmi+, 1:ulpi*/
+		|0<<3		/* phy i/f  0:8bit, 1:16bit*/
+		|0x7<<0;	/* HS/FS Timeout**/
+
+	if (pdata->usb_gusbcfg)
+		dflt_gusbcfg = pdata->usb_gusbcfg;
+
+	reg_data = 0;
+	if (get_sw_info()->usb_utmi_rst) {
+		reg_data = DWC2_UncachedRead32(usb_phy_reg);
+		DWC2_UncachedWrite32(0x18B, usb_phy_reg);
+		ATF_STATE = ATF_STATE_USB_UTMI_RST_DONE;
+	}
+
+	DWC2_UncachedWrite32(dflt_gusbcfg, &reg->gusbcfg);
+
+	if (get_sw_info()->usb_utmi_rst) {
+		DWC2_UncachedWrite32(reg_data, usb_phy_reg);
+		udelay(100);
+	}
+
+	/* Initialize OTG Link Core.*/
+	DWC2_UncachedWrite32(GAHBCFG_INIT, &reg->gahbcfg);
+}
+
+static int dwc2_ep_enable(struct usb_ep *_ep,
+			 const CH9_UsbEndpointDescriptor *desc)
+{
+	struct dwc2_ep *ep;
+	struct dwc2_udc *dev;
+
+	dwc2dbg("%s: %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != CH9_USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress
+	    || ep_maxpacket(ep) <
+	    le16ToCpu(desc->wMaxPacketSize)) {
+
+		dwc2dbg("%s: bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+	    && ep->bmAttributes != CH9_USB_EP_BULK
+	    && desc->bmAttributes != CH9_USB_EP_INTERRUPT) {
+
+		dwc2dbg("%s: %s type mismatch\n", __func__, _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == CH9_USB_EP_BULK &&
+	     le16ToCpu(desc->wMaxPacketSize) >
+	     ep_maxpacket(ep)) || !desc->wMaxPacketSize) {
+
+		dwc2dbg("%s: bad %s maxpacket\n", __func__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == CH9_USB_SPEED_UNKNOWN) {
+
+		dwc2dbg("%s: bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+	ep->stopped = 0;
+	ep->desc = ep->ep.desc = desc;
+	ep->pio_irqs = 0;
+	ep->ep.maxpacket = le16ToCpu(desc->wMaxPacketSize);
+
+	/* Reset halt state */
+	dwc2_udc_set_nak(ep);
+	dwc2_udc_set_halt(_ep, 0);
+
+	dwc2_udc_ep_activate(ep);
+
+	dwc2dbg("%s: enabled %s, stopped = %d, maxpacket = %d\n",
+	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
+
+	return 0;
+}
+
+void dwc2_hsotg_set_bit(uint32_t *reg, uint32_t val)
+{
+	DWC2_UncachedWrite32(DWC2_UncachedRead32(reg) | val, reg);
+}
+
+void dwc2_hsotg_clear_bit(uint32_t *reg, uint32_t val)
+{
+	DWC2_UncachedWrite32(DWC2_UncachedRead32(reg) & ~val, reg);
+}
+
+int dwc2_hsotg_wait_bit_set(uint32_t *reg, uint32_t bit, uint32_t timeout)
+{
+	uint32_t i;
+
+	for (i = 0; i < timeout; i++) {
+		if (DWC2_UncachedRead32(reg) & bit)
+			return 0;
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void dwc2_ep_stop_xfer(struct dwc2_udc *dev, struct dwc2_ep *ep)
+{
+	uint32_t ep_num = ep_index(ep);
+	uint32_t *epctrl_reg, *epint_reg;
+
+	epctrl_reg = ep_is_in(ep) ? &reg->in_endp[ep_num].diepctl :
+			&reg->out_endp[ep_num].doepctl;
+	epint_reg = ep_is_in(ep) ? &reg->in_endp[ep_num].diepint :
+			&reg->out_endp[ep_num].doepint;
+	if (ep_is_in(ep)) {
+		dwc2_hsotg_set_bit(epctrl_reg, DEPCTL_SNAK);
+		/* Wait for Nak effect */
+		if (dwc2_hsotg_wait_bit_set(epint_reg, INEPNAKEFF, 100))
+			tf_printf("%s: timeout DIEPINT.NAKEFF\n", __func__);
+	} else {
+		if (!(DWC2_UncachedRead32(&reg->gintsts) & INT_GOUTNakEff)) {
+			dwc2_hsotg_set_bit(&reg->dctl, SGOUTNAK);
+		}
+		/* Wait for global nak to take effect */
+		if (dwc2_hsotg_wait_bit_set(&reg->gintsts, INT_GOUTNakEff, 100)) {
+			tf_printf("%s: timeout GINTSTS.GOUTNAKEFF\n", __func__);
+		}
+	}
+
+	/* disable ep */
+	dwc2_hsotg_set_bit(epctrl_reg, DEPCTL_SNAK | DEPCTL_EPDIS);
+	/* Wait for ep to be disabled */
+	if (dwc2_hsotg_wait_bit_set(epint_reg, EPDISBLD, 100)) {
+		tf_printf("%s: timeout DOEPCTL.EPDisable\n", __func__);
+	}
+	/* Clear EPDISBLD interrupt */
+	dwc2_hsotg_set_bit(epint_reg, EPDISBLD);
+	if (ep_is_in(ep)) {
+		dwc2_hsotg_txfifo_flush(dev, ep->fifo_num);
+	} else {
+		dwc2_hsotg_set_bit(&reg->dctl, CGOUTNAK);
+	}
+}
+
+static int _dwc2_ep_disable(struct dwc2_ep *ep)
+{
+	uint32_t ep_num = ep_index(ep);
+	uint32_t *epctrl_reg;
+	uint32_t ctrl;
+
+	if (ep == &the_controller->ep[0]) {
+		tf_printf("%s: call for ep0-out\n", __func__);
+		return -EINVAL;
+	}
+
+	epctrl_reg = ep_is_in(ep) ? &reg->in_endp[ep_num].diepctl :
+			&reg->out_endp[ep_num].doepctl;
+	ctrl = DWC2_UncachedRead32(epctrl_reg);
+	if (ctrl & DEPCTL_EPENA)
+		dwc2_ep_stop_xfer(the_controller, ep);
+	ctrl &= ~DEPCTL_EPENA;
+	ctrl &= ~DEPCTL_USBACTEP;
+	ctrl |= DEPCTL_SNAK;
+	DWC2_UncachedWrite32(ctrl, epctrl_reg);
+	/* Nuke all pending requests */
+	kill_all_requests(the_controller, ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	return 0;
+}
+
+/*
+ * Disable EP
+ */
+static int dwc2_ep_disable(struct usb_ep *_ep)
+{
+	struct dwc2_ep *ep;
+
+	dwc2dbg("%s: %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+
+	if (!_ep || !ep->desc) {
+		dwc2dbg("%s: %s not enabled\n", __func__,
+		      _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	_dwc2_ep_disable(ep);
+
+	dwc2dbg("%s: disabled %s\n", __func__, _ep->name);
+
+	return 0;
+}
+
+static struct usb_request *dwc2_alloc_request(struct usb_ep *ep)
+{
+	struct dwc2_udc *dev = the_controller;
+	struct usb_gadget_driver *driver = dev->driver;
+	struct dwc2_request *req;
+
+	dwc2dbg("%s: %s %p\n", __func__, ep->name, ep);
+
+	req = driver->req_mem_alloc(&dev->gadget, sizeof(*req));
+	if (!req)
+		return 0;
+
+	memset(req, 0, sizeof(*req));
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void dwc2_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct dwc2_udc *dev = the_controller;
+	struct usb_gadget_driver *driver = dev->driver;
+	struct dwc2_request *req;
+
+	dwc2dbg("%s: %p\n", __func__, ep);
+
+	req = container_of(_req, struct dwc2_request, req);
+	if (!list_empty(&req->queue))
+		tf_printf("warning! free unfinished request!\n");
+	driver->req_mem_free(&dev->gadget, req);
+}
+
+/* dequeue JUST ONE request */
+static int dwc2_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct dwc2_ep *ep;
+	struct dwc2_request *req;
+
+	dwc2dbg("%s: %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		return -EINVAL;
+	}
+
+	dwc2_done(ep, req, -ECONNRESET);
+
+	return 0;
+}
+
+/*
+ * Return bytes in EP FIFO
+ */
+static int dwc2_fifo_status(struct usb_ep *_ep)
+{
+	int count = 0;
+	struct dwc2_ep *ep;
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	if (!_ep) {
+		dwc2dbg("%s: bad ep\n", __func__);
+		return -ENODEV;
+	}
+
+	dwc2dbg("%s: %d\n", __func__, ep_index(ep));
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (ep_is_in(ep))
+		return -EOPNOTSUPP;
+
+	return count;
+}
+
+/*
+ * Flush EP FIFO
+ */
+static void dwc2_fifo_flush(struct usb_ep *_ep)
+{
+	struct dwc2_ep *ep;
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	if (!_ep || (!ep->desc && ep->ep.name != ep0name)) {
+		dwc2dbg("%s: bad ep\n", __func__);
+		return;
+	}
+
+	dwc2dbg("%s: %d\n", __func__, ep_index(ep));
+}
+
+static int pullup(struct usb_gadget *gadget, int is_on)
+{
+	unsigned int uTemp = DWC2_UncachedRead32(&reg->dctl);
+
+	if (!is_on) {
+		uTemp |= SOFT_DISCONNECT;
+		DWC2_UncachedWrite32(uTemp, &reg->dctl);
+	} else {
+		uTemp &= ~SOFT_DISCONNECT;
+		DWC2_UncachedWrite32(uTemp, &reg->dctl);
+	}
+
+	return 0;
+}
+
+static int wakeup(struct usb_gadget *gadget)
+{
+	dwc2_hsotg_set_bit(&reg->dctl, RMTWKUPSIG);
+	mdelay(10);
+	dwc2_hsotg_clear_bit(&reg->dctl, RMTWKUPSIG);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops dwc2_udc_ops = {
+	/* current versions must always be self-powered */
+	.pullup = pullup,
+	.wakeup = wakeup,
+};
+
+uint8_t dwc2_phy_to_log_ep(uint8_t phy_num, uint8_t dir)
+{
+	return (phy_num) ? ((phy_num << 1) - (!!dir)) : 0;
+}
+
+/*
+ *	probe - binds to the platform device
+ */
+
+int dwc2_udc_probe(struct dwc2_plat_otg_data *pdata)
+{
+	struct dwc2_udc *dev;
+	int retval = 0;
+
+	dwc2dbg("%s: %p\n", __func__, pdata);
+
+	if (pdata->size < sizeof(*dev)) {
+		tf_printf("size for handler is too samll (%ld, %d)\n", sizeof(*dev), pdata->size);
+		return -1;
+	}
+
+	dwc2_log_write(0xbeefbeef, 0, 0, 0, 0);
+	dev = (struct dwc2_udc *)pdata->handler;
+	memset(dev, 0, sizeof(*dev));
+
+	dev->pdata = (void *)pdata;
+
+	reg = (struct dwc2_usbotg_reg *)pdata->regs_otg;
+
+	/* gadget init */
+	dev->usb_address = 0;
+	dev->gadget.ops = &dwc2_udc_ops;
+	dev->gadget.ep0 = &dev->ep[0].ep;
+	dev->gadget.name = driver_name;
+	dev->gadget.is_dualspeed = 1;
+	dev->gadget.is_otg = 0;
+	dev->gadget.is_a_peripheral = 0;
+	dev->gadget.b_hnp_enable = 0;
+	dev->gadget.a_hnp_support = 0;
+	dev->gadget.a_alt_hnp_support = 0;
+	dev->gadget.max_speed = CH9_USB_SPEED_HIGH;
+	/* eps init */
+	dev->ep[0].ep.name = ep0name;
+	dev->ep[0].ep.ops = &dwc2_ep_ops;
+	dev->ep[0].ep.maxpacket = EP0_FIFO_SIZE;
+	dev->ep[0].dev = dev;
+	dev->ep[0].bEndpointAddress = 0;
+	dev->ep[0].bmAttributes = 0;
+	dev->ep[0].ep_type = ep_control;
+	dev->ep[1].ep.name = ep1name;
+	dev->ep[1].ep.ops = &dwc2_ep_ops;
+	dev->ep[1].ep.maxpacket = EP_FIFO_SIZE;
+	dev->ep[1].dev = dev;
+	dev->ep[1].bEndpointAddress = USB_DIR_IN | 1;
+	dev->ep[1].bmAttributes = CH9_USB_EP_BULK;
+	dev->ep[1].ep_type = ep_bulk_out;
+	dev->ep[1].fifo_num = 1;
+	dev->ep[2].ep.name = ep2name;
+	dev->ep[2].ep.ops = &dwc2_ep_ops;
+	dev->ep[2].ep.maxpacket = EP_FIFO_SIZE;
+	dev->ep[2].dev = dev;
+	dev->ep[2].bEndpointAddress = USB_DIR_OUT | 1;
+	dev->ep[2].bmAttributes = CH9_USB_EP_BULK;
+	dev->ep[2].ep_type = ep_bulk_in;
+	dev->ep[2].fifo_num = 1;
+	dev->ep[3].ep.name = ep3name;
+	dev->ep[3].ep.ops = &dwc2_ep_ops;
+	dev->ep[3].ep.maxpacket = EP_FIFO_SIZE;
+	dev->ep[3].dev = dev;
+	dev->ep[3].bEndpointAddress = USB_DIR_IN | 2;
+	dev->ep[3].bmAttributes = CH9_USB_EP_INTERRUPT;
+	dev->ep[3].ep_type = ep_interrupt;
+	dev->ep[3].fifo_num = 2;
+
+	the_controller = dev;
+
+	dev->usb_ctrl = (CH9_UsbSetup *)pdata->ctrl_req;
+	if (!dev->usb_ctrl) {
+		tf_printf("No memory available for UDC!\n");
+		return -ENOMEM;
+	}
+
+	dev->usb_ctrl_dma_addr = (dma_addr_t)((uintptr_t)dev->usb_ctrl);
+	dev->reg = reg;
+
+	udc_reinit(dev);
+
+	return retval;
+}
+
+int usb_gadget_handle_interrupts(int index)
+{
+	uint32_t intr_status = DWC2_UncachedRead32(&reg->gintsts);
+	uint32_t gintmsk = DWC2_UncachedRead32(&reg->gintmsk);
+
+#ifdef DWC2_DBG
+{
+	static uint32_t print_cnt = 0xFFFF;
+
+	if (print_cnt) {
+		print_cnt--;
+	} else {
+		tf_printf("still alive\n");
+		print_cnt = 0xFFFF;
+	}
+}
+#endif
+	if (intr_status & gintmsk)
+		return dwc2_udc_irq(1, (void *)the_controller);
+	return 0;
+}
diff --git a/firmware/plat/cv180x/usb/dwc2_udc_otg_phy.c b/firmware/plat/cv180x/usb/dwc2_udc_otg_phy.c
new file mode 100644
index 0000000..6ffdc56
--- /dev/null
+++ b/firmware/plat/cv180x/usb/dwc2_udc_otg_phy.c
@@ -0,0 +1,100 @@
+/*
+ * drivers/usb/gadget/dwc2_udc_otg.c
+ * Designware DWC2 on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2008 for Samsung Electronics
+ *
+ * BSP Support for Samsung's UDC driver
+ * available at:
+ * git://git.kernel.org/pub/scm/linux/kernel/git/kki_ap/linux-2.6-samsung.git
+ *
+ * State machine bugfixes:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ *
+ * Ported to u-boot:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ * Lukasz Majewski <l.majewski@samsumg.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <malloc.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+
+#include <asm/mach-types.h>
+
+#include "dwc2_udc_otg_regs.h"
+#include "dwc2_udc_otg_priv.h"
+#include <usb/lin_gadget_compat.h>
+
+#include <usb/dwc2_udc.h>
+
+void otg_phy_init(struct dwc2_udc *dev)
+{
+	unsigned int usb_phy_ctrl = dev->pdata->usb_phy_ctrl;
+	struct dwc2_usbotg_phy *phy =
+		(struct dwc2_usbotg_phy *)dev->pdata->regs_phy;
+
+	dev->pdata->phy_control(1);
+
+	/* USB PHY0 Enable */
+	tf_printf("USB PHY0 Enable\n");
+
+	/* Enable PHY */
+	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
+
+	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
+		writel((readl(&phy->phypwr)
+			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
+			&~FORCE_SUSPEND_0), &phy->phypwr);
+	else /* C110 GONI */
+		writel((readl(&phy->phypwr) & ~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
+			&~FORCE_SUSPEND_0), &phy->phypwr);
+
+	if (s5p_cpu_id == 0x4412)
+		writel((readl(&phy->phyclk) & ~(EXYNOS4X12_ID_PULLUP0 |
+			EXYNOS4X12_COMMON_ON_N0)) | EXYNOS4X12_CLK_SEL_24MHZ,
+		       &phy->phyclk); /* PLL 24Mhz */
+	else
+		writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)) |
+		       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */
+
+	writel((readl(&phy->rstcon) & ~(LINK_SW_RST | PHYLNK_SW_RST)) | PHY_SW_RST0, &phy->rstcon);
+	udelay(10);
+	writel(readl(&phy->rstcon) & ~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
+	udelay(10);
+}
+
+void otg_phy_off(struct dwc2_udc *dev)
+{
+	unsigned int usb_phy_ctrl = dev->pdata->usb_phy_ctrl;
+	struct dwc2_usbotg_phy *phy =
+		(struct dwc2_usbotg_phy *)dev->pdata->regs_phy;
+
+	/* reset controller just in case */
+	writel(PHY_SW_RST0, &phy->rstcon);
+	udelay(20);
+	writel(readl(&phy->phypwr) & ~PHY_SW_RST0, &phy->rstcon);
+	udelay(20);
+
+	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
+	       | FORCE_SUSPEND_0, &phy->phypwr);
+
+	writel(readl(usb_phy_ctrl) & ~USB_PHY_CTRL_EN0, usb_phy_ctrl);
+
+	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
+	      &phy->phyclk);
+
+	mdelay(10);
+
+	dev->pdata->phy_control(0);
+}
diff --git a/firmware/plat/cv180x/usb/dwc2_udc_otg_xfer_dma.c b/firmware/plat/cv180x/usb/dwc2_udc_otg_xfer_dma.c
new file mode 100644
index 0000000..3f8ba0f
--- /dev/null
+++ b/firmware/plat/cv180x/usb/dwc2_udc_otg_xfer_dma.c
@@ -0,0 +1,1691 @@
+/*
+ * drivers/usb/gadget/dwc2_udc_otg_xfer_dma.c
+ * Designware DWC2 on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2009 for Samsung Electronics
+ *
+ * BSP Support for Samsung's UDC driver
+ * available at:
+ * git://git.kernel.org/pub/scm/linux/kernel/git/kki_ap/linux-2.6-samsung.git
+ *
+ * State machine bugfixes:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ *
+ * Ported to u-boot:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ * Lukasz Majewski <l.majewski@samsumg.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <list.h>
+#include <debug.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "platform.h"
+#include <dwc2_ch9.h>
+#include <dwc2_drv_if.h>
+
+#include <byteorder.h>
+#include <dwc2_stdtypes.h>
+#include <dwc2_errno.h>
+#include "dwc2_udc_otg_regs.h"
+#include "dwc2_udc_otg_priv.h"
+#include <dwc2_udc.h>
+#include <dps.h>
+
+static unsigned int ep0_fifo_size = 64;
+static unsigned int ep_fifo_size =  512;
+static unsigned int ep_fifo_size2 = 1024;
+
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV",
+	"WAIT_FOR_COMPLETE",
+	"WAIT_FOR_OUT_COMPLETE",
+	"WAIT_FOR_IN_COMPLETE",
+	"WAIT_FOR_NULL_COMPLETE",
+};
+
+/* Bulk-Only Mass Storage Reset (class-specific request) */
+#define GET_MAX_LUN_REQUEST	0xFE
+#define BOT_RESET_REQUEST	0xFF
+
+static void set_max_pktsize(struct dwc2_udc *dev, CH9_UsbSpeed speed)
+{
+	unsigned int ep_ctrl;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+	int i;
+
+	if (speed == CH9_USB_SPEED_HIGH) {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 512;
+		ep_fifo_size2 = 1024;
+		dev->gadget.speed = CH9_USB_SPEED_HIGH;
+	} else {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 64;
+		ep_fifo_size2 = 64;
+		dev->gadget.speed = CH9_USB_SPEED_FULL;
+	}
+
+	dev->ep[0].ep.maxpacket = ep0_fifo_size;
+	for (i = 1; i < DWC2_MAX_ENDPOINTS; i++)
+		dev->ep[i].ep.maxpacket = ep_fifo_size;
+
+	/* EP0 - Control IN (64 bytes)*/
+	ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl);
+	DWC2_UncachedWrite32(ep_ctrl & ~(3<<0), &reg->in_endp[EP0_CON].diepctl);
+
+	/* EP0 - Control OUT (64 bytes)*/
+	ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl);
+	DWC2_UncachedWrite32(ep_ctrl & ~(3<<0), &reg->out_endp[EP0_CON].doepctl);
+}
+
+static inline void dwc2_udc_ep0_zlp(struct dwc2_udc *dev)
+{
+	uint32_t ep_ctrl;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	DWC2_UncachedWrite32(dev->usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
+	DWC2_UncachedWrite32(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
+
+	ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl);
+	ep_ctrl &= ~(1 << 30);
+	ep_ctrl |= (DEPCTL_EPENA|DEPCTL_CNAK);
+	DWC2_UncachedWrite32(ep_ctrl,
+	       &reg->in_endp[EP0_CON].diepctl);
+
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl));
+	dev->ep0state = WAIT_FOR_IN_COMPLETE;
+	dwc2_log_write(0xAAAAA, ep_ctrl, dev->usb_ctrl_dma_addr,
+				DIEPT_SIZ_PKT_CNT(1), 0);
+}
+
+void dwc2_udc_pre_setup(struct dwc2_udc *dev)
+{
+	//uint32_t ep_ctrl, tmp, tmp1;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	dwc2dbg_cond(DEBUG_SETUP,
+		   "%s : Prepare Setup packets.\n", __func__);
+
+	DWC2_UncachedWrite32(DOEPT_SIZ_SUS_CNT(1) | DOEPT_SIZ_PKT_CNT(1) | sizeof(CH9_UsbSetup),
+	       &reg->out_endp[EP0_CON].doeptsiz);
+
+#ifdef DWC2_DMA_EN
+	DWC2_UncachedWrite32(dev->usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
+
+	tmp = DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl);
+	ep_ctrl = DEPCTL_EPENA | DEPCTL_USBACTEP;
+	// tmp = ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl);
+	// ep_ctrl &= ~(1 << 30);
+	// ep_ctrl |= DEPCTL_EPENA;
+
+	DWC2_UncachedWrite32(ep_ctrl, &reg->out_endp[EP0_CON].doepctl);
+#endif
+
+	//tmp1 = DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl);
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl));
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl));
+	//dwc2_log_write(0x99999, ep_ctrl, dev->usb_ctrl_dma_addr,
+	//			tmp, tmp1);
+
+}
+
+static inline void dwc2_ep0_complete_out(struct dwc2_udc *dev)
+{
+	uint32_t ep_ctrl;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl));
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl));
+
+	dwc2dbg_cond(DEBUG_OUT_EP,
+		"%s : Prepare Complete Out packet.\n", __func__);
+
+	//dwc2dbg_cond(1,
+	//	   "CO\n");
+	DWC2_UncachedWrite32(DOEPT_SIZ_PKT_CNT(1) | sizeof(CH9_UsbSetup),
+	       &reg->out_endp[EP0_CON].doeptsiz);
+	DWC2_UncachedWrite32(dev->usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
+
+	ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl);
+	ep_ctrl &= ~(1 << 30);
+	ep_ctrl |= (DEPCTL_EPENA | DEPCTL_CNAK);
+	DWC2_UncachedWrite32(ep_ctrl,
+	       &reg->out_endp[EP0_CON].doepctl);
+
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl));
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
+		__func__, DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl));
+	dwc2_log_write(0x88888, ep_ctrl, dev->usb_ctrl_dma_addr, DOEPT_SIZ_PKT_CNT(1) | sizeof(CH9_UsbSetup), 0);
+}
+
+static int setdma_rx(struct dwc2_ep *ep, struct dwc2_request *req)
+{
+	uint32_t *buf, ctrl;
+	uint32_t length, pktcnt;
+	uint32_t ep_num = ep_index(ep);
+	uint32_t dma_addr;
+	struct dwc2_usbotg_reg *reg = ep->dev->reg;
+
+	buf = req->req.buf + req->req.actual;
+	length = min_t(uint32_t, req->req.length - req->req.actual,
+		       ep_num ? DMA_BUFFER_SIZE : ep->ep.maxpacket);
+
+	ep->len = length;
+	ep->dma_buf = buf;
+
+	if (ep_num == EP0_CON || length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
+
+	ctrl =  DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl);
+
+	dma_addr = (uint32_t)((uintptr_t)ep->dma_buf);
+	// DWC2_CacheInvalidate(dma_addr, ep->len);
+
+#ifdef DWC2_DMA_EN
+	DWC2_UncachedWrite32(dma_addr, &reg->out_endp[ep_num].doepdma);
+	DWC2_UncachedWrite32(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
+	       &reg->out_endp[ep_num].doeptsiz);
+	ctrl &= ~(1 << 30);
+	ctrl |= (DEPCTL_EPENA|DEPCTL_CNAK);
+	DWC2_UncachedWrite32(ctrl, &reg->out_endp[ep_num].doepctl);
+#else
+	ctrl |= (DEPCTL_EPENA|DEPCTL_CNAK);
+	DWC2_UncachedWrite32(ctrl, &reg->out_endp[ep_num].doepctl);
+#endif
+
+	dwc2dbg_cond(DEBUG_OUT_EP != 0,
+			"%s: EP%d RX DMA start : DOEPDMA = 0x%x, DOEPTSIZ = 0x%x, DOEPCTL = 0x%x buf = 0x%p, pktcnt = %d, xfersize = %d\n",
+			__func__, ep_num,
+			DWC2_UncachedRead32(&reg->out_endp[ep_num].doepdma),
+			DWC2_UncachedRead32(&reg->out_endp[ep_num].doeptsiz),
+			DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl),
+			buf, pktcnt, length);
+	dwc2_log_write(0x77777, ctrl, dma_addr, DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length), 0);
+	return 0;
+
+}
+
+void dwc2_ep_fifo_write(struct dwc2_udc *dev, uint8_t ep_idx, uint8_t *src, uint16_t len)
+{
+	struct dwc2_usbotg_reg *reg = dev->reg;
+	uint32_t *pSrc = (uint32_t *)src;
+	uint32_t count32b, i;
+
+	count32b = ((uint32_t)len + 3U) / 4U;
+	for (i = 0U; i < count32b; i++) {
+		DWC2_UncachedWrite32(*pSrc, &reg->ep[ep_idx].fifo);
+		pSrc++;
+	}
+}
+
+static int setdma_tx(struct dwc2_ep *ep, struct dwc2_request *req)
+{
+	uint32_t *buf;
+	uint32_t ctrl = 0;
+	uint32_t tmp, tmp1;
+	uint32_t length, pktcnt;
+	uint32_t ep_num = ep_index(ep);
+	uint32_t dma_addr;
+	struct dwc2_usbotg_reg *reg = ep->dev->reg;
+
+	buf = req->req.buf + req->req.actual;
+	length = req->req.length - req->req.actual;
+	if (length > DMA_BUFFER_SIZE)
+		length = DMA_BUFFER_SIZE;
+
+	if (ep_num == EP0_CON)
+		length = min_t(uint32_t, length, ep_maxpacket(ep));
+
+	ep->len = length;
+	ep->dma_buf = buf;
+
+	dma_addr = (uint32_t)((uintptr_t)ep->dma_buf);
+	// DWC2_CacheFlush(dma_addr, ROUND(ep->len, CONFIG_SYS_CACHELINE_SIZE));
+	// flush_dcache_range(dma_addr, ROUND(ep->len, CONFIG_SYS_CACHELINE_SIZE));
+
+	if (length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
+
+	/* Flush the endpoint's Tx FIFO */
+	//DWC2_UncachedWrite32(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
+	//DWC2_UncachedWrite32(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
+	//while (DWC2_UncachedRead32(&reg->grstctl) & TX_FIFO_FLUSH)
+	//	;
+#ifdef DWC2_DMA_EN
+	DWC2_UncachedWrite32(dma_addr, &reg->in_endp[ep_num].diepdma);
+#endif
+	DWC2_UncachedWrite32(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
+	       &reg->in_endp[ep_num].dieptsiz);
+
+	tmp = ctrl = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl);
+
+	/* Write the FIFO number to be used for this endpoint */
+	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
+	ctrl &= ~(1 << 30);
+	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
+
+	/* Clear reserved (Next EP) bits */
+	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));
+	ctrl |= (DEPCTL_EPENA|DEPCTL_CNAK);
+	//tf_printf("diepctl0 = 0x%x\n", ctrl);
+	DWC2_UncachedWrite32(ctrl, &reg->in_endp[ep_num].diepctl);
+
+#ifndef DWC2_DMA_EN
+	dwc2_ep_fifo_write(ep->dev, ep_num, (uint8_t *)buf, length);
+	if (length > 0) {
+		DWC2_UncachedWrite32(1UL << (ep_num & 0x0f), &reg->diepempmsk);
+	}
+#endif
+
+	tmp1 = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl);
+	dwc2dbg_cond(DEBUG_IN_EP,
+		"%s:EP%d TX DMA start : DIEPDMA0 = 0x%x, DIEPTSIZ0 = 0x%x, DIEPCTL0 = 0x%x buf = 0x%p, pktcnt = %d, xfersize = %d\n",
+		__func__, ep_num,
+		DWC2_UncachedRead32(&reg->in_endp[ep_num].diepdma),
+		DWC2_UncachedRead32(&reg->in_endp[ep_num].dieptsiz),
+		DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl),
+		buf, pktcnt, length);
+	//dwc2dbg_cond(1, "TD\n");
+	dwc2_log_write(0x44444, ctrl, dma_addr, tmp, tmp1);
+	dwc2_log_write(0x46464, DWC2_UncachedRead32(&reg->in_endp[ep_num].dieptsiz), length, ep_num, 0);
+
+	return length;
+}
+
+static void complete_rx(struct dwc2_udc *dev, uint8_t ep_num)
+{
+	struct dwc2_ep *ep = &dev->ep[dwc2_phy_to_log_ep(ep_num, 0)];
+	struct dwc2_request *req = NULL;
+	uint32_t ep_tsr = 0, xfer_size = 0, is_short = 0;
+	// uint32_t dma_addr;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	if (list_empty(&ep->queue)) {
+		dwc2dbg_cond(DEBUG_OUT_EP != 0,
+			   "%s: RX DMA done : NULL REQ on OUT EP-%d\n",
+			   __func__, ep_num);
+		return;
+
+	}
+
+	req = list_entry(ep->queue.next, struct dwc2_request, queue);
+	ep_tsr = DWC2_UncachedRead32(&reg->out_endp[ep_num].doeptsiz);
+
+	if (ep_num == EP0_CON)
+		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
+	else
+
+		// xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
+		xfer_size = req->req.rxfifo_cnt;
+
+	xfer_size = ep->len - xfer_size;
+
+	/*
+	 * NOTE:
+	 *
+	 * Please be careful with proper buffer allocation for USB request,
+	 * which needs to be aligned to CONFIG_SYS_CACHELINE_SIZE, not only
+	 * with starting address, but also its size shall be a cache line
+	 * multiplication.
+	 *
+	 * This will prevent from corruption of data allocated immediatelly
+	 * before or after the buffer.
+	 *
+	 * For armv7, the cache_v7.c provides proper code to emit "ERROR"
+	 * message to warn users.
+	 */
+	// dma_addr = (uint32_t)((uintptr_t)ep->dma_buf);
+	// DWC2_CacheInvalidate(dma_addr, ROUND(xfer_size, CONFIG_SYS_CACHELINE_SIZE));
+
+	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
+	is_short = !!(xfer_size % ep->ep.maxpacket);
+
+	dwc2dbg_cond(DEBUG_OUT_EP != 0,
+		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
+		   __func__, ep_num, req->req.actual, req->req.length,
+		   is_short, ep_tsr, req->req.length - req->req.actual);
+
+	if (is_short || req->req.actual == req->req.length) {
+		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
+			dwc2dbg_cond(DEBUG_OUT_EP != 0, "	=> Send ZLP\n");
+			dwc2_udc_ep0_zlp(dev);
+			/* packet will be completed in complete_tx() */
+			dev->ep0state = WAIT_FOR_IN_COMPLETE;
+		} else {
+			dwc2_done(ep, req, 0);
+
+			if (!list_empty(&ep->queue)) {
+				req = list_entry(ep->queue.next,
+					struct dwc2_request, queue);
+				dwc2dbg_cond(DEBUG_OUT_EP != 0,
+					   "%s: Next Rx request start...\n",
+					   __func__);
+				setdma_rx(ep, req);
+			}
+		}
+	} else
+		setdma_rx(ep, req);
+}
+
+static void complete_tx(struct dwc2_udc *dev, uint8_t ep_num)
+{
+	struct dwc2_ep *ep = &dev->ep[dwc2_phy_to_log_ep(ep_num, 1)];
+	struct dwc2_request *req;
+	//uint32_t ep_tsr = 0, xfer_size = 0, is_short = 0;
+	uint32_t xfer_size = 0;
+	uint32_t last;
+	//struct dwc2_usbotg_reg *reg = dev->reg;
+
+	dwc2_log_write(0x55555, dev->ep0state, list_empty(&ep->queue), 0, 0);
+
+	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
+		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
+		dwc2_ep0_complete_out(dev);
+		return;
+	}
+
+	if (list_empty(&ep->queue)) {
+		dwc2dbg_cond(DEBUG_IN_EP,
+			"%s: TX DMA done : NULL REQ on IN EP-%d\n",
+			__func__, ep_num);
+		return;
+
+	}
+
+	req = list_entry(ep->queue.next, struct dwc2_request, queue);
+
+	xfer_size = ep->len;
+
+	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
+
+	// ep_tsr = DWC2_UncachedRead32(&reg->in_endp[ep_num].dieptsiz);
+
+	// is_short = (xfer_size < ep->ep.maxpacket);
+	// dwc2dbg_cond(DEBUG_IN_EP,
+	// "%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
+	// "is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
+	// __func__, ep_num, req->req.actual, req->req.length,
+	// is_short, ep_tsr, req->req.length - req->req.actual);
+
+	//dwc2dbg_cond(1,
+	//	   "TC\n");
+	if (ep_num == 0) {
+		if (dev->ep0state == DATA_STATE_XMIT) {
+			dwc2dbg_cond(DEBUG_IN_EP, "%s: ep_num = %d, ep0stat == DATA_STATE_XMIT\n",
+				__func__, ep_num);
+			last = dwc2_write_fifo_ep0(ep, req);
+			if (last)
+				dev->ep0state = WAIT_FOR_COMPLETE;
+		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
+			dwc2dbg_cond(DEBUG_IN_EP,
+				"%s: ep_num = %d, completing request\n",
+				__func__, ep_num);
+			dwc2_done(ep, req, 0);
+			dev->ep0state = WAIT_FOR_SETUP;
+		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
+			dwc2dbg_cond(DEBUG_IN_EP,
+				"%s: ep_num = %d, completing request\n",
+				__func__, ep_num);
+			dwc2_done(ep, req, 0);
+			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
+			dwc2_ep0_complete_out(dev);
+		} else {
+			dwc2dbg_cond(DEBUG_IN_EP,
+				"%s: ep_num = %d, invalid ep state\n",
+				__func__, ep_num);
+		}
+		return;
+	}
+
+	if (req->req.actual == req->req.length)
+		dwc2_done(ep, req, 0);
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct dwc2_request, queue);
+		dwc2dbg_cond(DEBUG_IN_EP,
+			"%s: Next Tx request start...\n", __func__);
+		setdma_tx(ep, req);
+	}
+}
+
+static inline void dwc2_udc_check_tx_queue(struct dwc2_udc *dev, uint8_t ep_num)
+{
+	struct dwc2_ep *ep = &dev->ep[dwc2_phy_to_log_ep(ep_num, 1)];
+	struct dwc2_request *req;
+
+	dwc2dbg_cond(DEBUG_IN_EP,
+		"%s: Check queue, ep_num = %d\n", __func__, ep_num);
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct dwc2_request, queue);
+		dwc2dbg_cond(DEBUG_IN_EP,
+			"%s: Next Tx request(0x%p) start...\n",
+			__func__, req);
+
+		if (ep_is_in(ep))
+			setdma_tx(ep, req);
+		else
+			setdma_rx(ep, req);
+	} else {
+		dwc2dbg_cond(DEBUG_IN_EP,
+			"%s: NULL REQ on IN EP-%d\n", __func__, ep_num);
+
+		return;
+	}
+
+}
+
+static int dwc2_set_test_mode(struct dwc2_udc *dev, int testmode)
+{
+	struct dwc2_usbotg_reg *reg = dev->reg;
+	uint32_t dctl = DWC2_UncachedRead32(&reg->dctl);
+
+	dctl &= ~DCTL_TSTCTL_MASK;
+	switch (testmode) {
+	case CH9_TEST_J:
+	case CH9_TEST_K:
+	case CH9_TEST_SE0_NAK:
+	case CH9_TEST_PACKET:
+	case CH9_TEST_FORCE_EN:
+		tf_printf("run test mode %d\n", testmode);
+		dctl |= testmode << DCTL_TSTCTL_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+	DWC2_UncachedWrite32(dctl, &reg->dctl);
+
+	return 0;
+}
+
+
+static void process_ep_in_intr(struct dwc2_udc *dev)
+{
+	uint32_t ep_intr, ep_intr_status;
+	uint8_t ep_num = 0;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	ep_intr = DWC2_UncachedRead32(&reg->daint);
+	dwc2dbg_cond(DEBUG_IN_EP,
+		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);
+
+	ep_intr &= DAINT_MASK;
+
+	while (ep_intr) {
+		if (ep_intr & DAINT_IN_EP_INT(1)) {
+			ep_intr_status = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepint);
+			dwc2dbg_cond(DEBUG_IN_EP,
+				   "\tEP%d-IN : DIEPINT = 0x%x\n",
+				   ep_num, ep_intr_status);
+			dwc2_log_write(0x737373, ep_num, ep_intr_status,
+					DWC2_UncachedRead32(&reg->in_endp[ep_num].dieptsiz),
+					DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl));
+			dwc2_log_write(0x747474,
+					DWC2_UncachedRead32(&reg->in_endp[ep_num].diepdma),
+					DWC2_UncachedRead32(&reg->in_endp[ep_num].dtxfsts),
+					0, 0);
+
+			/* Interrupt Clear */
+			DWC2_UncachedWrite32(ep_intr_status, &reg->in_endp[ep_num].diepint);
+
+			if (ep_intr_status & TRANSFER_DONE) {
+				complete_tx(dev, ep_num);
+
+				if (ep_num == 0) {
+					if (dev->test_mode) {
+						dwc2_set_test_mode(dev, dev->test_mode);
+					}
+					if (dev->ep0state ==
+					    WAIT_FOR_IN_COMPLETE)
+						dev->ep0state = WAIT_FOR_SETUP;
+
+					if (dev->ep0state == WAIT_FOR_SETUP)
+						dwc2_udc_pre_setup(dev);
+
+					/* continue transfer after set_clear_halt for DMA mode */
+					if (dev->clear_feature_flag == 1) {
+						dwc2_udc_check_tx_queue(dev,
+							dev->clear_feature_num);
+						dev->clear_feature_flag = 0;
+					}
+				}
+			}
+
+			// if ((ep_num == 0) && (ep_intr_status & CTRL_IN_EP_TIMEOUT)) {
+			// struct dwc2_ep *ep = &dev->ep[dwc2_phy_to_log_ep(ep_num, 1)];
+
+			// dwc2_nuke(ep, -EIO);
+			// }
+
+		}
+		ep_num++;
+		ep_intr >>= 1;
+	}
+}
+
+static void process_ep_out_intr(struct dwc2_udc *dev)
+{
+	uint32_t ep_intr, ep_intr_status;
+	uint8_t ep_num = 0;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	ep_intr = DWC2_UncachedRead32(&reg->daint);
+	dwc2dbg_cond(DEBUG_OUT_EP != 0,
+		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
+		   __func__, ep_intr);
+
+	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
+
+	while (ep_intr) {
+		if (ep_intr & 0x1) {
+			ep_intr_status = DWC2_UncachedRead32(&reg->out_endp[ep_num].doepint);
+			dwc2dbg_cond(DEBUG_OUT_EP != 0,
+				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
+				   ep_num, ep_intr_status);
+
+			/* Interrupt Clear */
+			DWC2_UncachedWrite32(ep_intr_status, &reg->out_endp[ep_num].doepint);
+
+			if (ep_num == 0) {
+				if (ep_intr_status &
+				    CTRL_OUT_EP_SETUP_PHASE_DONE) {
+					dwc2dbg_cond(DEBUG_OUT_EP != 0,
+						   "SETUP packet arrived\n");
+					//dwc2dbg_cond(1, "SP\n");
+					dwc2_log_write(0x3333, 0, 0, 0, 0);
+					dwc2_handle_ep0(dev);
+				} else if (ep_intr_status & TRANSFER_DONE) {
+					if (dev->ep0state !=
+					    WAIT_FOR_OUT_COMPLETE) {
+						dwc2_log_write(0x66666, 1, ep_intr_status, 0, 0);
+						complete_rx(dev, ep_num);
+					} else {
+						dwc2_log_write(0x66666, 2, ep_intr_status, 0, 0);
+						dev->ep0state = WAIT_FOR_SETUP;
+						dwc2_udc_pre_setup(dev);
+					}
+				}
+			} else {
+				if (ep_intr_status & TRANSFER_DONE)
+					complete_rx(dev, ep_num);
+			}
+		}
+		ep_num++;
+		ep_intr >>= 1;
+	}
+}
+
+/*
+ *	usb client interrupt handler.
+ */
+void dwc2_ep_fifo_read(struct dwc2_udc *dev, uint8_t ep_idx, uint8_t *dest, uint16_t len)
+{
+	struct dwc2_usbotg_reg *reg = dev->reg;
+	uint32_t *pDest = (uint32_t *)dest;
+	uint32_t i;
+	uint32_t count32b = ((uint32_t)len + 3U) / 4U;
+
+	for (i = 0U; i < count32b; i++) {
+		*pDest = DWC2_UncachedRead32(&reg->ep[ep_idx].fifo);
+		pDest++;
+	}
+}
+
+int dwc2_udc_irq(int irq, void *_dev)
+{
+	struct dwc2_udc *dev = _dev;
+	uint32_t intr_status;
+	uint32_t usb_status, gintmsk;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	intr_status = DWC2_UncachedRead32(&reg->gintsts);
+	gintmsk = DWC2_UncachedRead32(&reg->gintmsk);
+
+	dwc2dbg_cond(DEBUG_ISR,
+		  "\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x, DAINT : 0x%x, DAINTMSK : 0x%x\n",
+		  __func__, intr_status, state_names[dev->ep0state], gintmsk,
+		  DWC2_UncachedRead32(&reg->daint), DWC2_UncachedRead32(&reg->daintmsk));
+
+	if (!intr_status) {
+		return 0;
+	}
+
+	dwc2_log_write(0xEFEF, intr_status, dev->ep0state,
+			DWC2_UncachedRead32(&reg->daint), 0);
+
+#ifndef DWC2_DMA_EN //disable DMA
+	if (intr_status & INT_RX_FIFO_NOT_EMPTY) {
+		uint32_t read_count, ep_idx, tmp;
+		struct dwc2_ep *ep;
+		struct dwc2_request *req;
+
+		dwc2dbg_cond(DEBUG_ISR, "\tRx fifo level interrupt\n");
+
+		tmp = gintmsk & ~INT_RX_FIFO_NOT_EMPTY;
+		DWC2_UncachedWrite32(tmp, &reg->gintmsk);
+
+		tmp = DWC2_UncachedRead32(&reg->grxstsp);
+		ep_idx = tmp & GRXSTSP_EPNUM_MASK;
+
+		ep = &dev->ep[dwc2_phy_to_log_ep(ep_idx, 0)];
+		req = list_entry(ep->queue.next, struct dwc2_request, queue);
+		if ((tmp & GRXSTSP_PKTSTS_MASK) == OUT_PKT_RECEIVED) {
+			read_count = (tmp & GRXSTSP_BCNT_MASK) >> 4;
+			if (read_count != 0) {
+				dwc2_ep_fifo_read(dev, ep_idx, req->req.buf, read_count);
+				// req->req.actual += read_count;
+				req->req.rxfifo_cnt = read_count;
+			}
+		} else if ((tmp & GRXSTSP_PKTSTS_MASK) == SETUP_PKT_RECEIVED) {
+			read_count = (tmp & GRXSTSP_BCNT_MASK) >> 4;
+			dwc2_ep_fifo_read(dev, ep_idx, (uint8_t *)dev->usb_ctrl, read_count);
+		} else {
+			/* ... */
+		}
+
+		tmp = gintmsk | INT_RX_FIFO_NOT_EMPTY;
+		DWC2_UncachedWrite32(tmp, &reg->gintmsk);
+	}
+#endif
+
+	if (intr_status & INT_ENUMDONE) {
+		dwc2dbg_cond(DEBUG_ISR, "\tSpeed Detection interrupt\n");
+
+		DWC2_UncachedWrite32(INT_ENUMDONE, &reg->gintsts);
+		usb_status = (DWC2_UncachedRead32(&reg->dsts) & 0x6);
+
+		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
+			dwc2dbg_cond(DEBUG_ISR,
+				   "\t\tFull Speed Detection\n");
+			set_max_pktsize(dev, CH9_USB_SPEED_FULL);
+			dwc2_log_write(0x2222, 2, 0, 0, 0);
+
+		} else {
+			dwc2dbg_cond(DEBUG_ISR,
+				"\t\tHigh Speed Detection : 0x%x\n",
+				usb_status);
+			//dwc2dbg_cond(1, "HS\n");
+			dwc2_log_write(0x2222, 1, 0, 0, 0);
+			set_max_pktsize(dev, CH9_USB_SPEED_HIGH);
+		}
+	}
+
+	if (intr_status & INT_EARLY_SUSPEND) {
+		dwc2dbg_cond(DEBUG_ISR, "\tEarly suspend interrupt\n");
+		DWC2_UncachedWrite32(INT_EARLY_SUSPEND, &reg->gintsts);
+	}
+
+	if (intr_status & INT_SUSPEND) {
+		usb_status = DWC2_UncachedRead32(&reg->dsts);
+		dwc2dbg_cond(DEBUG_ISR,
+			"\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
+		DWC2_UncachedWrite32(INT_SUSPEND, &reg->gintsts);
+		if (dev->gadget.speed != CH9_USB_SPEED_UNKNOWN && dev->driver) {
+			if (dev->driver->suspend)
+				dev->driver->suspend(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESUME) {
+		dwc2dbg_cond(DEBUG_ISR, "\tResume interrupt\n");
+		DWC2_UncachedWrite32(INT_RESUME, &reg->gintsts);
+
+		if (dev->gadget.speed != CH9_USB_SPEED_UNKNOWN
+			&& dev->driver
+			&& dev->driver->resume)	{
+			dev->driver->resume(&dev->gadget);
+		}
+	}
+
+	if ((intr_status & INT_RESET) || (intr_status & INT_RESETDET)) {
+		usb_status = DWC2_UncachedRead32(&reg->gotgctl);
+		dwc2dbg_cond(DEBUG_ISR,
+			"\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
+		//dwc2dbg_cond(1,	"R\n");
+		dwc2_log_write(0x1111, usb_status, 0, 0, 0);
+		if (intr_status & INT_RESET)
+			DWC2_UncachedWrite32(INT_RESET, &reg->gintsts);
+		if (intr_status & INT_RESETDET)
+			DWC2_UncachedWrite32(INT_RESETDET, &reg->gintsts);
+
+		if ((usb_status & 0xc0000) == (0x3 << 18)) {
+			unsigned int connected = dev->connected;
+
+			dwc2dbg_cond(DEBUG_ISR,
+				"\t\tOTG core got reset!!\n");
+			dwc2_disconnect(dev);
+			if (connected)
+				dwc2_reconfig_usbd(dev, 1);
+			dev->ep0state = WAIT_FOR_SETUP;
+		} else {
+			dwc2dbg_cond(DEBUG_ISR,
+				   "\t\tRESET handling skipped\n");
+		}
+	}
+
+	if (intr_status & INT_IN_EP)
+		process_ep_in_intr(dev);
+
+	if (intr_status & INT_OUT_EP)
+		process_ep_out_intr(dev);
+
+	return 0;
+}
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ */
+int dwc2_queue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct dwc2_request *req;
+	struct dwc2_ep *ep;
+	struct dwc2_udc *dev;
+	uint32_t ep_num, gintsts;
+	struct dwc2_usbotg_reg *reg;
+
+	req = container_of(_req, struct dwc2_request, req);
+	if (!_req || !_req->complete || !_req->buf
+		     || !list_empty(&req->queue)) {
+
+		dwc2dbg("%s: bad params\n", __func__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+
+	if (!_ep || (!ep->desc && ep->ep.name != dwc2_get_ep0_name())) {
+
+		dwc2dbg("%s: bad ep: %s, %d, %p\n", __func__,
+		      ep->ep.name, !ep->desc, _ep);
+		return -EINVAL;
+	}
+
+	ep_num = ep_index(ep);
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == CH9_USB_SPEED_UNKNOWN) {
+
+		dwc2dbg("%s: bogus device state %p\n", __func__, dev->driver);
+		return -ESHUTDOWN;
+	}
+	reg = dev->reg;
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	dwc2dbg("\n*** %s: %s-%s req = %p, len = %d, buf = %p Q empty = %d, stopped = %d\n",
+			__func__, _ep->name, ep_is_in(ep) ? "in" : "out",
+			_req, _req->length, _req->buf,
+			list_empty(&ep->queue), ep->stopped);
+
+#ifdef DWC2_DBG
+	{
+		int i, len = _req->length;
+
+		tf_printf("pkt = ");
+		if (len > 64)
+			len = 64;
+		for (i = 0; i < len; i++) {
+			tf_printf("%02x", ((uint8_t *)_req->buf)[i]);
+			if ((i & 7) == 7)
+				tf_printf(" ");
+		}
+		tf_printf("\n");
+	}
+#endif
+
+	if (list_empty(&ep->queue) && !ep->stopped) {
+
+		if (ep_num == 0) {
+			/* EP0 */
+			list_add_tail(&req->queue, &ep->queue);
+			dwc2_ep0_kick(dev, ep);
+			req = 0;
+
+		} else if (ep_is_in(ep)) {
+			gintsts = DWC2_UncachedRead32(&reg->gintsts);
+			dwc2dbg_cond(DEBUG_IN_EP,
+				   "%s: ep_is_in, DWC2_UDC_OTG_GINTSTS=0x%x\n",
+				   __func__, gintsts);
+
+			setdma_tx(ep, req);
+		} else {
+			gintsts = DWC2_UncachedRead32(&reg->gintsts);
+			dwc2dbg_cond(DEBUG_OUT_EP != 0,
+				   "%s:ep_is_out, DWC2_UDC_OTG_GINTSTS=0x%x\n",
+				   __func__, gintsts);
+
+			setdma_rx(ep, req);
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (req != 0)
+		list_add_tail(&req->queue, &ep->queue);
+
+	return 0;
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+int dwc2_write_fifo_ep0(struct dwc2_ep *ep, struct dwc2_request *req)
+{
+	uint32_t max;
+	unsigned int count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	dwc2dbg_cond(DEBUG_EP0 != 0, "%s: max = %d\n", __func__, max);
+
+	count = setdma_tx(ep, req);
+
+	/* last packet is usually short (or a zlp) */
+	if (count != max)
+		is_last = 1;
+	else {
+		if ((req->req.length != req->req.actual + count)
+		    || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	dwc2dbg_cond(DEBUG_EP0 != 0,
+		   "%s: wrote %s %d bytes%s %d left %p\n", __func__,
+		   ep->ep.name, count,
+		   is_last ? "/L" : "",
+		   req->req.length - req->req.actual - count, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		ep->dev->ep0state = WAIT_FOR_SETUP;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int dwc2_fifo_read(struct dwc2_ep *ep, uintptr_t *cp, int max)
+{
+	// DWC2_CacheInvalidate((uintptr_t)cp, ROUND(max, CONFIG_SYS_CACHELINE_SIZE));
+	// inv_dcache_range((unsigned long)cp, ROUND(max, CONFIG_SYS_CACHELINE_SIZE));
+
+	dwc2dbg_cond(DEBUG_EP0 != 0,
+		   "%s: bytes=%d, ep_index=%d 0x%p\n", __func__,
+		   max, ep_index(ep), cp);
+
+	return max;
+}
+
+/**
+ * dwc2_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+void dwc2_set_address(struct dwc2_udc *dev, unsigned char address)
+{
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	uint32_t ctrl = DWC2_UncachedRead32(&reg->dcfg);
+
+	DWC2_UncachedWrite32(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
+
+	dwc2_udc_ep0_zlp(dev);
+
+	dwc2dbg_cond(DEBUG_EP0 != 0,
+		   "%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
+		   __func__, address, DWC2_UncachedRead32(&reg->dcfg));
+
+	dev->usb_address = address;
+	dev->connected = 1;
+}
+
+static inline void dwc2_udc_ep0_set_stall(struct dwc2_ep *ep, uint32_t is_in)
+{
+	struct dwc2_udc *dev = ep->dev;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+	uint32_t		ep_ctrl = 0;
+
+	dwc2_log_write(0x087087, is_in, 0, 0, 0);
+
+	if (is_in)
+		ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl);
+	else
+		ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[EP0_CON].doepctl);
+
+	/* set the disable and stall bits */
+	//if (ep_ctrl & DEPCTL_EPENA)
+	//	ep_ctrl |= DEPCTL_EPDIS;
+
+	ep_ctrl |= DEPCTL_STALL;
+
+	if (is_in) {
+		DWC2_UncachedWrite32(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
+		dwc2dbg_cond(DEBUG_EP0 != 0,
+			   "%s: set ep%d stall, DIEPCTL0 = 0x%p\n",
+			   __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
+	} else {
+		DWC2_UncachedWrite32(ep_ctrl, &reg->out_endp[EP0_CON].doepctl);
+		dwc2dbg_cond(DEBUG_EP0 != 0,
+			   "%s: set ep%d stall, DOEPCTL0 = 0x%p\n",
+			   __func__, ep_index(ep), &reg->out_endp[EP0_CON].doepctl);
+	}
+
+	/*
+	 * The application can only set this bit, and the core clears it,
+	 * when a SETUP token is received for this endpoint
+	 */
+	dev->ep0state = WAIT_FOR_SETUP;
+
+#ifdef DWC2_DMA_EN
+	dwc2_udc_pre_setup(dev);
+#endif
+}
+
+void dwc2_ep0_read(struct dwc2_udc *dev)
+{
+	struct dwc2_request *req;
+	struct dwc2_ep *ep = &dev->ep[0];
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct dwc2_request, queue);
+
+	} else {
+		dwc2dbg("%s: ---> BUG\n", __func__);
+		return;
+	}
+
+	dwc2dbg_cond(DEBUG_EP0 != 0,
+		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
+		   __func__, req, req->req.length, req->req.actual);
+
+	if (req->req.length == 0) {
+		/* zlp for Set_configuration, Set_interface, or Bulk-Only mass storge reset */
+
+		ep->len = 0;
+		dwc2_udc_ep0_zlp(dev);
+
+		dwc2dbg_cond(DEBUG_EP0 != 0,
+			   "%s: req.length = 0, bRequest = %d\n",
+			   __func__, dev->usb_ctrl->bRequest);
+		return;
+	}
+
+	setdma_rx(ep, req);
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+int dwc2_ep0_write(struct dwc2_udc *dev)
+{
+	struct dwc2_request *req;
+	struct dwc2_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct dwc2_request, queue);
+
+	if (!req) {
+		dwc2dbg_cond(DEBUG_EP0 != 0, "%s: NULL REQ\n", __func__);
+		return 0;
+	}
+
+	dwc2dbg_cond(DEBUG_EP0 != 0,
+		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
+		   __func__, req, req->req.length, req->req.actual);
+
+	// if (req->req.length - req->req.actual == ep0_fifo_size) {
+	// /* Next write will end with the packet size, */
+	// /* so we need Zero-length-packet */
+	// need_zlp = 1;
+	// }
+
+	ret = dwc2_write_fifo_ep0(ep, req);
+
+	if ((ret == 1) && !need_zlp) {
+		/* Last packet */
+		dev->ep0state = WAIT_FOR_COMPLETE;
+		dwc2dbg_cond(DEBUG_EP0 != 0,
+			   "%s: finished, waiting for status\n", __func__);
+
+	} else {
+		dev->ep0state = DATA_STATE_XMIT;
+		dwc2dbg_cond(DEBUG_EP0 != 0,
+			   "%s: not finished\n", __func__);
+	}
+
+	return 1;
+}
+
+static int dwc2_udc_get_status(struct dwc2_udc *dev,
+		CH9_UsbSetup *crq)
+{
+	uint8_t ep_num = dwc2_phy_to_log_ep(crq->wIndex & 0x7F, !!(crq->wIndex & 0x80));
+	uint16_t g_status = 0;
+	uint32_t ep_ctrl;
+	struct dwc2_usbotg_reg *reg = dev->reg;
+
+	dwc2dbg_cond(DEBUG_SETUP != 0,
+		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
+	tf_printf("crq->brequest:0x%x\n", crq->bmRequestType & CH9_REQ_RECIPIENT_MASK);
+	switch (crq->bmRequestType & CH9_REQ_RECIPIENT_MASK) {
+	case CH9_USB_REQ_RECIPIENT_INTERFACE:
+		g_status = 0;
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tGET_STATUS:CH9_USB_REQ_RECIPIENT_INTERFACE, g_stauts = %d\n",
+			   g_status);
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_DEVICE:
+		g_status = 0x1; /* Self powered */
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tGET_STATUS: CH9_USB_REQ_RECIPIENT_DEVICE, g_stauts = %d\n",
+			   g_status);
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_ENDPOINT:
+		if (crq->wLength > 2) {
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tGET_STATUS:Not support EP or wLength\n");
+			return 1;
+		}
+
+		g_status = dev->ep[ep_num].stopped;
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tGET_STATUS: CH9_USB_REQ_RECIPIENT_ENDPOINT, g_stauts = %d\n",
+			   g_status);
+
+		break;
+
+	default:
+		return 1;
+	}
+
+	memcpy(dev->usb_ctrl, &g_status, sizeof(g_status));
+
+	// DWC2_CacheFlush((unsigned long) dev->usb_ctrl, ROUND(sizeof(g_status), CONFIG_SYS_CACHELINE_SIZE));
+	// flush_dcache_range((unsigned long)dev->usb_ctrl, ROUND(sizeof(g_status), CONFIG_SYS_CACHELINE_SIZE));
+
+	DWC2_UncachedWrite32(dev->usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
+	DWC2_UncachedWrite32(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
+	       &reg->in_endp[EP0_CON].dieptsiz);
+
+	ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[EP0_CON].diepctl);
+	ep_ctrl &= ~(1 << 30);
+	DWC2_UncachedWrite32(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
+	       &reg->in_endp[EP0_CON].diepctl);
+	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
+
+	return 0;
+}
+
+void dwc2_udc_set_nak(struct dwc2_ep *ep)
+{
+	uint8_t		ep_num;
+	uint32_t		ep_ctrl = 0;
+	struct dwc2_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+	dwc2dbg("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl);
+		ep_ctrl |= DEPCTL_SNAK;
+		DWC2_UncachedWrite32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+		dwc2dbg("%s: set NAK, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl));
+	} else {
+		ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl);
+		ep_ctrl |= DEPCTL_SNAK;
+		DWC2_UncachedWrite32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+		dwc2dbg("%s: set NAK, DOEPCTL%d = 0x%x\n",
+		      __func__, ep_num, DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl));
+	}
+}
+
+
+static void dwc2_udc_ep_set_stall(struct dwc2_ep *ep)
+{
+	uint8_t		ep_num;
+	uint32_t		ep_ctrl = 0;
+	struct dwc2_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+	dwc2dbg("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl);
+
+		/* set the disable and stall bits */
+		if (ep_ctrl & DEPCTL_EPENA)
+			ep_ctrl |= DEPCTL_EPDIS;
+
+		ep_ctrl |= DEPCTL_STALL;
+
+		DWC2_UncachedWrite32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+		dwc2dbg("%s: set stall, DIEPCTL%d = 0x%x\n",
+		      __func__, ep_num, DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl));
+
+	} else {
+		ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl);
+
+		/* set the stall bit */
+		ep_ctrl |= DEPCTL_STALL;
+
+		DWC2_UncachedWrite32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+		dwc2dbg("%s: set stall, DOEPCTL%d = 0x%x\n",
+		      __func__, ep_num, DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl));
+	}
+}
+
+static void dwc2_udc_ep_clear_stall(struct dwc2_ep *ep)
+{
+	uint8_t		ep_num;
+	uint32_t		ep_ctrl = 0;
+	struct dwc2_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+	dwc2dbg("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl);
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		/*
+		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
+		 * of whether an endpoint has the Halt feature set, a
+		 * ClearFeature(ENDPOINT_HALT) request always results in the
+		 * data toggle being reinitialized to DATA0.
+		 */
+		if (ep->bmAttributes == CH9_USB_EP_INTERRUPT
+		    || ep->bmAttributes == CH9_USB_EP_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		DWC2_UncachedWrite32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+		dwc2dbg("%s: cleared stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl));
+
+	} else {
+		ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl);
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		if (ep->bmAttributes == CH9_USB_EP_INTERRUPT
+		    || ep->bmAttributes == CH9_USB_EP_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		DWC2_UncachedWrite32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+		dwc2dbg("%s: cleared stall, DOEPCTL%d = 0x%x\n",
+		      __func__, ep_num, DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl));
+	}
+}
+
+int dwc2_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct dwc2_ep	*ep;
+	struct dwc2_udc	*dev;
+	uint8_t		ep_num;
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	ep_num = ep_index(ep);
+
+	if (!_ep || !ep->desc || ep_num == EP0_CON ||
+		     ep->desc->bmAttributes == CH9_USB_EP_ISOCHRONOUS) {
+		dwc2dbg("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
+		return -EINVAL;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests are still queue */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		dwc2dbg("%s: %s queue not empty, req = %p\n",
+			__func__, ep->ep.name,
+			list_entry(ep->queue.next, struct dwc2_request, queue));
+
+		return -EAGAIN;
+	}
+
+	dev = ep->dev;
+	dwc2dbg("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);
+
+	if (value == 0) {
+		ep->stopped = 0;
+		dwc2_udc_ep_clear_stall(ep);
+	} else {
+		if (ep_num == 0)
+			dev->ep0state = WAIT_FOR_SETUP;
+
+		ep->stopped = 1;
+		dwc2_udc_ep_set_stall(ep);
+	}
+
+	return 0;
+}
+
+void dwc2_udc_ep_activate(struct dwc2_ep *ep)
+{
+	uint8_t ep_num;
+	uint32_t ep_ctrl = 0, daintmsk = 0;
+	struct dwc2_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+
+	/* Read DEPCTLn register */
+	if (ep_is_in(ep)) {
+		ep_ctrl = DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl);
+		daintmsk = 1 << ep_num;
+	} else {
+		ep_ctrl = DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl);
+		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
+	}
+
+	dwc2dbg("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
+		__func__, ep_num, ep_ctrl, ep_is_in(ep));
+
+	/* If the EP is already active don't change the EP Control register. */
+	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
+		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
+			(ep->bmAttributes << DEPCTL_TYPE_BIT);
+		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
+			(ep->ep.maxpacket << DEPCTL_MPS_BIT);
+		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
+
+		if (ep_is_in(ep)) {
+			DWC2_UncachedWrite32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+			dwc2dbg("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
+			      __func__, ep_num, ep_num,
+			      DWC2_UncachedRead32(&reg->in_endp[ep_num].diepctl));
+		} else {
+			DWC2_UncachedWrite32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+			dwc2dbg("%s: USB Ative EP%d, DOEPCTRL%d = 0x%x\n",
+			      __func__, ep_num, ep_num,
+			      DWC2_UncachedRead32(&reg->out_endp[ep_num].doepctl));
+		}
+	}
+
+	/* Unmask EP Interrtupt */
+	DWC2_UncachedWrite32(DWC2_UncachedRead32(&reg->daintmsk)|daintmsk, &reg->daintmsk);
+	dwc2dbg("%s: DAINTMSK = 0x%x\n", __func__, DWC2_UncachedRead32(&reg->daintmsk));
+
+}
+
+static int dwc2_udc_clear_feature(struct usb_ep *_ep)
+{
+	struct dwc2_udc	*dev;
+	struct dwc2_ep	*ep;
+	uint8_t		ep_num;
+	CH9_UsbSetup *usb_ctrl;
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	ep_num = ep_index(ep);
+
+	dev = ep->dev;
+	usb_ctrl = dev->usb_ctrl;
+
+	dwc2dbg_cond(DEBUG_SETUP != 0,
+		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
+		   __func__, ep_num, ep_is_in(ep), dev->clear_feature_flag);
+
+	if (usb_ctrl->wLength != 0) {
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
+		return 1;
+	}
+
+	switch (usb_ctrl->bmRequestType & CH9_REQ_RECIPIENT_MASK) {
+	case CH9_USB_REQ_RECIPIENT_DEVICE:
+		switch (usb_ctrl->wValue) {
+		case CH9_USB_FS_DEVICE_REMOTE_WAKEUP:
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tOFF:USB_DEVICE_REMOTE_WAKEUP\n");
+			break;
+
+		case CH9_USB_FS_TEST_MODE:
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
+			/** @todo Add CLEAR_FEATURE for TEST modes. */
+			break;
+		}
+
+		dwc2_udc_ep0_zlp(dev);
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_ENDPOINT:
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tCLEAR_FEATURE:CH9_USB_REQ_RECIPIENT_ENDPOINT, wValue = %d\n",
+			   usb_ctrl->wValue);
+
+		if (usb_ctrl->wValue == CH9_USB_FS_ENDPOINT_HALT) {
+			if (ep_num == 0) {
+				dwc2_udc_ep0_set_stall(ep, 1);
+				return 0;
+			}
+
+			dwc2_udc_ep0_zlp(dev);
+
+			dwc2_udc_ep_clear_stall(ep);
+			dwc2_udc_ep_activate(ep);
+			ep->stopped = 0;
+
+			dev->clear_feature_num = ep_num;
+			dev->clear_feature_flag = 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static int dwc2_udc_set_feature(struct usb_ep *_ep)
+{
+	struct dwc2_udc	*dev;
+	struct dwc2_ep	*ep;
+	uint8_t		ep_num;
+	CH9_UsbSetup *usb_ctrl;
+
+	ep = container_of(_ep, struct dwc2_ep, ep);
+	ep_num = ep_index(ep);
+	dev = ep->dev;
+	usb_ctrl = dev->usb_ctrl;
+
+	dwc2dbg_cond(DEBUG_SETUP != 0,
+		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
+		    __func__, ep_num);
+
+	if (usb_ctrl->wLength != 0) {
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tSET_FEATURE: wLength is not zero.....\n");
+		return 1;
+	}
+
+	switch (usb_ctrl->bmRequestType & CH9_REQ_RECIPIENT_MASK) {
+	case CH9_USB_REQ_RECIPIENT_DEVICE:
+		switch (usb_ctrl->wValue) {
+		case CH9_USB_FS_DEVICE_REMOTE_WAKEUP:
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tSET_FEATURE:USB_DEVICE_REMOTE_WAKEUP\n");
+			break;
+		case CH9_USB_FS_B_HNP_ENABLE:
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tSET_FEATURE: USB_DEVICE_B_HNP_ENABLE\n");
+			break;
+
+		case CH9_USB_FS_A_HNP_SUPPORT:
+			/* RH port supports HNP */
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tSET_FEATURE:USB_DEVICE_A_HNP_SUPPORT\n");
+			break;
+
+		case CH9_USB_FS_A_ALT_HNP_SUPPORT:
+			/* other RH port does */
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tSET: USB_DEVICE_A_ALT_HNP_SUPPORT\n");
+			break;
+		case CH9_USB_FS_TEST_MODE:
+			dev->test_mode = usb_ctrl->wIndex >> 8;
+			break;
+		}
+
+		dwc2_udc_ep0_zlp(dev);
+		return 0;
+
+	case CH9_USB_REQ_RECIPIENT_INTERFACE:
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tSET_FEATURE: CH9_USB_REQ_RECIPIENT_INTERFACE\n");
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_ENDPOINT:
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tSET_FEATURE: CH9_USB_REQ_RECIPIENT_ENDPOINT\n");
+		if (usb_ctrl->wValue == CH9_USB_FS_ENDPOINT_HALT) {
+			if (ep_num == 0) {
+				dwc2_udc_ep0_set_stall(ep, 1);
+				return 0;
+			}
+			ep->stopped = 1;
+			dwc2_udc_ep_set_stall(ep);
+		}
+
+		dwc2_udc_ep0_zlp(dev);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * WAIT_FOR_SETUP (OUT_PKT_RDY)
+ */
+static void dwc2_ep0_setup(struct dwc2_udc *dev)
+{
+	struct dwc2_ep *ep = &dev->ep[0];
+	int i;
+	uint8_t ep_num;
+	CH9_UsbSetup *usb_ctrl = dev->usb_ctrl;
+	uint8_t three_stage = 0;
+
+	/* Nuke all previous transfers */
+	dwc2_nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	dwc2_fifo_read(ep, (uintptr_t *)usb_ctrl, 8);
+
+	// if (usb_ctrl->bRequest == 0)
+	// {
+	//	usb_ctrl->bRequest = 0x06;
+	//	usb_ctrl->wValue = 0x100;
+	// }
+
+	dwc2dbg_cond(DEBUG_SETUP != 0,
+				"%s: bmRequestType = 0x%x(%s), bRequest = 0x%x wLength = 0x%x, wValue = 0x%x, wIndex= 0x%x\n",
+				__func__, usb_ctrl->bmRequestType,
+				(usb_ctrl->bmRequestType & USB_DIR_IN) ? "IN" : "OUT",
+				usb_ctrl->bRequest,
+				usb_ctrl->wLength, usb_ctrl->wValue, usb_ctrl->wIndex);
+
+	three_stage = usb_ctrl->wLength ? 1 : 0;
+#ifdef DWC2_DBG
+	{
+		int i, len = sizeof(*usb_ctrl);
+		char *p = (char *)usb_ctrl;
+
+		tf_printf("pkt = ");
+		for (i = 0; i < len; i++) {
+			tf_printf("%02x", ((uint8_t *)p)[i]);
+			if ((i & 7) == 7)
+				tf_printf(" ");
+		}
+		tf_printf("\n");
+	}
+#endif
+
+	/* Set direction of EP0 */
+	if (usb_ctrl->bmRequestType & USB_DIR_IN) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+	}
+	/* cope with automagic for some standard requests. */
+	dev->req_std = (usb_ctrl->bmRequestType & CH9_USB_REQ_TYPE_MASK)
+		== CH9_USB_REQ_TYPE_STANDARD;
+
+	dev->req_pending = 1;
+
+	/* Handle some SETUP packets ourselves */
+	if (dev->req_std) {
+		switch (usb_ctrl->bRequest) {
+		case CH9_USB_REQ_SET_ADDRESS:
+			dwc2_log_write(0xBBBBB, 1, usb_ctrl->wValue, 0, 0);
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "%s: *** USB_REQ_SET_ADDRESS (%d)\n",
+			   __func__, usb_ctrl->wValue);
+			if (usb_ctrl->bmRequestType
+				!= (CH9_USB_REQ_TYPE_STANDARD | CH9_USB_REQ_RECIPIENT_DEVICE))
+				break;
+
+			dwc2_set_address(dev, usb_ctrl->wValue);
+			return;
+
+		case CH9_USB_REQ_SET_CONFIGURATION:
+			dwc2_log_write(0xBBBBB, 2, usb_ctrl->wValue, 0, 0);
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "=====================================\n");
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "%s: USB_REQ_SET_CONFIGURATION (%d)\n",
+				   __func__, usb_ctrl->wValue);
+
+			break;
+
+		case CH9_USB_REQ_GET_DESCRIPTOR:
+			dwc2_log_write(0xBBBBB, 3, 0, 0, 0);
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "%s: *** USB_REQ_GET_DESCRIPTOR\n",
+				   __func__);
+			break;
+
+		case CH9_USB_REQ_SET_INTERFACE:
+			dwc2_log_write(0xBBBBB, 4, 0, 0, 0);
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "%s: *** USB_REQ_SET_INTERFACE (%d)\n",
+				   __func__, usb_ctrl->wValue);
+
+			break;
+
+		case CH9_USB_REQ_GET_CONFIGURATION:
+			dwc2_log_write(0xBBBBB, 5, 0, 0, 0);
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "%s: *** USB_REQ_GET_CONFIGURATION\n",
+				   __func__);
+			break;
+
+		case CH9_USB_REQ_GET_STATUS:
+			dwc2_log_write(0xBBBBB, 6, 0, 0, 0);
+			if (!dwc2_udc_get_status(dev, usb_ctrl))
+				return;
+
+			break;
+
+		case CH9_USB_REQ_CLEAR_FEATURE:
+			dwc2_log_write(0xBBBBB, 7, 0, 0, 0);
+			ep_num = dwc2_phy_to_log_ep(usb_ctrl->wIndex & 0x7F, !!(usb_ctrl->wIndex & 0x80));
+
+			if (!dwc2_udc_clear_feature(&dev->ep[ep_num].ep))
+				return;
+
+			break;
+
+		case CH9_USB_REQ_SET_FEATURE:
+			dwc2_log_write(0xBBBBB, 8, 0, 0, 0);
+			ep_num = dwc2_phy_to_log_ep(usb_ctrl->wIndex & 0x7F, !!(usb_ctrl->wIndex & 0x80));
+
+			if (!dwc2_udc_set_feature(&dev->ep[ep_num].ep))
+				return;
+
+			break;
+
+		default:
+			dwc2_log_write(0xBBBBB, 9, 0, 0, 0);
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+						"%s: *** Default of usb_ctrl->bRequest=0x%x happened.\n",
+						__func__, usb_ctrl->bRequest);
+			break;
+		}
+	}
+
+	if (dev->driver) {
+		/* device-2-host (IN) or no data setup command, process immediately */
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "%s:usb_ctrlreq will be passed to fsg_setup()\n",
+			    __func__);
+
+		i = dev->driver->setup(&dev->gadget, usb_ctrl);
+
+		if (i < 0) {
+			uint32_t dir = (usb_ctrl->wLength == 0) ? 1 : ep_is_in(ep);
+			/* setup processing failed, force stall */
+			dwc2_udc_ep0_set_stall(ep, dir);
+			dev->ep0state = WAIT_FOR_SETUP;
+
+			dwc2dbg_cond(DEBUG_SETUP != 0, "\tdev->driver->setup failed (%d), bRequest = %d\n",
+						i, usb_ctrl->bRequest);
+			return;
+
+
+		} else if (dev->req_pending) {
+			dev->req_pending = 0;
+			dwc2dbg_cond(DEBUG_SETUP != 0,
+				   "\tdev->req_pending...\n");
+		}
+
+		dwc2dbg_cond(DEBUG_SETUP != 0,
+			   "\tep0state = %s\n", state_names[dev->ep0state]);
+
+	}
+
+	if (!three_stage)
+		dwc2_udc_ep0_zlp(dev);
+}
+
+/*
+ * handle ep0 interrupt
+ */
+void dwc2_handle_ep0(struct dwc2_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP) {
+		dwc2dbg_cond(DEBUG_OUT_EP != 0,
+			   "%s: WAIT_FOR_SETUP\n", __func__);
+		dwc2_ep0_setup(dev);
+
+	} else {
+		dwc2dbg_cond(DEBUG_OUT_EP != 0,
+			   "%s: strange state!!(state = %s)\n",
+			__func__, state_names[dev->ep0state]);
+	}
+}
+
+void dwc2_ep0_kick(struct dwc2_udc *dev, struct dwc2_ep *ep)
+{
+	dwc2dbg_cond(DEBUG_EP0 != 0,
+		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		dwc2_ep0_write(dev);
+
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		dwc2_ep0_read(dev);
+	}
+}
diff --git a/firmware/plat/cv180x/usb/usb_tty.c b/firmware/plat/cv180x/usb/usb_tty.c
new file mode 100644
index 0000000..e1613d8
--- /dev/null
+++ b/firmware/plat/cv180x/usb/usb_tty.c
@@ -0,0 +1,986 @@
+/**********************************************************************
+ *
+ * usb_tty.c
+ * ACM class application.
+ *
+ ***********************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <crc16.h>
+#include <delay_timer.h>
+#include "platform.h"
+#include "debug.h"
+#include "cv_usb.h"
+#include "mmio.h"
+#include "platform.h"
+#include "utils.h"
+
+#include "usb_tty.h"
+#include <cv_usb.h>
+#include <dwc2_ch9.h>
+#include <dwc2_drv_if.h>
+#include "dwc2_udc_otg_regs.h"
+#include "dwc2_udc_otg_priv.h"
+#include <dwc2_udc.h>
+#include <dwc2_errno.h>
+#include <security/efuse.h>
+
+static uint32_t ts;
+static uint64_t fip_buf;
+static uint32_t fip_tx_offset;
+static uint32_t fip_tx_size;
+
+// dwc2 USB driver object
+static struct dwc2_drv_obj drv_obj = {
+	.plat = {
+		.regs_otg = USB_BASE, // address where USB core is mapped
+		.usb_gusbcfg    = 0x40081408,
+		.rx_fifo_sz     = 512,
+		.np_tx_fifo_sz  = 512,
+		.tx_fifo_sz     = 512,
+	},
+};
+
+//variable declare
+static uint8_t *bulkBuf, *cmdBuf, *ep0Buff;
+static struct usb_ep *epIn, *epOut, *epInNotify;
+// request used by driver
+static struct usb_request *bulkInReq, *bulkOutReq, *ep0Req, *IntInReq;
+static uint8_t configValue;
+static uint8_t configBreak;
+uint8_t acm_configValue;
+static uint8_t current_speed = CH9_USB_SPEED_UNKNOWN;
+static uint8_t mem_alloc_cnt;
+static uint32_t transfer_size;
+static uint8_t flagEnterDL;
+static uint8_t flagReboot;
+struct f_acm *acm;
+
+static uint8_t *bulkBufAlloc = (uint8_t *)BLK_BUF_ADDR; // 512
+static uint8_t *cmdBufAlloc = (uint8_t *)CMD_BUF_ADDR; // 512
+static uint8_t *cb0_buf = (uint8_t *)CB0_BUF_ADDR; // 128
+static uint8_t *cb1_buf = (uint8_t *)CB1_BUF_ADDR; // 128
+static uint8_t *cb2_buf = (uint8_t *)CB2_BUF_ADDR; // 64
+static uint8_t *ep0BuffAlloc = (uint8_t *)EP0_BUF_ADDR; // 32
+static uint8_t *rsp_buf = (uint8_t *)RSP_BUF_ADDR; // 128
+static uint8_t *acm_buf = (uint8_t *)ACM_BUF_ADDR; // 128
+static uint8_t *setup_buf = (uint8_t *)STP_BUF_ADDR; // 32
+static uint8_t *handler = (uint8_t *)HANDLER_ADDR; // 1024
+
+// string will be filled then in initializing section
+static char vendorDesc[sizeof(USB_MANUFACTURER_STRING) * 2 + 2];
+static char productDesc[sizeof(USB_PRODUCT_STRING) * 2 + 2];
+static char serialDesc[sizeof(USB_SERIAL_NUMBER_STRING) * 2 + 2];
+
+typedef void func(void);
+
+static void init_param(void)
+{
+	bulkBuf = NULL;
+	cmdBuf = NULL;
+	ep0Buff = NULL;
+	epIn = NULL;
+	epOut = NULL;
+	epInNotify = NULL;
+	bulkInReq = NULL;
+	bulkOutReq = NULL;
+	ep0Req = NULL;
+	IntInReq = NULL;
+	configValue = 0;
+	configBreak = 0;
+	acm_configValue = 0;
+	current_speed = CH9_USB_SPEED_UNKNOWN;
+	mem_alloc_cnt = 0;
+	transfer_size = 0;
+	acm = NULL;
+	flagReboot = 0;
+}
+
+uint8_t bulkBufAllocArr[BUF_SIZE] __aligned(64);
+uint8_t cmdBufAllocArr[BUF_SIZE]  __aligned(64);
+uint8_t cb0_bufArr[CB_SIZE]  __aligned(64);
+uint8_t cb1_bufArr[CB_SIZE]  __aligned(64);
+uint8_t cb2_bufArr[CB_SIZE]  __aligned(64);
+uint8_t ep0BuffAllocArr[EP0_SIZE]  __aligned(64);
+uint8_t rsp_bufArr[RSP_SIZE]  __aligned(64);
+uint8_t acm_bufArr[ACM_SIZE]  __aligned(64);
+uint8_t setup_bufArr[STP_SIZE]  __aligned(64);
+uint8_t handlerArr[HANDLER_SIZE]  __aligned(64);
+void convert_buf_addr(void)
+{
+	bulkBufAlloc = bulkBufAllocArr;
+	cmdBufAlloc = cmdBufAllocArr;
+	cb0_buf = cb0_bufArr;
+	cb1_buf = cb1_bufArr;
+	cb2_buf = cb2_bufArr;
+	ep0BuffAlloc = ep0BuffAllocArr;
+	rsp_buf = rsp_bufArr;
+	acm_buf = acm_bufArr;
+	setup_buf = setup_bufArr;
+	handler = handlerArr;
+}
+
+void print_buf_addr(void)
+{
+	INFO("bulkBufAlloc: %p\n", bulkBufAlloc);
+	INFO("cmdBufAlloc: %p\n", cmdBufAlloc);
+	INFO("cb0_buf: %p\n", cb0_buf);
+	INFO("cb1_buf: %p\n", cb1_buf);
+	INFO("cb2_buf: %p\n", cb2_buf);
+	INFO("ep0BuffAlloc: %p\n", ep0BuffAlloc);
+	INFO("rsp_buf: %p\n", rsp_buf);
+	INFO("acm_buf: %p\n", acm_buf);
+	INFO("setup_buf: %p\n", setup_buf);
+	INFO("handler: %p\n", handler);
+}
+
+// interrupt handler
+void AcmIsr(void)
+{
+	usb_gadget_handle_interrupts(0);
+}
+
+static int getDescAcm(CH9_UsbSpeed speed, uint8_t *acmDesc)
+{
+	int i = 0;
+	void *desc;
+	int sum = 0;
+	void *(*tab)[];
+
+	switch (speed) {
+	case CH9_USB_SPEED_FULL:
+		tab = &descriptorsFs;
+		break;
+	case CH9_USB_SPEED_HIGH:
+		tab = &descriptorsHs;
+		break;
+
+	default:
+		return -1;
+	}
+
+	desc = (*tab)[i];
+
+	while (desc) {
+		int length = *(uint8_t *)desc;
+
+		VERBOSE("acm get length %d\n", length);
+		memcpy(&acmDesc[sum], desc, length);
+		sum += length;
+		desc = (*tab)[++i];
+	}
+	////VERBOSE("acm get sum:%d\n", sum);
+	return sum;
+}
+
+static void clearReq(struct usb_request *req)
+{
+	memset(req, 0, sizeof(*req));
+}
+
+static void reset(struct usb_gadget *gadget)
+{
+	INFO("Application: %s\n", __func__);
+}
+
+static void disconnect(struct usb_gadget *gadget)
+{
+	acm_configValue = 0;
+	mem_alloc_cnt = 1;
+	configValue = 0;
+	INFO("Application: %s\n", __func__);
+}
+
+static void resume(struct usb_gadget *gadget)
+{
+	VERBOSE("Application: %s\n", __func__);
+}
+
+static void reqComplete(struct usb_ep *ep, struct usb_request *req)
+{
+	VERBOSE("Request on endpoint completed\n");
+	if (req->status == -EIO) {
+		INFO("IO Abort !!!!!\n");
+		flagReboot = 1;
+	}
+}
+
+static void suspend(struct usb_gadget *gadget)
+{
+	VERBOSE("Application: %s\n", __func__);
+}
+
+static void *requestMemAlloc(struct usb_gadget *gadget, uint32_t requireSize)
+{
+	void *ptr;
+	// VERBOSE("requestMemAlloc: size %d\n", requireSize);
+	if (mem_alloc_cnt == 0) {
+		ptr = cb0_buf;
+	} else if (mem_alloc_cnt == 1) {
+		ptr = cb1_buf;
+	} else {
+		ptr = cb2_buf;
+	}
+	VERBOSE("%s: ptr %p, size %d, mem_alloc_cnt %d\n", __func__, ptr, requireSize, mem_alloc_cnt);
+	mem_alloc_cnt++;
+	return ptr;
+}
+
+static void requestMemFree(struct usb_gadget *gadget, void *usbRequest)
+{
+}
+
+static void bulkInCmpl(struct usb_ep *ep, struct usb_request *req)
+{
+	if (req->status == -ESHUTDOWN)
+		return;
+
+	VERBOSE("%s\n", __func__);
+	memset(cmdBuf, 0x00, HEADER_SIZE); //next time init
+	bulkOutReq->length = transfer_size;
+	bulkOutReq->buf = cmdBuf;
+	bulkOutReq->dma = (uintptr_t)cmdBuf;
+	// INFO ("epOut->ops->queue\n");
+	epOut->ops->queue(epOut, bulkOutReq);
+}
+
+static void bulkOutCmpl(struct usb_ep *ep, struct usb_request *req)
+{
+	static uint8_t ack_idx;
+	void *dest_addr = 0x0;
+	uint16_t crc;
+	uint16_t magic;
+	uint32_t *flag = (uint32_t *)BOOT_SOURCE_FLAG_ADDR;
+#if DBG_USB
+	uint32_t i;
+#endif
+
+	if (req->status == -ESHUTDOWN)
+		return;
+
+	CVI_USB_TOKEN token = ((uint8_t *)req->buf)[0];
+	uint32_t length = (((uint8_t *)req->buf)[1] << 8) + (((uint8_t *)req->buf)[2]);
+
+	dest_addr =
+		(void *)(((uint64_t)(((uint8_t *)req->buf)[3]) << 32) + ((uint64_t)(((uint8_t *)req->buf)[4]) << 24) +
+			 ((uint64_t)(((uint8_t *)req->buf)[5]) << 16) + ((uint64_t)(((uint8_t *)req->buf)[6]) << 8) +
+			 ((uint64_t)(((uint8_t *)req->buf)[7])));
+	VERBOSE("Transfer complete on ep:%02X %lu req\n", ep->address, (uintptr_t)req);
+
+#if DBG_USB
+	for (i = 0; i < 512; i++)
+		INFO("cmdBuf[%d] = %x\n", i, cmdBuf[i]);
+#endif
+
+	if (length == 0 && dest_addr == 0) {
+		bulkOutReq->length = transfer_size;
+		bulkOutReq->buf = cmdBuf;
+		bulkOutReq->dma = (uintptr_t)cmdBuf;
+		VERBOSE("buffer zero\n");
+		epOut->ops->queue(epOut, bulkOutReq);
+		return;
+	}
+
+	crc = crc16_ccitt(0, cmdBuf, length);
+	VERBOSE("CRC: %x\n", crc);
+
+	switch (token) {
+	case CVI_USB_TX_DATA_TO_RAM:
+		memcpy((void *)((uint64_t)fip_buf + (uint64_t)dest_addr), cmdBuf + HEADER_SIZE, length - HEADER_SIZE);
+		break;
+
+	case CVI_USB_TX_FLAG:
+		if (dest_addr == (uint32_t *)BOOT_SOURCE_FLAG_ADDR)
+			memcpy((void *)(dest_addr), cmdBuf + HEADER_SIZE, BOOT_SOURCE_FLAG_SIZE);
+		break;
+
+	case CVI_USB_BREAK:
+		INFO("CVI_USB_BREAK\n");
+		ack_idx = 0;
+		configBreak = 1;
+		break;
+
+	case CVI_USB_KEEP_DL:
+		magic = crc16_ccitt(0, cmdBuf + HEADER_SIZE, length - HEADER_SIZE);
+		NOTICE("USBK.");
+		if (magic == 0xC283) {
+			ack_idx = 0;
+			flagEnterDL = 1;
+			*flag = 0;
+			INFO("flagEnterDL %d\n", flagEnterDL);
+		} else {
+			flagEnterDL = 0;
+			*flag = 0;
+			INFO("MAGIC NUM NOT MATCH\n");
+			// Failed to enter download mode
+			NOTICE("USBKF.");
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	memset(rsp_buf, 0, RSP_SIZE);
+	rsp_buf[0] = (crc >> 8) & 0xFF;
+	rsp_buf[1] = crc & 0xFF;
+	rsp_buf[2] = (crc >> 8) & 0xFF;
+	rsp_buf[3] = crc & 0xFF;
+	rsp_buf[4] = 0;
+	rsp_buf[5] = 0;
+	rsp_buf[6] = token;
+	rsp_buf[7] = ack_idx;
+	rsp_buf[8] = (fip_tx_offset >> 24) & 0xFF;
+	rsp_buf[9] = (fip_tx_offset >> 16) & 0xFF;
+	rsp_buf[10] = (fip_tx_offset >> 8) & 0xFF;
+	rsp_buf[11] = fip_tx_offset & 0xFF;
+	rsp_buf[12] = (fip_tx_size >> 24) & 0xFF;
+	rsp_buf[13] = (fip_tx_size >> 16) & 0xFF;
+	rsp_buf[14] = (fip_tx_size >> 8) & 0xFF;
+	rsp_buf[15] = fip_tx_size & 0xFF;
+	ack_idx++;
+
+	clearReq(bulkInReq);
+	bulkInReq->length = RSP_SIZE;
+	bulkInReq->buf = rsp_buf;
+	bulkInReq->dma = (uintptr_t)rsp_buf;
+	bulkInReq->complete = bulkInCmpl;
+	VERBOSE("rsp_buf epIn->ops->queue\n");
+	epIn->ops->queue(epIn, bulkInReq);
+}
+
+// functions aligns buffer to alignValue modulo address
+
+static uint8_t *alignBuff(void *notAllignedBuff, uint8_t alignValue)
+{
+	uint8_t offset = ((uintptr_t)notAllignedBuff) % alignValue;
+
+	if (offset == 0)
+		return (uint8_t *)notAllignedBuff;
+
+	uint8_t *ret_address = &(((uint8_t *)notAllignedBuff)[alignValue - offset]);
+	return ret_address;
+}
+
+/* ACM control ... data handling is delegated to tty library code.
+ * The main task of this function is to activate and deactivate
+ * that code based on device state; track parameters like line
+ * speed, handshake state, and so on; and issue notifications.
+ */
+
+static void acm_complete_set_line_coding(struct usb_ep *ep, struct usb_request *req)
+{
+	struct usb_cdc_line_coding *value = req->buf;
+
+	//VERBOSE("req buf : %d, %d, %d, %d\n",value->dwDTERate,value->bCharFormat,value->bParityType,value->bDataBits);
+	acm->port_line_coding = *value;
+	VERBOSE("acm data transfer complete\n");
+}
+
+static int bind(struct usb_gadget *gadget)
+{
+	INFO("usb %s\n", __func__);
+	if (drv_obj.gadget) {
+		NOTICE("USBB.");
+		return 0;
+	}
+	drv_obj.gadget = gadget;
+
+	return 0;
+}
+
+static void unbind(struct usb_gadget *gadget)
+{
+	INFO("usb %s\n", __func__);
+	drv_obj.gadget = NULL;
+}
+
+#if defined(USB_PHY_DETECTION)
+static void get_unicode_string(char *target, const char *src);
+
+#define EFUSE_SHADOW_REG (EFUSE_BASE + 0x100)
+#define EFUSE_FTSN1 (EFUSE_SHADOW_REG + 0x04)
+static uint32_t usb_patch_serial(char *target)
+{
+	static uint8_t is_serial_patched;
+	static char serial[16];
+	uint32_t ftsn[4];
+	uint8_t use_efuse_value = 0;
+	uint8_t i;
+	uint32_t val;
+
+	if (is_serial_patched == 0) {
+		memset(serial, 0, 16);
+
+		for (i = 0; i < 4; i++) {
+			ftsn[i] = mmio_read_32(EFUSE_FTSN1 + i * 4);
+			INFO("ftsn[%d] = %x\n", i, ftsn[i]);
+
+			if (ftsn[i] != 0)
+				use_efuse_value = 1;
+		}
+
+		if (use_efuse_value) {
+			val = crc16_ccitt(0, (unsigned char *)ftsn, 16);
+			INFO("crc val = %x\n", val);
+		} else {
+			val = get_random_from_timer(ts);
+			INFO("ts val = %x\n", val);
+		}
+
+		ntostr(serial, val, 16, 0);
+		is_serial_patched = 1;
+	}
+	NOTICE("USBS/%s.", serial);
+
+	get_unicode_string(target, serial);
+
+	return 0;
+}
+#endif
+
+static int setup(struct usb_gadget *gadget, const CH9_UsbSetup *ctrl)
+{
+	int is_vid_desc = 0;
+	int length = 0;
+	CH9_UsbDeviceDescriptor *devDesc;
+	CH9_UsbEndpointDescriptor *endpointEpInDesc, *endpointEpOutDesc, *endpointEpInDesc2;
+	CH9_UsbSetup TmpCtrl;
+
+	TmpCtrl.bRequest = ctrl->bRequest;
+	TmpCtrl.bmRequestType = ctrl->bmRequestType;
+	TmpCtrl.wIndex = le16ToCpu(ctrl->wIndex);
+	TmpCtrl.wLength = le16ToCpu(ctrl->wLength);
+	TmpCtrl.wValue = le16ToCpu(ctrl->wValue);
+
+	VERBOSE("Speed %d\n", gadget->speed);
+	VERBOSE("bRequest: %02X\n", TmpCtrl.bRequest);
+	VERBOSE("bRequestType: %02X\n", TmpCtrl.bmRequestType);
+	VERBOSE("wIndex: %04X\n", TmpCtrl.wIndex);
+	VERBOSE("wValue: %04X\n", TmpCtrl.wValue);
+	VERBOSE("wLength: %04X\n", TmpCtrl.wLength);
+
+	ep0Req->buf = ep0Buff;
+	ep0Req->dma = (uintptr_t)ep0Buff;
+	ep0Req->complete = reqComplete;
+
+	switch (gadget->speed) {
+	case CH9_USB_SPEED_FULL:
+		endpointEpInDesc = &acm_fs_in_desc;
+		endpointEpOutDesc = &acm_fs_out_desc;
+		endpointEpInDesc2 = &acm_fs_notify_desc;
+		devDesc = &devHsDesc;
+		break;
+
+	case CH9_USB_SPEED_HIGH:
+		endpointEpInDesc = &acm_hs_in_desc;
+		endpointEpOutDesc = &acm_hs_out_desc;
+		endpointEpInDesc2 = &acm_fs_notify_desc;
+		devDesc = &devHsDesc;
+		break;
+
+	default:
+		VERBOSE("Unknown speed %d\n", gadget->speed);
+		return 1;
+	}
+
+	switch (TmpCtrl.bmRequestType & CH9_USB_REQ_TYPE_MASK) {
+	case CH9_USB_REQ_TYPE_STANDARD:
+
+		switch (TmpCtrl.bRequest) {
+		case CH9_USB_REQ_GET_DESCRIPTOR:
+			VERBOSE("GET DESCRIPTOR %c\n", ' ');
+			if ((TmpCtrl.bmRequestType & CH9_REQ_RECIPIENT_MASK) == CH9_USB_REQ_RECIPIENT_INTERFACE) {
+				INFO("recipient target cannot be interface!\n");
+				return -1;
+			}
+			if ((TmpCtrl.bmRequestType & CH9_REQ_RECIPIENT_MASK) == CH9_USB_REQ_RECIPIENT_DEVICE) {
+				switch (TmpCtrl.wValue >> 8) {
+				case CH9_USB_DT_DEVICE:
+					length = CH9_USB_DS_DEVICE;
+					if (cv_usb_vid != 0) {
+						NOTICE("USBP/0x%x.", cv_usb_vid);
+						devDesc->idVendor = cpuToLe16(cv_usb_vid);
+					}
+					memmove(ep0Buff, devDesc, 18);
+					VERBOSE("DevDesc[0] = %d\n", devDesc->bLength);
+					for (int i = 0; i < length; i++) {
+						VERBOSE("%02X ", ep0Buff[i]);
+					VERBOSE(" %c\n", ' ');
+					}
+					is_vid_desc = 1;
+					break;
+
+				case CH9_USB_DT_CONFIGURATION: {
+					uint16_t acmDescLen =
+						(uint16_t)getDescAcm(gadget->speed, &ep0Buff[CH9_USB_DS_CONFIGURATION]);
+
+					length = le16ToCpu(acmDescLen + CH9_USB_DS_CONFIGURATION);
+					ConfDesc.wTotalLength = cpuToLe16(length);
+					memmove(ep0Buff, &ConfDesc, CH9_USB_DS_CONFIGURATION);
+					for (int i = 0; i < length; i++)
+						VERBOSE("%02X ", ep0Buff[i]);
+					VERBOSE(" %c\n", ' ');
+					break;
+				}
+
+				case CH9_USB_DT_STRING: {
+					uint8_t descIndex = (uint8_t)(TmpCtrl.wValue & 0xFF);
+					char *strDesc;
+
+					VERBOSE("StringDesc %c\n", ' ');
+					switch (descIndex) {
+					case 0:
+						strDesc = (char *)&languageDesc;
+						length = strDesc[0];
+						VERBOSE("language %c\n", ' ');
+						break;
+
+					case 1:
+						strDesc = (char *)&vendorDesc;
+						length = strDesc[0];
+						VERBOSE("vendor %c\n", ' ');
+						break;
+
+					case 2:
+						strDesc = (char *)&productDesc;
+						length = strDesc[0];
+						VERBOSE("product %c\n", ' ');
+						break;
+
+					case 3:
+#if defined(USB_PHY_DETECTION)
+					if (usb_id_det() == 0)
+						usb_patch_serial(serialDesc);
+					else
+						get_unicode_string(serialDesc, USB_SERIAL_NUMBER_STRING);
+#else
+					get_unicode_string(serialDesc, USB_SERIAL_NUMBER_STRING);
+#endif
+					strDesc = (char *)&serialDesc;
+					length = strDesc[0];
+					VERBOSE("serial %c\n", ' ');
+					break;
+
+					default:
+						return -1;
+					}
+					memmove(ep0Buff, strDesc, length);
+					break;
+				}
+
+				case CH9_USB_DT_BOS: {
+					int offset = 0;
+
+					length = le16ToCpu(bosDesc.wTotalLength);
+					memmove(ep0Buff, &bosDesc, CH9_USB_DS_BOS);
+					offset += CH9_USB_DS_BOS;
+					memmove(&ep0Buff[offset], &capabilityExtDesc, CH9_USB_DS_DEVICE_CAPABILITY_20);
+					break;
+				}
+
+				case CH9_USB_DT_DEVICE_QUALIFIER:
+					length = CH9_USB_DS_DEVICE_QUALIFIER;
+					memmove(ep0Buff, &qualifierDesc, length);
+					break;
+
+				case CH9_USB_DT_OTHER_SPEED_CONFIGURATION: {
+					uint16_t acmDescLen =
+						(uint16_t)getDescAcm(gadget->speed, &ep0Buff[CH9_USB_DS_CONFIGURATION]);
+
+					length = le16ToCpu(acmDescLen + CH9_USB_DS_CONFIGURATION);
+					ConfDesc.wTotalLength = cpuToLe16(length);
+					memmove(ep0Buff, &ConfDesc, CH9_USB_DS_CONFIGURATION);
+
+					for (int i = 0; i < length; i++)
+						VERBOSE("%02X ", ep0Buff[i]);
+
+					VERBOSE(" %c\n", ' ');
+
+					break;
+				}
+
+				default:
+					return -1;
+
+				} //switch
+			} //if
+			break;
+
+		case CH9_USB_REQ_SET_CONFIGURATION: {
+			struct usb_ep *ep;
+			struct list_head *list;
+
+			VERBOSE("SET CONFIGURATION(%d)\n", le16ToCpu(ctrl->wValue));
+			if (TmpCtrl.wValue > 1) {
+				return -1; // no such configuration
+			}
+			// unconfigure device
+			if (TmpCtrl.wValue == 0) {
+				configValue = 0;
+				for (list = gadget->ep_list.next; list != &gadget->ep_list; list = list->next) {
+					ep = (struct usb_ep *)list;
+					if (ep->name) {
+						ep->ops->disable(ep);
+					}
+				}
+				return 0;
+			}
+
+			// device already configured
+			if (configValue == 1 && TmpCtrl.wValue == 1) {
+				return 0;
+			}
+
+			// configure device
+			configValue = (uint8_t)TmpCtrl.wValue;
+			for (list = gadget->ep_list.next; list != &gadget->ep_list; list = list->next) {
+				ep = (struct usb_ep *)list;
+				if (ep->name && (!strcmp(ep->name, "ep1in-bulk"))) {
+					ep->ops->enable(ep, endpointEpInDesc);
+					VERBOSE("enable EP IN\n");
+					break;
+				}
+			}
+			for (list = gadget->ep_list.next; list != &gadget->ep_list; list = list->next) {
+				ep = (struct usb_ep *)list;
+				if ((ep->name && !strcmp(ep->name, "ep2out-bulk"))) {
+					ep->ops->enable(ep, endpointEpOutDesc);
+					VERBOSE("enable EP OUT\n");
+					break;
+				}
+			}
+			for (list = gadget->ep_list.next; list != &gadget->ep_list; list = list->next) {
+				ep = (struct usb_ep *)list;
+				if ((ep->name && !strcmp(ep->name, "ep3in-int"))) {
+					ep->ops->enable(ep, endpointEpInDesc2);
+					break;
+					VERBOSE("enable EP Notify\n");
+				}
+			}
+
+			/*Code control  Self powered feature of USB*/
+			if (ConfDesc.bmAttributes & CH9_USB_CONFIG_SELF_POWERED) {
+				if (gadget->ops->set_selfpowered) {
+					gadget->ops->set_selfpowered(gadget, 1);
+				}
+			} else {
+				if (gadget->ops->set_selfpowered) {
+					gadget->ops->set_selfpowered(gadget, 0);
+				}
+			}
+		}
+			return 0;
+
+		case CH9_USB_REQ_GET_CONFIGURATION:
+			length = 1;
+			memmove(ep0Buff, &configValue, length);
+			//VERBOSE("CH9_USB_REQ_GET_CONFIGURATION %c\n", ' ');
+			break;
+
+		default:
+			return -1; //return error
+		}
+		break;
+
+	case CH9_USB_REQ_TYPE_CLASS:
+		/* SET_LINE_CODING ... just read and save what the host sends */
+		switch (TmpCtrl.bRequest) {
+		case USB_CDC_REQ_SET_LINE_CODING:
+			length = TmpCtrl.wLength;
+			ep0Req->complete = acm_complete_set_line_coding;
+			VERBOSE("USB_CDC_REQ_SET_LINE_CODING %d\n", length);
+			acm_configValue = 1;
+			break;
+		case USB_CDC_REQ_SET_CONTROL_LINE_STATE:
+			acm->port_handshake_bits = TmpCtrl.wValue;
+			acm_configValue = 1;
+			VERBOSE("USB_CDC_REQ_SET_CONTROL_LINE_STATE %c\n", ' ');
+			break;
+		case USB_CDC_REQ_GET_LINE_CODING:
+			length = TmpCtrl.wLength;
+			memmove(ep0Buff, &acm->port_line_coding, length);
+			//ep0Req->complete = acm_complete_get_line_coding;
+			VERBOSE("USB_CDC_REQ_GET_LINE_CODING %d\n", length);
+			acm_configValue = 1;
+			break;
+		}
+		break;
+	}
+
+	if (length > 0) {
+		ep0Req->length = TmpCtrl.wLength < length ? TmpCtrl.wLength : length;
+		gadget->ep0->ops->queue(gadget->ep0, ep0Req);
+		if (is_vid_desc)
+			ATF_STATE = ATF_STATE_USB_SEND_VID_DONE;
+	}
+	return 0;
+}
+
+static void get_unicode_string(char *target, const char *src)
+{
+	size_t src_len = strlen(src) * 2;
+	int i;
+
+	*target++ = src_len + 2;
+	*target++ = CH9_USB_DT_STRING;
+
+	if (src_len > 100) {
+		src_len = 100;
+	}
+	for (i = 0; i < src_len; i += 2) {
+		*target++ = *src++;
+		*target++ = 0;
+	}
+}
+
+static struct usb_gadget_driver g_driver = {
+	.function = "TTY",
+	.speed = CH9_USB_SPEED_HIGH,
+	.bind = bind,
+	.unbind = unbind,
+	.setup = setup,
+	.reset = reset,
+	.disconnect = disconnect,
+	.suspend = suspend,
+	.resume = resume,
+	.req_mem_alloc = requestMemAlloc,
+	.req_mem_free = requestMemFree,
+};
+
+int acm_app_init(void)
+{
+	struct usb_ep *ep0 = drv_obj.gadget->ep0;
+
+	// set unicode strings
+	get_unicode_string(vendorDesc, USB_MANUFACTURER_STRING);
+	get_unicode_string(productDesc, USB_PRODUCT_STRING);
+
+	// align buffers to modulo32 address
+	ep0Buff = alignBuff(ep0BuffAlloc, CONFIG_SYS_CACHELINE_SIZE);
+	bulkBuf = alignBuff(bulkBufAlloc, CONFIG_SYS_CACHELINE_SIZE);
+	cmdBuf = alignBuff(cmdBufAlloc, CONFIG_SYS_CACHELINE_SIZE);
+	VERBOSE("bulkBuf %p bulkBufAlloc %p\n", bulkBuf, bulkBufAlloc);
+	VERBOSE("cmdBuf %p cmdBufAlloc %p\n", cmdBuf, cmdBufAlloc);
+	VERBOSE("ep0Buff %p ep0BuffAlloc %p\n", ep0Buff, ep0BuffAlloc);
+
+	memset(ep0BuffAlloc, 0x00, EP0_SIZE);
+	memset(bulkBufAlloc, 0x00, BUF_SIZE);
+	memset(cmdBufAlloc, 0x00, BUF_SIZE);
+
+	// allocate request for ep0
+	ep0Req = ep0->ops->alloc_request(ep0);
+
+	/*Change descriptor for maxSpeed == HS only Device*/
+	/*For USB2.0 we have to modified wTotalLength of BOS descriptor*/
+	if (drv_obj.gadget->max_speed < CH9_USB_SPEED_SUPER) {
+		bosDesc.wTotalLength = cpuToLe16(CH9_USB_DS_BOS + CH9_USB_DS_DEVICE_CAPABILITY_20);
+		bosDesc.bNumDeviceCaps = 1;
+		devHsDesc.bcdUSB = cpuToLe16(BCD_USB_HS_ONLY);
+	}
+
+	//acm init
+	acm = (struct f_acm *)acm_buf;
+	acm->port_line_coding.dwDTERate = 921600;
+	acm->port_line_coding.bCharFormat = USB_CDC_1_STOP_BITS;
+	acm->port_line_coding.bParityType = USB_CDC_NO_PARITY;
+	acm->port_line_coding.bDataBits = 8;
+	acm->port_handshake_bits = 0;
+	VERBOSE("acm size %lu\n", sizeof(struct f_acm));
+	return 0;
+}
+
+#if defined(USB_PHY_DETECTION)
+uint8_t usb_vbus_det(void)
+{
+	return ((mmio_read_32(REG_TOP_CONF_INFO) & BIT_TOP_USB_VBUS) >> SHIFT_TOP_USB_VBUS);
+}
+
+
+
+uint32_t get_usb_polling_timeout_value(void)
+{
+	uint32_t usb_polling_time = 1000;
+
+	if (usb_id_det() == 0) {
+		switch (get_sw_info()->usb_polling_time) {
+		case 0:
+			usb_polling_time = 10000;
+			break;
+		case 1:
+			usb_polling_time = DISABLE_TIMEOUT;
+			break;
+		default:
+			usb_polling_time = 1000;
+			break;
+		}
+	}
+
+	return usb_polling_time;
+}
+#endif
+
+int AcmApp(void *buf, uint32_t offset, uint32_t size)
+{
+	struct usb_gadget *gadget;
+	uint32_t res = 0; // keeps result of operation on driver
+	struct list_head *list; // used in for_each loop
+	struct usb_ep *ep;
+	uint32_t timeout_in_ms = 1000;
+	uint32_t *flag = (uint32_t *)BOOT_SOURCE_FLAG_ADDR;
+
+	fip_buf = (uint64_t)buf;
+	fip_tx_offset = offset;
+	fip_tx_size = size;
+	*flag = 0;
+
+#if defined(USB_PHY_DETECTION)
+	if (usb_vbus_det() == 0) {
+		INFO("USB vbus is off\n");
+		return -EIO;
+	}
+
+	timeout_in_ms = get_usb_polling_timeout_value();
+	INFO("timeout_in_ms %d\n", timeout_in_ms);
+	if (timeout_in_ms >= DISABLE_TIMEOUT) {
+		flagEnterDL = 1;
+		// Enter USB download by efuse config
+		NOTICE("USBC.");
+		ATF_STATE = ATF_STATE_USB_DL_BY_CONF_DONE;
+	}
+
+#endif
+	INFO("USB polling timeout_in_ms: %d\n", timeout_in_ms);
+_reboot:
+	init_param();
+	convert_buf_addr();
+	print_buf_addr();
+
+	drv_obj.plat.handler = (void *)handler;
+	drv_obj.plat.size = HANDLER_SIZE;
+	drv_obj.plat.ctrl_req = (void *)setup_buf;
+	res = dwc2_udc_probe(&drv_obj.plat);
+	if (res != 0) {
+		goto error;
+	}
+	// bind the gadget object here.
+	if (usb_gadget_register_driver(&g_driver) < 0) {
+		INFO("Gadget Register Fail\n");
+		goto error;
+	}
+	gadget = drv_obj.gadget;
+	if (!gadget) {
+		INFO("Gadget object not existed!\n");
+		goto error;
+	}
+
+	acm_app_init();
+
+	VERBOSE("Initializing OK! %d\n", __LINE__);
+
+	ts = get_timer(0);
+	ATF_STATE = ATF_STATE_USB_WAIT_ENUM;
+	trig_simulation_timer(timeout_in_ms * 1000);
+	VERBOSE("ts: %u\n", get_timer(ts));
+
+	gadget->ops->pullup(gadget, 1);
+unconfigured:
+	while (!acm_configValue) {
+		AcmIsr();
+		if ((get_timer(ts) > timeout_in_ms) && (flagEnterDL == 0)) {
+			NOTICE("USBEF.");
+			ATF_STATE = ATF_STATE_USB_ENUM_FAIL;
+			return -EIO;
+		}
+		if (flagReboot)
+			goto _reboot;
+	}
+	ATF_STATE = ATF_STATE_USB_ENUM_DONE;
+
+	mem_alloc_cnt = 1;
+	// find bulk endpoint
+	for (list = gadget->ep_list.next; list != &gadget->ep_list; list = list->next) {
+		ep = (struct usb_ep *)list;
+		if (ep->desc && (ep->desc->bEndpointAddress == BULK_EP_IN)) {
+			bulkInReq = ep->ops->alloc_request(ep);
+			epIn = ep;
+		} else if (ep->desc && (ep->desc->bEndpointAddress == BULK_EP_OUT)) {
+			bulkOutReq = ep->ops->alloc_request(ep);
+			epOut = ep;
+		} else if (ep->desc && (ep->desc->bEndpointAddress == BULK_EP_NOTIFY)) {
+			IntInReq = ep->ops->alloc_request(ep);
+			epInNotify = ep;
+		}
+	}
+
+	current_speed = gadget->speed;
+	switch (current_speed) {
+	case CH9_USB_SPEED_FULL:
+		transfer_size = 64;
+		break;
+	case CH9_USB_SPEED_HIGH:
+		transfer_size = 512;
+		break;
+	case CH9_USB_SPEED_SUPER:
+		transfer_size = 1024;
+		break;
+	default:
+		VERBOSE("Test error\n");
+		return -EIO;
+	}
+
+	VERBOSE("OUT DATA TRANSFER size :%d\n", transfer_size);
+	clearReq(bulkOutReq);
+	bulkOutReq->buf = cmdBuf;
+	bulkOutReq->dma = (uintptr_t)cmdBuf;
+	bulkOutReq->complete = bulkOutCmpl;
+	bulkOutReq->length = transfer_size;
+
+	VERBOSE("IN DATA TRANSFER\n");
+	clearReq(bulkInReq);
+	bulkInReq->buf = bulkBuf;
+	bulkInReq->dma = (uintptr_t)bulkBuf;
+	bulkInReq->complete = bulkInCmpl;
+	bulkInReq->length = transfer_size;
+	epOut->ops->queue(epOut, bulkOutReq);
+	INFO("connection speed: %d\n", gadget->speed);
+	ts = get_timer(0);
+	VERBOSE("ts: %u\n", get_timer(ts));
+
+	while (1) {
+		AcmIsr();
+		if (!acm_configValue)
+			goto unconfigured;
+		if (configBreak)
+			break;
+		if (flagEnterDL == 0) {
+			if (get_timer(ts) > timeout_in_ms) {
+				// USB data timeout
+				NOTICE("USBW/%d.", timeout_in_ms);
+				ATF_STATE = ATF_STATE_USB_DATA_TIMEOUT;
+				break;
+			}
+		} else if (flagEnterDL == 1 && fip_tx_size == 0) {
+			// USB enter download mode by magic.bin
+			NOTICE("USBD.");
+			return CV_USB_DL;
+		}
+	}
+	NOTICE("USBL.");
+	ATF_STATE = ATF_STATE_USB_TRANSFER_DONE;
+	gadget->ops->pullup(gadget, 0);
+	usb_gadget_unregister_driver(&g_driver);
+
+	if (*flag == MAGIC_NUM_USB_DL) // Set by host tool
+		return CV_USB_DL;
+	else
+		return 0;
+
+error:
+	ERROR("USB Error %u\n", res);
+	ATF_STATE = ATF_STATE_USB_ERR;
+	return ((res < 0) ? (-res) : res);
+}
diff --git a/firmware/plat/cv181x/bl2/bl2_main.c b/firmware/plat/cv181x/bl2/bl2_main.c
index e5b11f0..fcc0c8e 100644
--- a/firmware/plat/cv181x/bl2/bl2_main.c
+++ b/firmware/plat/cv181x/bl2/bl2_main.c
@@ -4,6 +4,7 @@
 #include <bl2.h>
 #include <string.h>
 #include <delay_timer.h>
+#include <rom_api.h>
 
 #ifdef RTOS_ENABLE_FREERTOS
 int init_comm_info(int ret)
@@ -45,8 +46,41 @@ int dec_verify_image(const void *image, size_t size, size_t dec_skip, struct fip
 }
 #endif
 
+// Start of addition
+#define UART_DLL 0x04140000
+#define UART_DLH 0x04140004
+#define UART_LCR 0x0414000C
+
+void set_baudrate()
+{
+	// 14 for 115200, 13 for 128000
+	int baud_divisor = 14;
+
+	// set DLAB to 1 to set dll and dlh
+	*(volatile uint32_t*)(UART_LCR) |= (uint32_t)0x80;
+
+	// set divisor
+	*(volatile uint32_t*)(UART_DLL) = (uint32_t)(baud_divisor & 0xff);
+	*(volatile uint32_t*)(UART_DLH) = (uint32_t)((baud_divisor >> 8) & 0xff);
+
+	// set DLAB back to 0
+	*(volatile uint32_t*)(UART_LCR) &= (uint32_t)(~0x80);
+}
+// End of addition
+
 void bl2_main(void)
 {
+	// Start of addition
+	set_baudrate();
+	// End of addition
+	
+	enum CHIP_CLK_MODE mode;
+	uint32_t v = p_rom_api_get_boot_src();
+
+	if (v == BOOT_SRC_UART) {
+		console_init(0, PLAT_UART_CLK_IN_HZ, UART_DL_BAUDRATE);
+	}
+
 	ATF_STATE = ATF_STATE_BL2_MAIN;
 	time_records->fsbl_start = read_time_ms();
 
@@ -68,12 +102,17 @@ void bl2_main(void)
 	set_rtc_en_registers();
 
 	load_ddr();
+
 #ifdef OD_CLK_SEL
-	load_rest_od_sel();
+	mode = CLK_OD;
 #else
-	load_rest();
+#ifdef VC_CLK_OVERDRIVE
+	mode = CLK_VC_OD;
+#else
+	mode = CLK_ND;
 #endif
-
+#endif
+	load_rest(mode);
 	NOTICE("BL2 end.\n");
 
 	while (1)
diff --git a/firmware/plat/cv181x/bl2/bl2_opt.c b/firmware/plat/cv181x/bl2/bl2_opt.c
new file mode 100644
index 0000000..c73fa55
--- /dev/null
+++ b/firmware/plat/cv181x/bl2/bl2_opt.c
@@ -0,0 +1,431 @@
+/*
+ * Copyright (c) 2013-2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <debug.h>
+#include <bitwise_ops.h>
+#include <console.h>
+#include <platform.h>
+#include <rom_api.h>
+#include <bl2.h>
+#include <ddr.h>
+#include <string.h>
+#include <decompress.h>
+#include <delay_timer.h>
+#include <security/security.h>
+
+struct _time_records *time_records = (void *)TIME_RECORDS_ADDR;
+struct fip_param1 *fip_param1 = (void *)PARAM1_BASE;
+static struct fip_param2 fip_param2 __aligned(BLOCK_SIZE);
+static union {
+	struct ddr_param ddr_param;
+	struct loader_2nd_header loader_2nd_header;
+	uint8_t buf[BLOCK_SIZE];
+} sram_union_buf __aligned(BLOCK_SIZE);
+
+int init_comm_info(int ret) __attribute__((weak));
+int init_comm_info(int ret)
+{
+	return ret;
+}
+
+void print_sram_log(void)
+{
+	uint32_t *const log_size = (void *)BOOT_LOG_LEN_ADDR;
+	uint8_t *const log_buf = (void *)phys_to_dma(BOOT_LOG_BUF_BASE);
+	uint32_t i;
+
+	static const char m1[] = "\nSRAM Log: ========================================\n";
+	static const char m2[] = "\nSRAM Log end: ====================================\n";
+
+	for (i = 0; m1[i]; i++)
+		console_putc(m1[i]);
+
+	for (i = 0; i < *log_size; i++)
+		console_putc(log_buf[i]);
+
+	for (i = 0; m2[i]; i++)
+		console_putc(m2[i]);
+}
+
+void lock_efuse_chipsn(void)
+{
+	int value = mmio_read_32(EFUSE_W_LOCK0_REG);
+
+	if (efuse_power_on()) {
+		NOTICE("efuse power on fail\n");
+		return;
+	}
+
+	if ((value & (0x1 << BIT_FTSN3_LOCK)) == 0)
+		efuse_program_bit(0x26, BIT_FTSN3_LOCK);
+
+	if ((value & (0x1 << BIT_FTSN4_LOCK)) == 0)
+		efuse_program_bit(0x26, BIT_FTSN4_LOCK);
+
+	if (efuse_refresh_shadow()) {
+		NOTICE("efuse refresh shadow fail\n");
+		return;
+	}
+
+	value = mmio_read_32(EFUSE_W_LOCK0_REG);
+	if (((value & (0x3 << BIT_FTSN3_LOCK)) >> BIT_FTSN3_LOCK) !=  0x3)
+		NOTICE("lock efuse chipsn fail\n");
+
+	if (efuse_power_off()) {
+		NOTICE("efuse power off fail\n");
+		return;
+	}
+}
+
+int load_param2(int retry)
+{
+	uint32_t crc;
+	int ret = -1;
+
+	NOTICE("P2S/0x%lx/%p.\n", sizeof(fip_param2), &fip_param2);
+
+	ret = p_rom_api_load_image(&fip_param2, fip_param1->param2_loadaddr, PARAM2_SIZE, retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (fip_param2.magic1 != FIP_PARAM2_MAGIC1) {
+		WARN("LP2_NOMAGIC\n");
+		return -1;
+	}
+
+	crc = p_rom_api_image_crc(&fip_param2.reserved1, sizeof(fip_param2) - 12);
+	if (crc != fip_param2.param2_cksum) {
+		ERROR("param2_cksum (0x%x/0x%x)\n", crc, fip_param2.param2_cksum);
+		return -1;
+	}
+
+	NOTICE("P2E.\n");
+
+	return 0;
+}
+
+int load_ddr_param(int retry)
+{
+	uint32_t crc;
+	int ret = -1;
+
+	NOTICE("DPS/0x%x/0x%x.\n", fip_param2.ddr_param_loadaddr, fip_param2.ddr_param_size);
+
+	if (fip_param2.ddr_param_size >= sizeof(sram_union_buf.ddr_param))
+		fip_param2.ddr_param_size = sizeof(sram_union_buf.ddr_param);
+
+	ret = p_rom_api_load_image(&sram_union_buf.ddr_param, fip_param2.ddr_param_loadaddr, fip_param2.ddr_param_size,
+				   retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	crc = p_rom_api_image_crc(&sram_union_buf.ddr_param, fip_param2.ddr_param_size);
+	if (crc != fip_param2.ddr_param_cksum) {
+		ERROR("ddr_param_cksum (0x%x/0x%x)\n", crc, fip_param2.ddr_param_cksum);
+		return -1;
+	}
+
+	NOTICE("DPE.\n");
+
+	return 0;
+}
+
+int load_ddr(void)
+{
+	int retry = 0;
+
+retry_from_flash:
+	for (retry = 0; retry < p_rom_api_get_number_of_retries(); retry++) {
+		if (load_param2(retry) < 0)
+			continue;
+
+		if (load_ddr_param(retry) < 0)
+			continue;
+
+		break;
+	}
+
+	if (retry >= p_rom_api_get_number_of_retries()) {
+		switch (p_rom_api_get_boot_src()) {
+		case BOOT_SRC_UART:
+		case BOOT_SRC_SD:
+		case BOOT_SRC_USB:
+			WARN("DL cancelled. Load flash. (%d).\n", retry);
+			// Continue to boot from flash if boot from external source
+			p_rom_api_flash_init();
+			goto retry_from_flash;
+		default:
+			ERROR("Failed to load DDR param (%d).\n", retry);
+			panic_handler();
+		}
+	}
+
+	time_records->ddr_init_start = read_time_ms();
+	ddr_init(&sram_union_buf.ddr_param);
+	time_records->ddr_init_end = read_time_ms();
+
+	return 0;
+}
+
+int load_blcp_2nd(int retry)
+{
+	uint32_t crc, rtos_base;
+	int ret = -1;
+
+	// if no blcp_2nd, release_blcp_2nd should be ddr_init_end
+	time_records->release_blcp_2nd = time_records->ddr_init_end;
+
+	NOTICE("C2S/0x%x/0x%x/0x%x.\n", fip_param2.blcp_2nd_loadaddr, fip_param2.blcp_2nd_runaddr,
+	       fip_param2.blcp_2nd_size);
+
+	if (!fip_param2.blcp_2nd_runaddr) {
+		NOTICE("No C906L image.\n");
+		return 0;
+	}
+
+	if (!IN_RANGE(fip_param2.blcp_2nd_runaddr, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("blcp_2nd_runaddr (0x%x) is not in DRAM.\n", fip_param2.blcp_2nd_runaddr);
+		panic_handler();
+	}
+
+	if (!IN_RANGE(fip_param2.blcp_2nd_runaddr + fip_param2.blcp_2nd_size, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("blcp_2nd_size (0x%x) is not in DRAM.\n", fip_param2.blcp_2nd_size);
+		panic_handler();
+	}
+
+	ret = p_rom_api_load_image((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_loadaddr,
+				   fip_param2.blcp_2nd_size, retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	crc = p_rom_api_image_crc((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_size);
+	if (crc != fip_param2.blcp_2nd_cksum) {
+		ERROR("blcp_2nd_cksum (0x%x/0x%x)\n", crc, fip_param2.blcp_2nd_cksum);
+		return -1;
+	}
+
+	ret = dec_verify_image((void *)(uintptr_t)fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_size, 0, fip_param1);
+	if (ret < 0) {
+		ERROR("verify blcp 2nd (%d)\n", ret);
+		return ret;
+	}
+
+	flush_dcache_range(fip_param2.blcp_2nd_runaddr, fip_param2.blcp_2nd_size);
+
+	rtos_base = mmio_read_32(AXI_SRAM_RTOS_BASE);
+	init_comm_info(0);
+
+	time_records->release_blcp_2nd = read_time_ms();
+	if (rtos_base == CVI_RTOS_MAGIC_CODE) {
+		mmio_write_32(AXI_SRAM_RTOS_BASE, fip_param2.blcp_2nd_runaddr);
+	} else {
+		reset_c906l(fip_param2.blcp_2nd_runaddr);
+	}
+
+	NOTICE("C2E.\n");
+
+	return 0;
+}
+
+int load_monitor(int retry, uint64_t *monitor_entry)
+{
+	uint32_t crc;
+	int ret = -1;
+
+	NOTICE("MS/0x%x/0x%x/0x%x.\n", fip_param2.monitor_loadaddr, fip_param2.monitor_runaddr,
+	       fip_param2.monitor_size);
+
+	if (!fip_param2.monitor_runaddr) {
+		NOTICE("No monitor.\n");
+		return 0;
+	}
+
+	if (!IN_RANGE(fip_param2.monitor_runaddr, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("monitor_runaddr (0x%x) is not in DRAM.\n", fip_param2.monitor_runaddr);
+		panic_handler();
+	}
+
+	if (!IN_RANGE(fip_param2.monitor_runaddr + fip_param2.monitor_size, DRAM_BASE, DRAM_SIZE)) {
+		ERROR("monitor_size (0x%x) is not in DRAM.\n", fip_param2.monitor_size);
+		panic_handler();
+	}
+
+	ret = p_rom_api_load_image((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_loadaddr,
+				   fip_param2.monitor_size, retry);
+	if (ret < 0) {
+		return ret;
+	}
+
+	crc = p_rom_api_image_crc((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_size);
+	if (crc != fip_param2.monitor_cksum) {
+		ERROR("monitor_cksum (0x%x/0x%x)\n", crc, fip_param2.monitor_cksum);
+		return -1;
+	}
+
+	ret = dec_verify_image((void *)(uintptr_t)fip_param2.monitor_runaddr, fip_param2.monitor_size, 0, fip_param1);
+	if (ret < 0) {
+		ERROR("verify monitor (%d)\n", ret);
+		return ret;
+	}
+
+	flush_dcache_range(fip_param2.monitor_runaddr, fip_param2.monitor_size);
+	NOTICE("ME.\n");
+
+	*monitor_entry = fip_param2.monitor_runaddr;
+
+	return 0;
+}
+
+int load_loader_2nd(int retry, uint64_t *loader_2nd_entry)
+{
+	struct loader_2nd_header *loader_2nd_header = &sram_union_buf.loader_2nd_header;
+	uint32_t crc;
+	int ret = -1;
+	const int cksum_offset =
+		offsetof(struct loader_2nd_header, cksum) + sizeof(((struct loader_2nd_header *)0)->cksum);
+
+	enum COMPRESS_TYPE comp_type = COMP_NONE;
+	int reading_size;
+	void *image_buf;
+
+	NOTICE("L2/0x%x.\n", fip_param2.loader_2nd_loadaddr);
+
+	ret = p_rom_api_load_image(loader_2nd_header, fip_param2.loader_2nd_loadaddr, BLOCK_SIZE, retry);
+	if (ret < 0) {
+		return -1;
+	}
+
+	reading_size = ROUND_UP(loader_2nd_header->size, BLOCK_SIZE);
+
+	NOTICE("L2/0x%x/0x%x/0x%lx/0x%x/0x%x\n", loader_2nd_header->magic, loader_2nd_header->cksum,
+	       loader_2nd_header->runaddr, loader_2nd_header->size, reading_size);
+
+	switch (loader_2nd_header->magic) {
+	case LOADER_2ND_MAGIC_LZMA:
+		comp_type = COMP_LZMA;
+		break;
+	case LOADER_2ND_MAGIC_LZ4:
+		comp_type = COMP_LZ4;
+		break;
+	default:
+		comp_type = COMP_NONE;
+		break;
+	}
+
+	if (comp_type) {
+		NOTICE("COMP/%d.\n", comp_type);
+		image_buf = (void *)DECOMP_BUF_ADDR;
+	} else {
+		image_buf = (void *)loader_2nd_header->runaddr;
+	}
+
+	ret = p_rom_api_load_image(image_buf, fip_param2.loader_2nd_loadaddr, reading_size, retry);
+	if (ret < 0) {
+		return -1;
+	}
+
+	crc = p_rom_api_image_crc(image_buf + cksum_offset, loader_2nd_header->size - cksum_offset);
+	if (crc != loader_2nd_header->cksum) {
+		ERROR("loader_2nd_cksum (0x%x/0x%x)\n", crc, loader_2nd_header->cksum);
+		return -1;
+	}
+
+	ret = dec_verify_image(image_buf + cksum_offset, loader_2nd_header->size - cksum_offset,
+			       sizeof(struct loader_2nd_header) - cksum_offset, fip_param1);
+	if (ret < 0) {
+		ERROR("verify loader 2nd (%d)\n", ret);
+		return ret;
+	}
+
+	time_records->load_loader_2nd_end = read_time_ms();
+
+	sys_switch_all_to_pll();
+
+	time_records->fsbl_decomp_start = read_time_ms();
+	if (comp_type) {
+		size_t dst_size = DECOMP_DST_SIZE;
+
+		// header is not compressed.
+		void *dst = (void *)loader_2nd_header->runaddr;
+
+		memcpy(dst, image_buf, sizeof(struct loader_2nd_header));
+		image_buf += sizeof(struct loader_2nd_header);
+
+		ret = decompress(dst + sizeof(struct loader_2nd_header), &dst_size, image_buf, loader_2nd_header->size,
+				 comp_type);
+		if (ret < 0) {
+			ERROR("Failed to decompress loader_2nd (%d/%lu)\n", ret, dst_size);
+			return -1;
+		}
+
+		reading_size = dst_size;
+	}
+
+	flush_dcache_range(loader_2nd_header->runaddr, reading_size);
+	time_records->fsbl_decomp_end = read_time_ms();
+	NOTICE("Loader_2nd loaded.\n");
+
+	*loader_2nd_entry = loader_2nd_header->runaddr + sizeof(struct loader_2nd_header);
+
+	return 0;
+}
+
+int load_rest(enum CHIP_CLK_MODE mode)
+{
+	int retry = 0;
+	uint64_t monitor_entry = 0;
+	uint64_t loader_2nd_entry = 0;
+
+	// Init sys PLL and switch clocks to PLL
+	sys_pll_init(mode);
+
+retry_from_flash:
+	for (retry = 0; retry < p_rom_api_get_number_of_retries(); retry++) {
+		if (load_blcp_2nd(retry) < 0)
+			continue;
+
+		if (load_monitor(retry, &monitor_entry) < 0)
+			continue;
+
+		if (load_loader_2nd(retry, &loader_2nd_entry) < 0)
+			continue;
+
+		break;
+	}
+
+	if (retry >= p_rom_api_get_number_of_retries()) {
+		switch (p_rom_api_get_boot_src()) {
+		case BOOT_SRC_UART:
+		case BOOT_SRC_SD:
+		case BOOT_SRC_USB:
+			WARN("DL cancelled. Load flash. (%d).\n", retry);
+			// Continue to boot from flash if boot from external source
+			p_rom_api_flash_init();
+			goto retry_from_flash;
+		default:
+			ERROR("Failed to load rest (%d).\n", retry);
+			panic_handler();
+		}
+	}
+
+	sync_cache();
+	console_flush();
+
+	switch_rtc_mode_2nd_stage();
+
+	if (monitor_entry) {
+		NOTICE("Jump to monitor at 0x%lx.\n", monitor_entry);
+		jump_to_monitor(monitor_entry, loader_2nd_entry);
+	} else {
+		NOTICE("Jump to loader_2nd at 0x%lx.\n", loader_2nd_entry);
+		jump_to_loader_2nd(loader_2nd_entry);
+	}
+
+	return 0;
+}
diff --git a/firmware/plat/cv181x/ddr/cvx16_dram_cap_check.c b/firmware/plat/cv181x/ddr/cvx16_dram_cap_check.c
new file mode 100644
index 0000000..54881a9
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/cvx16_dram_cap_check.c
@@ -0,0 +1,111 @@
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+
+void cvx16_dram_cap_check(uint8_t size)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x5A);
+	// ddr_debug_num_write();
+	KC_MSG("-5A- %s\n", __func__);
+
+#ifdef ETRON_DDR2_512
+	KC_MSG("ETRON_DDR2_512\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif ESMT_N25_DDR3_1G
+	KC_MSG("ESMT_N25_DDR3_1G\n");
+
+	if (size == 7) {
+		KC_MSG("dram_cap_check = 1Gb (128MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif ESMT_DDR3_2G
+	KC_MSG("ESMT_DDR3_2G\n");
+
+	if (size == 8) {
+		KC_MSG("dram_cap_check = 2Gb (256MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif ETRON_DDR3_1G
+	KC_MSG("ETRON_DDR3_1G\n");
+
+	if (size == 7) {
+		KC_MSG("dram_cap_check = 1Gb (128MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_1G
+	KC_MSG("DDR3_1G\n");
+
+	if (size == 7) {
+		KC_MSG("dram_cap_check = 1Gb (128MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_2G
+	KC_MSG("DDR3_2G\n");
+
+	if (size == 8) {
+		KC_MSG("dram_cap_check = 2Gb (256MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_4G
+	KC_MSG("DDR3_4G\n");
+
+	if (size == 9) {
+		KC_MSG("dram_cap_check = 4Gb (512MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_DBG
+	KC_MSG("DDR3_DBG\n");
+
+	if (size == 9) {
+		KC_MSG("dram_cap_check = 4Gb (512MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR3_PINMUX
+	KC_MSG("DDR3_6mil\n");
+
+	if (size == 9) {
+		KC_MSG("dram_cap_check = 4Gb (512MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR2_512
+	KC_MSG("DDR2_512\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif N25_DDR2_512
+	KC_MSG("N25_DDR2_512\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#elif DDR2_PINMUX
+	KC_MSG("DDR2\n");
+
+	if (size == 6) {
+		KC_MSG("dram_cap_check = 512Mb (64MB)\n");
+	} else {
+		KC_MSG("dram_cap_check ERROR !!! size = %x\n", size);
+	}
+#else
+	KC_MSG("no pinmux\n");
+#endif
+}
\ No newline at end of file
diff --git a/firmware/plat/cv181x/ddr/cvx16_pinmux.c b/firmware/plat/cv181x/ddr/cvx16_pinmux.c
new file mode 100644
index 0000000..d502878
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/cvx16_pinmux.c
@@ -0,0 +1,576 @@
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_pkg_info.h>
+
+void cvx16_pinmux(void)
+{
+	uartlog("%s\n", __func__);
+	//		ddr_debug_wr32(0x4E);
+	//		ddr_debug_num_write();
+	switch (get_ddr_vendor()) {
+	case DDR_VENDOR_NY_4G:
+		// DDR3_4G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x12141013);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x0C041503);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x06050001);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x08070B02);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0A0F0E09);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x0016110D);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x02136574);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000008);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76512308);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_NY_2G:
+		// DDR3_2G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x08070D09);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x0605020B);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x14040100);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x15030E0C);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0A0F1213);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00111016);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x82135764);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x67513028);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ESMT_1G:
+		// DDR3_1G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x08070B09);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x05000206);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0C04010D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x15030A14);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x10111213);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x000F160E);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x31756024);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000008);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x26473518);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000000);
+		break;
+	case DDR_VENDOR_ESMT_512M_DDR2:
+		// N25_DDR2_512
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x0C06080B);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x070D0904);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x00010502);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x110A0E03);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0F141610);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00151312);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x71840532);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000006);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76103425);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000008);
+		break;
+	case DDR_VENDOR_ESMT_2G:
+		// DDR3_2G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x080B0D06);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x09010407);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x1405020C);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x15000E03);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0A0F1213);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00111016);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x82135764);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x67513208);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ETRON_1G:
+		// ETRON_DDR3_1G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x0B060908);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x02000107);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0C05040D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x13141503);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x160A1112);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x000F100E);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x28137564);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76158320);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ESMT_N25_1G:
+		// ESMT_N25_DDR3_1G
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x08060B09);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x02040701);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0C00050D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x13150314);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x10111216);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x000F0A0E);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x82135674);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76153280);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000004);
+		break;
+	case DDR_VENDOR_ETRON_512M_DDR2:
+		// ETRON_DDR2_512
+		mmio_write_32(0x0000 + PHYD_BASE_ADDR, 0x070B090C);
+		mmio_write_32(0x0004 + PHYD_BASE_ADDR, 0x04050608);
+		mmio_write_32(0x0008 + PHYD_BASE_ADDR, 0x0E02030D);
+		mmio_write_32(0x000C + PHYD_BASE_ADDR, 0x110A0100);
+		mmio_write_32(0x0010 + PHYD_BASE_ADDR, 0x0F131614);
+		mmio_write_32(0x0014 + PHYD_BASE_ADDR, 0x00151012);
+		mmio_write_32(0x0018 + PHYD_BASE_ADDR, 0x00000000);
+		mmio_write_32(0x001C + PHYD_BASE_ADDR, 0x00000100);
+		mmio_write_32(0x0020 + PHYD_BASE_ADDR, 0x86014532);
+		mmio_write_32(0x0024 + PHYD_BASE_ADDR, 0x00000007);
+		mmio_write_32(0x0028 + PHYD_BASE_ADDR, 0x76012345);
+		mmio_write_32(0x002C + PHYD_BASE_ADDR, 0x00000008);
+		break;
+	}
+
+#ifdef ETRON_DDR2_512
+	KC_MSG("pin mux X16 mode ETRON_DDR2_512 setting\n");
+	//------------------------------
+	//  pin mux base on PHYA
+	//------------------------------
+	//param_phyd_data_byte_swap_slice0    [1:     0]
+	//param_phyd_data_byte_swap_slice1    [9:     8]
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dq0_mux    [3:     0]
+	//param_phyd_swap_byte0_dq1_mux    [7:     4]
+	//param_phyd_swap_byte0_dq2_mux    [11:    8]
+	//param_phyd_swap_byte0_dq3_mux    [15:   12]
+	//param_phyd_swap_byte0_dq4_mux    [19:   16]
+	//param_phyd_swap_byte0_dq5_mux    [23:   20]
+	//param_phyd_swap_byte0_dq6_mux    [27:   24]
+	//param_phyd_swap_byte0_dq7_mux    [31:   28]
+	rddata = 0x86014532;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dm_mux     [3:     0]
+	rddata = 0x00000007;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dq0_mux    [3:     0]
+	//param_phyd_swap_byte1_dq1_mux    [7:     4]
+	//param_phyd_swap_byte1_dq2_mux    [11:    8]
+	//param_phyd_swap_byte1_dq3_mux    [15:   12]
+	//param_phyd_swap_byte1_dq4_mux    [19:   16]
+	//param_phyd_swap_byte1_dq5_mux    [23:   20]
+	//param_phyd_swap_byte1_dq6_mux    [27:   24]
+	//param_phyd_swap_byte1_dq7_mux    [31:   28]
+	rddata = 0x76012345;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dm_mux     [3:     0]
+	rddata = 0x00000008;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca0    [4:     0]
+	//param_phyd_swap_ca1    [12:    8]
+	//param_phyd_swap_ca2    [20:   16]
+	//param_phyd_swap_ca3    [28:   24]
+	rddata = 0x070B090C;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca4    [4:     0]
+	//param_phyd_swap_ca5    [12:    8]
+	//param_phyd_swap_ca6    [20:   16]
+	//param_phyd_swap_ca7    [28:   24]
+	rddata = 0x04050608;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca8    [4:     0]
+	//param_phyd_swap_ca9    [12:    8]
+	//param_phyd_swap_ca10   [20:   16]
+	//param_phyd_swap_ca11   [28:   24]
+	rddata = 0x0E02030D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca12   [4:     0]
+	//param_phyd_swap_ca13   [12:    8]
+	//param_phyd_swap_ca14   [20:   16]
+	//param_phyd_swap_ca15   [28:   24]
+	rddata = 0x110A0100;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca16   [4:     0]
+	//param_phyd_swap_ca17   [12:    8]
+	//param_phyd_swap_ca18   [20:   16]
+	//param_phyd_swap_ca19   [28:   24]
+	rddata = 0x0F131614;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca20   [4:     0]
+	//param_phyd_swap_ca21   [12:    8]
+	//param_phyd_swap_ca22   [20:   16]
+	rddata = 0x00151012;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_cke0   [0:0]
+	//param_phyd_swap_cs0    [4:4]
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+	//pinmux
+#ifdef ESMT_N25_DDR3_1G
+	KC_MSG("pin mux X16 mode ESMT_N25_DDR3_1G setting\n");
+	//------------------------------
+	//  pin mux base on PHYA
+	//------------------------------
+	//param_phyd_data_byte_swap_slice0    [1:     0]
+	//param_phyd_data_byte_swap_slice1    [9:     8]
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dq0_mux    [3:     0]
+	//param_phyd_swap_byte0_dq1_mux    [7:     4]
+	//param_phyd_swap_byte0_dq2_mux    [11:    8]
+	//param_phyd_swap_byte0_dq3_mux    [15:   12]
+	//param_phyd_swap_byte0_dq4_mux    [19:   16]
+	//param_phyd_swap_byte0_dq5_mux    [23:   20]
+	//param_phyd_swap_byte0_dq6_mux    [27:   24]
+	//param_phyd_swap_byte0_dq7_mux    [31:   28]
+	rddata = 0x82135674;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte0_dm_mux     [3:     0]
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dq0_mux    [3:     0]
+	//param_phyd_swap_byte1_dq1_mux    [7:     4]
+	//param_phyd_swap_byte1_dq2_mux    [11:    8]
+	//param_phyd_swap_byte1_dq3_mux    [15:   12]
+	//param_phyd_swap_byte1_dq4_mux    [19:   16]
+	//param_phyd_swap_byte1_dq5_mux    [23:   20]
+	//param_phyd_swap_byte1_dq6_mux    [27:   24]
+	//param_phyd_swap_byte1_dq7_mux    [31:   28]
+	rddata = 0x76153280;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_byte1_dm_mux     [3:     0]
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca0    [4:     0]
+	//param_phyd_swap_ca1    [12:    8]
+	//param_phyd_swap_ca2    [20:   16]
+	//param_phyd_swap_ca3    [28:   24]
+	rddata = 0x08060B09;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca4    [4:     0]
+	//param_phyd_swap_ca5    [12:    8]
+	//param_phyd_swap_ca6    [20:   16]
+	//param_phyd_swap_ca7    [28:   24]
+	rddata = 0x02040701;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca8    [4:     0]
+	//param_phyd_swap_ca9    [12:    8]
+	//param_phyd_swap_ca10   [20:   16]
+	//param_phyd_swap_ca11   [28:   24]
+	rddata = 0x0C00050D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca12   [4:     0]
+	//param_phyd_swap_ca13   [12:    8]
+	//param_phyd_swap_ca14   [20:   16]
+	//param_phyd_swap_ca15   [28:   24]
+	rddata = 0x13150314;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca16   [4:     0]
+	//param_phyd_swap_ca17   [12:    8]
+	//param_phyd_swap_ca18   [20:   16]
+	//param_phyd_swap_ca19   [28:   24]
+	rddata = 0x10111216;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_ca20   [4:     0]
+	//param_phyd_swap_ca21   [12:    8]
+	//param_phyd_swap_ca22   [20:   16]
+	rddata = 0x000F0A0E;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	//param_phyd_swap_cke0   [0:     0]
+	//param_phyd_swap_cs0    [4:     4]
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef ESMT_DDR3_2G
+	KC_MSG("pin mux X16 mode ESMT_DDR3_2G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x82135764;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x67513208;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x080B0D06;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x09010407;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x1405020C;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x15000E03;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A0F1213;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00111016;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef ETRON_DDR3_1G
+	KC_MSG("pin mux X16 mode ETRON_DDR3_1G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x28137564;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x76158320;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0B060908;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x02000107;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C05040D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x13141503;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x160A1112;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x000F100E;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_1G
+	KC_MSG("pin mux X16 mode DDR3_1G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x31756024;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x26473518;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x08070B09;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x05000206;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C04010D;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x15030A14;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x10111213;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x000F160E;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_2G
+	KC_MSG("pin mux X16 mode DDR3_2G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x82135764;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x67513028;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x08070D09;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0605020B;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x14040100;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x15030E0C;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A0F1213;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00111016;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_4G
+	KC_MSG("pin mux X16 mode DDR3_4G setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x02136574;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x76512308;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000004;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x12141013;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C041503;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x06050001;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x08070B02;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A0F0E09;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0016110D;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR3_DBG
+	KC_MSG("pin mux X16 mode DDR3_DBG setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x30587246;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000001;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x26417538;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0002080E;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x04060D01;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x090C030B;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x05071412;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0A151013;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0016110F;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+#ifdef DDR3_PINMUX
+	KC_MSG("pin mux X16 mode DDR3_6mil setting\n");
+	rddata = 0x00000001;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x40613578;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000002;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x03582467;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000001;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x020E0D00;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x07090806;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C05010B;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x12141503;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x100A0413;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00160F11;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef DDR2_512
+	KC_MSG("pin mux X16 mode DDR2_512 setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x60851243;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000007;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x67012354;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C06080B;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x090D0204;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x01050700;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x160A0E03;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0F141110;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00151312;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+
+#ifdef N25_DDR2_512
+	KC_MSG("pin mux X16 mode N25_DDR2_512 setting\n");
+	rddata = 0x00000100;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x71840532;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000006;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x76103425;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000008;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C06080B;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x070D0904;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00010502;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x110A0E03;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0F141610;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00151312;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+#ifdef DDR2_PINMUX
+	KC_MSG("pin mux X16 mode DDR2 setting\n");
+	rddata = 0x00000001;
+	mmio_write_32(0x001C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x40613578;
+	mmio_write_32(0x0020 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000002;
+	mmio_write_32(0x0024 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x03582467;
+	mmio_write_32(0x0028 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000001;
+	mmio_write_32(0x002C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x020E0D00;
+	mmio_write_32(0x0000 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x07090806;
+	mmio_write_32(0x0004 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x0C05010B;
+	mmio_write_32(0x0008 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x12141503;
+	mmio_write_32(0x000C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x100A0413;
+	mmio_write_32(0x0010 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00160F11;
+	mmio_write_32(0x0014 + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	mmio_write_32(0x0018 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("pin mux setting }\n");
+#endif
+}
diff --git a/firmware/plat/cv181x/ddr/ddr.c b/firmware/plat/cv181x/ddr/ddr.c
new file mode 100644
index 0000000..6e0f97d
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr.c
@@ -0,0 +1,20 @@
+#include <platform.h>
+#include <ddr.h>
+#include <ddr_sys_bring_up.h>
+#include <ddr_pkg_info.h>
+
+
+int ddr_init(const struct ddr_param *ddr_param)
+{
+	NOTICE("cv181x DDR init.\n");
+	NOTICE("ddr_param[0]=0x%x.\n", ((const uint32_t *)ddr_param)[0]);
+
+	// read_ddr_pkg_info();
+	// bldp_init((void *)ddr_param);
+#ifndef NO_DDR_CFG
+	read_ddr_pkg_info();
+	ddr_sys_bring_up();
+#endif //NO_DDR_CFG
+
+	return 0;
+}
diff --git a/firmware/plat/cv181x/ddr/ddr.mk b/firmware/plat/cv181x/ddr/ddr.mk
new file mode 100644
index 0000000..01a45d3
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr.mk
@@ -0,0 +1,83 @@
+$(call print_var,DDR_CFG)
+
+# DDR_CFG = ddr3_2133_x16
+# DDR_CFG = ddr3_1866_x16
+# DDR_CFG = ddr2_1333_x16
+# DDR_CDF = ddr_auto_x16
+
+ifeq (${DDR_CFG},none)
+DDR_CFG =
+endif
+
+ifeq ($(DDR_CFG), )
+INCLUDES += \
+	-Iplat/${CHIP_ARCH}/include/ddr
+
+BL2_SOURCES += \
+	plat/${CHIP_ARCH}/ddr/ddr.c
+
+$(eval $(call add_define,NO_DDR_CFG))
+else
+INCLUDES += \
+	-Iplat/${CHIP_ARCH}/include/ddr \
+	-Iplat/${CHIP_ARCH}/include/ddr/ddr_config/${DDR_CFG}
+
+BL2_SOURCES += \
+	plat/${CHIP_ARCH}/ddr/ddr.c \
+	plat/${CHIP_ARCH}/ddr/ddr_pkg_info.c \
+	plat/${CHIP_ARCH}/ddr/ddr_sys_bring_up.c \
+	plat/${CHIP_ARCH}/ddr/ddr_sys.c \
+	plat/${CHIP_ARCH}/ddr/phy_pll_init.c \
+	plat/${CHIP_ARCH}/ddr/cvx16_pinmux.c \
+	plat/${CHIP_ARCH}/ddr/cvx16_dram_cap_check.c \
+	plat/${CHIP_ARCH}/ddr/ddr_config/${DDR_CFG}/ddrc_init.c \
+	plat/${CHIP_ARCH}/ddr/ddr_config/${DDR_CFG}/phy_init.c \
+	plat/${CHIP_ARCH}/ddr/ddr_config/${DDR_CFG}/ddr_patch_regs.c
+
+ifneq ($(findstring ddr3, ${DDR_CFG}),)
+    $(eval $(call add_define,DDR3))
+else ifneq ($(findstring ddr2, ${DDR_CFG}),)
+    $(eval $(call add_define,DDR2))
+else ifneq ($(findstring ddr_auto, ${DDR_CFG}),)
+    $(eval $(call add_define,DDR2_3))
+endif
+
+ifneq ($(findstring 2133, ${DDR_CFG}),)
+    $(eval $(call add_define,_mem_freq_2133))
+else ifneq ($(findstring 1866, ${DDR_CFG}),)
+    $(eval $(call add_define,_mem_freq_1866))
+else ifneq ($(findstring 1333, ${DDR_CFG}),)
+    $(eval $(call add_define,_mem_freq_1333))
+endif
+
+$(eval $(call add_define,REAL_DDRPHY))
+# $(eval $(call add_define,SSC_EN))
+$(eval $(call add_define,REAL_LOCK))
+$(eval $(call add_define,X16_MODE))
+
+# pinmux
+# ifneq ($(findstring ddr3, ${DDR_CFG}),)
+#     # $(eval $(call add_define,DDR3_4G))
+#     $(eval $(call add_define,DDR3_1G))
+# else ifneq ($(findstring ddr2, ${DDR_CFG}),)
+#     $(eval $(call add_define,N25_DDR2_512))
+# endif
+
+# full mem bist
+# $(eval $(call add_define,DBG_SHMOO))
+# $(eval $(call add_define,DBG_SHMOO_CA))
+# $(eval $(call add_define,DBG_SHMOO_CS))
+# $(eval $(call add_define,FULL_MEM_BIST))
+# $(eval $(call add_define,FULL_MEM_BIST_FOREVER))
+
+# overdrive clock setting
+ifeq ($(OD_CLK_SEL),y)
+$(eval $(call add_define,OD_CLK_SEL))
+else ifeq ($(VC_CLK_OVERDRIVE),y)
+$(eval $(call add_define,VC_CLK_OVERDRIVE))
+endif
+ifeq ($(TPU_PERF_MODE),y)
+$(eval $(call add_define,TPU_PERF_MODE))
+endif
+
+endif
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c b/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..3128ff5
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddr_patch_regs.c
@@ -0,0 +1,109 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr2_1333_x16_qfn.c
+
+struct regpatch ddr_patch_regs[] = {
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000808},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x04040404},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000808},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x04040404},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06440644},
+	{0x08000a04, 0xFFFFFFFF, 0x06440644},
+	{0x08000a08, 0xFFFFFFFF, 0x06440644},
+	{0x08000a0c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a10, 0xFFFFFFFF, 0x00000644},
+	{0x08000a14, 0xFFFFFFFF, 0x0d000000},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06440644},
+	{0x08000a44, 0xFFFFFFFF, 0x06440644},
+	{0x08000a48, 0xFFFFFFFF, 0x06440644},
+	{0x08000a4c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a50, 0xFFFFFFFF, 0x00000644},
+	{0x08000a54, 0xFFFFFFFF, 0x0d000000},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x02000202},
+	{0x08000b04, 0xFFFFFFFF, 0x00020000},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x002d3202},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x04020603},
+	{0x08000b34, 0xFFFFFFFF, 0x00060203},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x00313503},
+
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x0000081e},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x0000081e},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+};
+
+uint32_t ddr_patch_regs_count = ARRAY_SIZE(ddr_patch_regs);
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c
new file mode 100644
index 0000000..5b32318
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/ddrc_init.c
@@ -0,0 +1,376 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+#include <bitwise_ops.h>
+
+uint32_t ddr_data_rate = 1333;
+
+void ddrc_init(void)
+{
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	// PATCH0.use_blk_ext}:0:2:=0x1
+	// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+	// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+	// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+	// PATCH0.starve_stall_at_abr:5:1:=0x1
+	// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+	// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+	// PATCH0.pagematch_limit_threshold:8:3=0x3
+	// PATCH0.qos_sel:12:2:=0x2
+	// PATCH0.burst_rdwr_xpi:16:4:=0x4
+	// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+	// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+	// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+	// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+	// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+	// PATCH0.derate_sys_en:29:1:=0x1
+	// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+	mmio_wr32(0x08004000 + 0x44, 0x00000000);
+	// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+	// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+	// PATCH1.ref_adv_max:16:7:=0x0
+	mmio_wr32(0x08004000 + 0x148, 0x989D0000);
+	// PATCH4.t_phyd_rden:16:6=0x0
+	// PATCH4.phyd_rd_clk_stop:23:1=0x0
+	// PATCH4.t_phyd_wren:24:6=0x0
+	// PATCH4.phyd_wr_clk_stop:31:1=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x0, 0x81041400);
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	mmio_wr32(0x08004000 + 0x34, 0x006A0001);
+	mmio_wr32(0x08004000 + 0x38, 0x00020000);
+	mmio_wr32(0x08004000 + 0x50, 0x00201070);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	mmio_wr32(0x08004000 + 0x64, 0x0051006E);
+#ifdef DDR_INIT_SPEED_UP
+	mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+	mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+#else
+	mmio_wr32(0x08004000 + 0xd0, 0x00010043);
+	mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+#endif
+	mmio_wr32(0x08004000 + 0xdc, 0x03030040);
+	mmio_wr32(0x08004000 + 0xe0, 0x00800000);
+	mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+	mmio_wr32(0x08004000 + 0x104, 0x00030414);
+	mmio_wr32(0x08004000 + 0x108, 0x04050409);
+	mmio_wr32(0x08004000 + 0x10c, 0x00003004);
+	mmio_wr32(0x08004000 + 0x110, 0x05020406);
+	mmio_wr32(0x08004000 + 0x114, 0x01010303);
+	mmio_wr32(0x08004000 + 0x120, 0x00000505);
+	// phyd related
+	mmio_wr32(0x08004000 + 0x190, 0x04878304);
+	// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+	// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+	// DFITMG0.dfi_t_rddata_en:16:7:=0x6
+	// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+	// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+	// DFITMG0.dfi_tphy_wrlat:0:6:=0x4
+	mmio_wr32(0x08004000 + 0x194, 0x00070102);
+	// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+	// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+	// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+	// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+	// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+	mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+	// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+	// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+	// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+	// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+	// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+	// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+	// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+	mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+	mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+	mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+	mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+	// address map, auto gen.
+	// support from 0.5Gb to 4Gb
+	// R[17:13]B[2]R[12:0]B[1:0]C[9:0]
+	mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x204, 0x00140707);
+	mmio_wr32(0x08004000 + 0x208, 0x00000000);
+	mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+	mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+	mmio_wr32(0x08004000 + 0x218, 0x06060605);
+	mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+	mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+	mmio_wr32(0x08004000 + 0x224, 0x05050505);
+	mmio_wr32(0x08004000 + 0x228, 0x05050505);
+	mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x240, 0x07030710); // TBD
+	mmio_wr32(0x08004000 + 0x244, 0x00000000);
+	mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+	// SCHED.opt_vprw_sch:31:1:=0x0
+	// SCHED.rdwr_idle_gap:24:7:=0x0
+	// SCHED.go2critical_hysteresis:16:8:=0x0
+	// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+	// SCHED.lpr_num_entries:8:7:=0x1f
+	// SCHED.autopre_rmw:7:1:=0x1
+	// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+	// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+	// SCHED.opt_wrcam_fill_level:4:1:=0x0
+	// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+	// SCHED.pageclose:2:1:=0x0
+	// SCHED.prefer_write:1:1:=0x0
+	// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x254, 0x00000020);
+	// SCHED1.page_hit_limit_rd:28:3:=0x0
+	// SCHED1.page_hit_limit_wr:24:3:=0x0
+	// SCHED1.visible_window_limit_rd:20:3:=0x0
+	// SCHED1.visible_window_limit_wr:16:3:=0x0
+	// SCHED1.delay_switch_write:12:4:=0x0
+	// SCHED1.pageclose_timer:0:8:=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x25c, 0x100000A8);
+	// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+	// PERFHPR1.hpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x264, 0x100000A8);
+	// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+	// PERFLPR1.lpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x26c, 0x100000A8);
+	// PERFWR1.w_xact_run_length:24:8:=0x20
+	// PERFWR1.w_max_starve:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x300, 0x00000000);
+	// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+	// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+	// DBG0.dis_collision_page_opt:4:1:=0x0
+	// DBG0.dis_act_bypass:2:1:=0x0
+	// DBG0.dis_rd_bypass:1:1:=0x0
+	// DBG0.dis_wc:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x304, 0x00000000);
+	// DBG1.dis_hif:1:1:=0x0
+	// DBG1.dis_dq:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x320, 0x00000001);
+	// SWCTL.sw_done:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+	// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+	// POISONCFG.rd_poison_intr_en:20:1:=0x0
+	// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+	// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+	// POISONCFG.wr_poison_intr_en:4:1:=0x0
+	// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x400, 0x00000011);
+	// PCCFG.dch_density_ratio:12:2:=0x0
+	// PCCFG.bl_exp_mode:8:1:=0x0
+	// PCCFG.pagematch_limit:4:1:=0x1
+	// PCCFG.go2critical_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x404, 0x00006000);
+	// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_0.rd_port_aging_en:12:1:=0x0
+	// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_0.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x408, 0x00006000);
+	// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_0.wr_port_aging_en:12:1:=0x0
+	// PCFGW_0.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x490, 0x00000001);
+	// PCTRL_0.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x494, 0x00000007);
+	// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+	// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+	// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+	// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+	// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_1.rd_port_aging_en:12:1:=0x0
+	// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_1.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+	// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_1.wr_port_aging_en:12:1:=0x0
+	// PCFGW_1.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x540, 0x00000001);
+	// PCTRL_1.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x544, 0x00000007);
+	// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+	// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+	// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+	// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x564, 0x00006000);
+	// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_2.rd_port_aging_en:12:1:=0x0
+	// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_2.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x568, 0x00006000);
+	// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_2.wr_port_aging_en:12:1:=0x0
+	// PCFGW_2.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+	// PCTRL_2.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+	// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+	// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+	// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+	// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+}
+
+void ctrl_init_high_patch(void)
+{
+	// enable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000002);
+	// enable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+	// enable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+	// change xpi to multi DDR burst
+	//mmio_wr32(0x08004000 + 0xc, 0x63786370);
+}
+
+void ctrl_init_low_patch(void)
+{
+	// disable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	// disable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	// disable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+	// change xpi to single DDR burst
+	//mmio_wr32(0x08004000 + 0xc, 0x63746371);
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	rddata = mmio_rd32(0x08004000 + 0x0);
+	dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+	dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+	dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 5:
+		mmio_wr32(0x08004000 + 0x64, 0x00510019);
+		mmio_wr32(0x08004000 + 0x100, 0x0B011610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000502);
+		break;
+	case 6:
+		mmio_wr32(0x08004000 + 0x64, 0x0051002C);
+		mmio_wr32(0x08004000 + 0x100, 0x0B011610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000503);
+		break;
+	case 7:
+		mmio_wr32(0x08004000 + 0x64, 0x0051002B);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000503);
+		break;
+	case 8:
+		mmio_wr32(0x08004000 + 0x64, 0x00510041);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000504);
+		break;
+	case 9:
+		mmio_wr32(0x08004000 + 0x64, 0x0051006E);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x120, 0x00000505);
+		break;
+	}
+
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 5:
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x003F0606);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F1F0000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x040F0404);
+		mmio_wr32(0x08004000 + 0x218, 0x04040404);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000404);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x04040404);
+		mmio_wr32(0x08004000 + 0x228, 0x04040404);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F04);
+		break;
+	case 6:
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x003F0707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+		mmio_wr32(0x08004000 + 0x218, 0x05050505);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000505);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x05050505);
+		mmio_wr32(0x08004000 + 0x228, 0x05050505);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+		break;
+	case 7:
+	case 8:
+	case 9:
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x00070707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+		mmio_wr32(0x08004000 + 0x218, 0x06060606);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x06060606);
+		mmio_wr32(0x08004000 + 0x228, 0x06060606);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+		break;
+	}
+	// toggle refresh_update_level
+	mmio_wr32(0x08004000 + 0x60, 0x00000002);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/phy_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/phy_init.c
new file mode 100644
index 0000000..a1e18db
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr2_1333_x16/phy_init.c
@@ -0,0 +1,271 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, DDR_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, DDR_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, DDR_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, DDR_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, DDR_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, DDR_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, DDR_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, DDR_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, DDR_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, DDR_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, DDR_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, DDR_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, DDR_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, DDR_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, DDR_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, DDR_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, DDR_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, DDR_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, DDR_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, DDR_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, DDR_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, DDR_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, DDR_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, DDR_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, DDR_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, DDR_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, DDR_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, DDR_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, DDR_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, DDR_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, DDR_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, DDR_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, DDR_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, DDR_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, DDR_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, DDR_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, DDR_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, DDR_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, DDR_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, DDR_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, DDR_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, DDR_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, DDR_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, DDR_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, DDR_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, DDR_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, DDR_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, DDR_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, DDR_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, DDR_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, DDR_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, DDR_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, DDR_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, DDR_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, DDR_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, DDR_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, DDR_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, DDR_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, DDR_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, DDR_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, DDR_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, DDR_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, DDR_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, DDR_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, DDR_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, DDR_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, DDR_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, DDR_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, DDR_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, DDR_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, DDR_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, DDR_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, DDR_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, DDR_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, DDR_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, DDR_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, DDR_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, DDR_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, DDR_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, DDR_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, DDR_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c b/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..fad2b2b
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddr_patch_regs.c
@@ -0,0 +1,108 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr3_x16_bga.c for 1866
+
+struct regpatch ddr_patch_regs[] = {
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x06060606},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x06060606},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06430643},
+	{0x08000a04, 0xFFFFFFFF, 0x06430643},
+	{0x08000a08, 0xFFFFFFFF, 0x06430643},
+	{0x08000a0c, 0xFFFFFFFF, 0x06430643},
+	{0x08000a10, 0xFFFFFFFF, 0x00000643},
+	{0x08000a14, 0xFFFFFFFF, 0x0a7e007e},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06480648},
+	{0x08000a44, 0xFFFFFFFF, 0x06480648},
+	{0x08000a48, 0xFFFFFFFF, 0x06480648},
+	{0x08000a4c, 0xFFFFFFFF, 0x06480648},
+	{0x08000a50, 0xFFFFFFFF, 0x00000648},
+	{0x08000a54, 0xFFFFFFFF, 0x0a7e007e},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x00020402},
+	{0x08000b04, 0xFFFFFFFF, 0x05020401},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x00313902},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x06000100},
+	{0x08000b34, 0xFFFFFFFF, 0x02010303},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x00323900},
+
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x00000a14},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x00000a14},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+};
+
+uint32_t ddr_patch_regs_count = ARRAY_SIZE(ddr_patch_regs);
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c
new file mode 100644
index 0000000..6e7fd36
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/ddrc_init.c
@@ -0,0 +1,336 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+#include <bitwise_ops.h>
+
+uint32_t ddr_data_rate = 1866;
+
+void ddrc_init(void)
+{
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	// PATCH0.use_blk_ext}:0:2:=0x1
+	// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+	// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+	// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+	// PATCH0.starve_stall_at_abr:5:1:=0x1
+	// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+	// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+	// PATCH0.pagematch_limit_threshold:8:3=0x3
+	// PATCH0.qos_sel:12:2:=0x2
+	// PATCH0.burst_rdwr_xpi:16:4:=0x4
+	// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+	// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+	// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+	// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+	// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+	// PATCH0.derate_sys_en:29:1:=0x1
+	// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+	mmio_wr32(0x08004000 + 0x44, 0x00000000);
+	// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+	// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+	// PATCH1.ref_adv_max:16:7:=0x0
+	mmio_wr32(0x08004000 + 0x148, 0x999F0000);
+	// PATCH4.t_phyd_rden:16:6=0x0
+	// PATCH4.phyd_rd_clk_stop:23:1=0x0
+	// PATCH4.t_phyd_wren:24:6=0x0
+	// PATCH4.phyd_wr_clk_stop:31:1=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x0, 0x81041401);
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	mmio_wr32(0x08004000 + 0x34, 0x00930001);
+	mmio_wr32(0x08004000 + 0x38, 0x00020000);
+	mmio_wr32(0x08004000 + 0x50, 0x00201070);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+	mmio_wr32(0x08004000 + 0xc0, 0x00000000);
+	mmio_wr32(0x08004000 + 0xc4, 0x00000000);
+#ifdef DDR_INIT_SPEED_UP
+	mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+	mmio_wr32(0x08004000 + 0xd4, 0x00020000);
+#else
+	mmio_wr32(0x08004000 + 0xd0, 0x000100E5);
+	mmio_wr32(0x08004000 + 0xd4, 0x006A0000);
+#endif
+	mmio_wr32(0x08004000 + 0xdc, 0x1F140040);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0xe0, 0x04600000);
+#else
+	mmio_wr32(0x08004000 + 0xe0, 0x00600000);
+#endif
+	mmio_wr32(0x08004000 + 0xe4, 0x000B03BF);
+	mmio_wr32(0x08004000 + 0x100, 0x0E111F10);
+	mmio_wr32(0x08004000 + 0x104, 0x00030417);
+	mmio_wr32(0x08004000 + 0x108, 0x0507060A);
+	mmio_wr32(0x08004000 + 0x10c, 0x00002007);
+	mmio_wr32(0x08004000 + 0x110, 0x07020307);
+	mmio_wr32(0x08004000 + 0x114, 0x05050303);
+	mmio_wr32(0x08004000 + 0x120, 0x00000907);
+	mmio_wr32(0x08004000 + 0x13c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x180, 0xC0960026);
+	mmio_wr32(0x08004000 + 0x184, 0x00000001);
+	// phyd related
+	mmio_wr32(0x08004000 + 0x190, 0x048a8305);
+	// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+	// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+	// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+	// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+	// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+	// DFITMG0.dfi_tphy_wrlat:0:6:=0x5
+	mmio_wr32(0x08004000 + 0x194, 0x00070202);
+	// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+	// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+	// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+	// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+	// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+	mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+	// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+	// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+	// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+	// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+	// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+	// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+	// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+	mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+	mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+	mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+	mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+	// address map, auto gen.
+	mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x204, 0x00070707);
+	mmio_wr32(0x08004000 + 0x208, 0x00000000);
+	mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+	mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+	mmio_wr32(0x08004000 + 0x218, 0x06060606);
+	mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+	mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+	mmio_wr32(0x08004000 + 0x224, 0x06060606);
+	mmio_wr32(0x08004000 + 0x228, 0x06060606);
+	mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x240, 0x08000610);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0x244, 0x00000001);
+#else
+	mmio_wr32(0x08004000 + 0x244, 0x00000000);
+#endif
+	mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+	// SCHED.opt_vprw_sch:31:1:=0x0
+	// SCHED.rdwr_idle_gap:24:7:=0x0
+	// SCHED.go2critical_hysteresis:16:8:=0x0
+	// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+	// SCHED.lpr_num_entries:8:7:=0x1f
+	// SCHED.autopre_rmw:7:1:=0x1
+	// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+	// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+	// SCHED.opt_wrcam_fill_level:4:1:=0x0
+	// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+	// SCHED.pageclose:2:1:=0x1
+	// SCHED.prefer_write:1:1:=0x0
+	// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x254, 0x00000000);
+	// SCHED1.page_hit_limit_rd:28:3:=0x0
+	// SCHED1.page_hit_limit_wr:24:3:=0x0
+	// SCHED1.visible_window_limit_rd:20:3:=0x0
+	// SCHED1.visible_window_limit_wr:16:3:=0x0
+	// SCHED1.delay_switch_write:12:4:=0x0
+	// SCHED1.pageclose_timer:0:8:=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x25c, 0x100000F0);
+	// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+	// PERFHPR1.hpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x264, 0x100000F0);
+	// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+	// PERFLPR1.lpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x26c, 0x100000F0);
+	// PERFWR1.w_xact_run_length:24:8:=0x20
+	// PERFWR1.w_max_starve:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x300, 0x00000000);
+	// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+	// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+	// DBG0.dis_collision_page_opt:4:1:=0x0
+	// DBG0.dis_act_bypass:2:1:=0x0
+	// DBG0.dis_rd_bypass:1:1:=0x0
+	// DBG0.dis_wc:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x304, 0x00000000);
+	// DBG1.dis_hif:1:1:=0x0
+	// DBG1.dis_dq:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x320, 0x00000001);
+	// SWCTL.sw_done:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+	// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+	// POISONCFG.rd_poison_intr_en:20:1:=0x0
+	// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+	// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+	// POISONCFG.wr_poison_intr_en:4:1:=0x0
+	// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x400, 0x00000011);
+	// PCCFG.dch_density_ratio:12:2:=0x0
+	// PCCFG.bl_exp_mode:8:1:=0x0
+	// PCCFG.pagematch_limit:4:1:=0x1
+	// PCCFG.go2critical_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x404, 0x00006000);
+	// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_0.rd_port_aging_en:12:1:=0x0
+	// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_0.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x408, 0x00006000);
+	// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_0.wr_port_aging_en:12:1:=0x0
+	// PCFGW_0.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x490, 0x00000001);
+	// PCTRL_0.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x494, 0x00000007);
+	// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+	// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+	// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+	// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+	// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_1.rd_port_aging_en:12:1:=0x0
+	// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_1.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+	// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_1.wr_port_aging_en:12:1:=0x0
+	// PCFGW_1.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x540, 0x00000001);
+	// PCTRL_1.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x544, 0x00000007);
+	// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+	// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+	// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+	// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x564, 0x00006000);
+	// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_2.rd_port_aging_en:12:1:=0x0
+	// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_2.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x568, 0x00006000);
+	// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_2.wr_port_aging_en:12:1:=0x0
+	// PCFGW_2.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+	// PCTRL_2.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+	// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+	// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+	// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+	// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+}
+
+void ctrl_init_high_patch(void)
+{
+	// enable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000002);
+	// enable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+	// enable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+	// change xpi to multi DDR burst
+	//mmio_wr32(0x08004000 + 0xc, 0x63786370);
+}
+
+void ctrl_init_low_patch(void)
+{
+	// disable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	// disable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	// disable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+	// change xpi to single DDR burst
+	//mmio_wr32(0x08004000 + 0xc, 0x63746371);
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	rddata = mmio_rd32(0x08004000 + 0x0);
+	dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+	dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+	dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 6:
+		mmio_wr32(0x08004000 + 0x64, 0x0071002A);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 7:
+		mmio_wr32(0x08004000 + 0x64, 0x00710034);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 8:
+		mmio_wr32(0x08004000 + 0x64, 0x0071004B);
+		mmio_wr32(0x08004000 + 0x120, 0x00000904);
+		break;
+	case 9:
+		mmio_wr32(0x08004000 + 0x64, 0x0071007A);
+		mmio_wr32(0x08004000 + 0x120, 0x00000905);
+		break;
+	case 10:
+		mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+		mmio_wr32(0x08004000 + 0x120, 0x00000907);
+		break;
+	}
+	// toggle refresh_update_level
+	mmio_wr32(0x08004000 + 0x60, 0x00000002);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/phy_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/phy_init.c
new file mode 100644
index 0000000..a1e18db
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr3_1866_x16/phy_init.c
@@ -0,0 +1,271 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, DDR_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, DDR_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, DDR_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, DDR_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, DDR_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, DDR_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, DDR_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, DDR_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, DDR_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, DDR_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, DDR_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, DDR_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, DDR_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, DDR_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, DDR_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, DDR_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, DDR_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, DDR_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, DDR_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, DDR_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, DDR_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, DDR_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, DDR_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, DDR_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, DDR_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, DDR_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, DDR_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, DDR_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, DDR_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, DDR_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, DDR_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, DDR_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, DDR_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, DDR_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, DDR_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, DDR_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, DDR_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, DDR_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, DDR_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, DDR_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, DDR_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, DDR_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, DDR_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, DDR_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, DDR_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, DDR_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, DDR_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, DDR_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, DDR_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, DDR_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, DDR_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, DDR_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, DDR_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, DDR_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, DDR_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, DDR_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, DDR_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, DDR_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, DDR_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, DDR_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, DDR_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, DDR_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, DDR_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, DDR_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, DDR_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, DDR_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, DDR_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, DDR_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, DDR_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, DDR_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, DDR_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, DDR_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, DDR_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, DDR_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, DDR_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, DDR_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, DDR_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, DDR_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, DDR_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, DDR_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, DDR_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c b/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..366868a
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddr_patch_regs.c
@@ -0,0 +1,108 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr3_x16_bga.c for 2133
+
+struct regpatch ddr_patch_regs[] = {
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x06060606},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x06060606},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06430643},
+	{0x08000a04, 0xFFFFFFFF, 0x06430643},
+	{0x08000a08, 0xFFFFFFFF, 0x06430643},
+	{0x08000a0c, 0xFFFFFFFF, 0x06430643},
+	{0x08000a10, 0xFFFFFFFF, 0x00000643},
+	{0x08000a14, 0xFFFFFFFF, 0x0a7e007e},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06480648},
+	{0x08000a44, 0xFFFFFFFF, 0x06480648},
+	{0x08000a48, 0xFFFFFFFF, 0x06480648},
+	{0x08000a4c, 0xFFFFFFFF, 0x06480648},
+	{0x08000a50, 0xFFFFFFFF, 0x00000648},
+	{0x08000a54, 0xFFFFFFFF, 0x0a7e007e},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x00020402},
+	{0x08000b04, 0xFFFFFFFF, 0x05020401},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x00313902},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x06000100},
+	{0x08000b34, 0xFFFFFFFF, 0x02010303},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x00323900},
+
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x00000c28},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x00000c2a},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+};
+
+uint32_t ddr_patch_regs_count = ARRAY_SIZE(ddr_patch_regs);
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c
new file mode 100644
index 0000000..bbd970a
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/ddrc_init.c
@@ -0,0 +1,337 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+#include <bitwise_ops.h>
+
+uint32_t ddr_data_rate = 2133;
+
+void ddrc_init(void)
+{
+	mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	// PATCH0.use_blk_ext}:0:2:=0x1
+	// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+	// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+	// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+	// PATCH0.starve_stall_at_abr:5:1:=0x1
+	// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+	// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+	// PATCH0.pagematch_limit_threshold:8:3=0x3
+	// PATCH0.qos_sel:12:2:=0x2
+	// PATCH0.burst_rdwr_xpi:16:4:=0x4
+	// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+	// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+	// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+	// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+	// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+	// PATCH0.derate_sys_en:29:1:=0x1
+	// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+	mmio_wr32(0x08004000 + 0x44, 0x00000000);
+	// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+	// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+	// PATCH1.ref_adv_max:16:7:=0x0
+	mmio_wr32(0x08004000 + 0x148, 0x999F0000);
+	// PATCH4.t_phyd_rden:16:6=0x0
+	// PATCH4.phyd_rd_clk_stop:23:1=0x0
+	// PATCH4.t_phyd_wren:24:6=0x0
+	// PATCH4.phyd_wr_clk_stop:31:1=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x0, 0x81041401);
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	mmio_wr32(0x08004000 + 0x34, 0x00A80001);
+	mmio_wr32(0x08004000 + 0x38, 0x00020000);
+	mmio_wr32(0x08004000 + 0x50, 0x00201070);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	mmio_wr32(0x08004000 + 0x64, 0x008200BB);
+	mmio_wr32(0x08004000 + 0xc0, 0x00000000);
+	mmio_wr32(0x08004000 + 0xc4, 0x00000000);
+#ifdef DDR_INIT_SPEED_UP
+	mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+	mmio_wr32(0x08004000 + 0xd4, 0x00030000);
+#else
+	mmio_wr32(0x08004000 + 0xd0, 0x00010106);
+	mmio_wr32(0x08004000 + 0xd4, 0x00790000);
+#endif
+	mmio_wr32(0x08004000 + 0xdc, 0x11240040);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0xe0, 0x04680000);
+#else
+	mmio_wr32(0x08004000 + 0xe0, 0x00680000);
+#endif
+	mmio_wr32(0x08004000 + 0xe4, 0x000C03BF);
+	mmio_wr32(0x08004000 + 0x100, 0x0F132412);
+	mmio_wr32(0x08004000 + 0x104, 0x00040419);
+	mmio_wr32(0x08004000 + 0x108, 0x0507060B);
+	mmio_wr32(0x08004000 + 0x10c, 0x00002008);
+	mmio_wr32(0x08004000 + 0x110, 0x07020408);
+	mmio_wr32(0x08004000 + 0x114, 0x06060403);
+	mmio_wr32(0x08004000 + 0x120, 0x00000907);
+	mmio_wr32(0x08004000 + 0x13c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x180, 0xC0AB002B);
+	mmio_wr32(0x08004000 + 0x184, 0x00000001);
+	// phyd related
+	mmio_wr32(0x08004000 + 0x190, 0x048a8306);
+	// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+	// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+	// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+	// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+	// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+	// DFITMG0.dfi_tphy_wrlat:0:6:=0x6
+	mmio_wr32(0x08004000 + 0x194, 0x00070202);
+	// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+	// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+	// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+	// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+	// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+	mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+	// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+	// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+	// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+	// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+	// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+	// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+	// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+	// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+	mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+	mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+	mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+	mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+	// address map, auto gen.
+	mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x204, 0x00070707);
+	mmio_wr32(0x08004000 + 0x208, 0x00000000);
+	mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+	mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+	mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+	mmio_wr32(0x08004000 + 0x218, 0x06060606);
+	mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+	mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+	mmio_wr32(0x08004000 + 0x224, 0x06060606);
+	mmio_wr32(0x08004000 + 0x228, 0x06060606);
+	mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x240, 0x08000610);
+#ifdef DDR_DODT
+	mmio_wr32(0x08004000 + 0x244, 0x00000001);
+#else
+	mmio_wr32(0x08004000 + 0x244, 0x00000000);
+#endif
+	mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+	// SCHED.opt_vprw_sch:31:1:=0x0
+	// SCHED.rdwr_idle_gap:24:7:=0x0
+	// SCHED.go2critical_hysteresis:16:8:=0x0
+	// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+	// SCHED.lpr_num_entries:8:7:=0x1f
+	// SCHED.autopre_rmw:7:1:=0x1
+	// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+	// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+	// SCHED.opt_wrcam_fill_level:4:1:=0x0
+	// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+	// SCHED.pageclose:2:1:=0x1
+	// SCHED.prefer_write:1:1:=0x0
+	// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x254, 0x00000000);
+	// SCHED1.page_hit_limit_rd:28:3:=0x0
+	// SCHED1.page_hit_limit_wr:24:3:=0x0
+	// SCHED1.visible_window_limit_rd:20:3:=0x0
+	// SCHED1.visible_window_limit_wr:16:3:=0x0
+	// SCHED1.delay_switch_write:12:4:=0x0
+	// SCHED1.pageclose_timer:0:8:=0x0
+	// auto gen.
+	mmio_wr32(0x08004000 + 0x25c, 0x10000110);
+	// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+	// PERFHPR1.hpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x264, 0x10000110);
+	// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+	// PERFLPR1.lpr_max_starve:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x26c, 0x10000110);
+	// PERFWR1.w_xact_run_length:24:8:=0x20
+	// PERFWR1.w_max_starve:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x300, 0x00000000);
+	// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+	// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+	// DBG0.dis_collision_page_opt:4:1:=0x0
+	// DBG0.dis_act_bypass:2:1:=0x0
+	// DBG0.dis_rd_bypass:1:1:=0x0
+	// DBG0.dis_wc:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x304, 0x00000000);
+	// DBG1.dis_hif:1:1:=0x0
+	// DBG1.dis_dq:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+	mmio_wr32(0x08004000 + 0x320, 0x00000001);
+	// SWCTL.sw_done:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+	// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+	// POISONCFG.rd_poison_intr_en:20:1:=0x0
+	// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+	// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+	// POISONCFG.wr_poison_intr_en:4:1:=0x0
+	// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+	mmio_wr32(0x08004000 + 0x400, 0x00000011);
+	// PCCFG.dch_density_ratio:12:2:=0x0
+	// PCCFG.bl_exp_mode:8:1:=0x0
+	// PCCFG.pagematch_limit:4:1:=0x1
+	// PCCFG.go2critical_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x404, 0x00006000);
+	// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_0.rd_port_aging_en:12:1:=0x0
+	// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_0.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x408, 0x00006000);
+	// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_0.wr_port_aging_en:12:1:=0x0
+	// PCFGW_0.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x490, 0x00000001);
+	// PCTRL_0.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x494, 0x00000007);
+	// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+	// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+	// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+	// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+	// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_1.rd_port_aging_en:12:1:=0x0
+	// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_1.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+	// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_1.wr_port_aging_en:12:1:=0x0
+	// PCFGW_1.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x540, 0x00000001);
+	// PCTRL_1.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x544, 0x00000007);
+	// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+	// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+	// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+	// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+	mmio_wr32(0x08004000 + 0x564, 0x00006000);
+	// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+	// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+	// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+	// PCFGR_2.rd_port_aging_en:12:1:=0x0
+	// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+	// PCFGR_2.rd_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x568, 0x00006000);
+	// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+	// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+	// PCFGW_2.wr_port_aging_en:12:1:=0x0
+	// PCFGW_2.wr_port_priority:0:10:=0x0
+	mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+	// PCTRL_2.port_en:0:1:=0x1
+	mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+	// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+	// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+	// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+	// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+	// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+	// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+	// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+	mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+	// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+	// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+	// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+	// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+	// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+	mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+	// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+	// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+}
+
+void ctrl_init_high_patch(void)
+{
+	// enable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000002);
+	// enable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+	// enable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+	// change xpi to multi DDR burst
+	//mmio_wr32(0x08004000 + 0xc, 0x63786370);
+}
+
+void ctrl_init_low_patch(void)
+{
+	// disable auto PD/SR
+	mmio_wr32(0x08004000 + 0x30, 0x00000000);
+	// disable auto ctrl_upd
+	mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+	// disable clock gating
+	mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+	// change xpi to single DDR burst
+	//mmio_wr32(0x08004000 + 0xc, 0x63746371);
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	rddata = mmio_rd32(0x08004000 + 0x0);
+	dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+	dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+	dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+	uartlog("dram_cap_in_mbyte_per_dev=%d\n", dram_cap_in_mbyte_per_dev);
+	switch (dram_cap_in_mbyte_per_dev) {
+	case 6:
+		mmio_wr32(0x08004000 + 0x64, 0x00820030);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 7:
+		mmio_wr32(0x08004000 + 0x64, 0x0082003B);
+		mmio_wr32(0x08004000 + 0x120, 0x00000903);
+		break;
+	case 8:
+		mmio_wr32(0x08004000 + 0x64, 0x00820056);
+		mmio_wr32(0x08004000 + 0x120, 0x00000904);
+		break;
+	case 9:
+		mmio_wr32(0x08004000 + 0x64, 0x0082008B);
+		mmio_wr32(0x08004000 + 0x120, 0x00000906);
+		break;
+	case 10:
+		mmio_wr32(0x08004000 + 0x64, 0x008200BB);
+		mmio_wr32(0x08004000 + 0x120, 0x00000907);
+		break;
+	}
+	// toggle refresh_update_level
+	mmio_wr32(0x08004000 + 0x60, 0x00000002);
+	mmio_wr32(0x08004000 + 0x60, 0x00000000);
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/phy_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/phy_init.c
new file mode 100644
index 0000000..a1e18db
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr3_2133_x16/phy_init.c
@@ -0,0 +1,271 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr_init.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, DDR_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, DDR_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, DDR_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, DDR_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, DDR_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, DDR_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, DDR_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, DDR_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, DDR_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, DDR_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, DDR_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, DDR_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, DDR_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, DDR_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, DDR_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, DDR_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, DDR_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, DDR_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, DDR_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, DDR_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, DDR_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, DDR_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, DDR_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, DDR_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, DDR_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, DDR_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, DDR_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, DDR_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, DDR_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, DDR_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, DDR_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, DDR_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, DDR_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, DDR_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, DDR_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, DDR_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, DDR_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, DDR_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, DDR_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, DDR_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, DDR_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, DDR_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, DDR_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, DDR_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, DDR_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, DDR_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, DDR_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, DDR_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, DDR_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, DDR_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, DDR_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, DDR_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, DDR_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, DDR_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, DDR_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, DDR_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, DDR_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, DDR_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, DDR_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, DDR_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, DDR_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, DDR_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, DDR_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, DDR_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, DDR_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, DDR_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, DDR_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, DDR_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, DDR_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, DDR_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, DDR_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, DDR_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, DDR_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, DDR_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, DDR_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, DDR_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, DDR_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, DDR_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, DDR_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, DDR_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, DDR_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, DDR_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, DDR_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, DDR_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, DDR_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, DDR_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, DDR_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, DDR_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, DDR_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, DDR_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, DDR_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, DDR_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, DDR_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, DDR_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, DDR_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, DDR_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, DDR_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, DDR_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, DDR_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, DDR_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, DDR_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, DDR_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, DDR_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, DDR_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, DDR_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, DDR_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, DDR_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, DDR_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, DDR_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, DDR_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, DDR_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, DDR_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, DDR_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, DDR_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, DDR_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, DDR_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, DDR_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, DDR_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, DDR_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, DDR_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, DDR_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, DDR_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, DDR_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, DDR_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, DDR_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, DDR_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, DDR_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, DDR_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, DDR_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, DDR_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, DDR_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, DDR_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, DDR_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, DDR_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, DDR_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, DDR_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, DDR_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, DDR_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, DDR_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, DDR_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, DDR_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, DDR_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, DDR_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, DDR_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, DDR_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, DDR_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, DDR_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, DDR_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, DDR_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, DDR_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, DDR_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, DDR_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, DDR_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, DDR_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, DDR_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, DDR_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, DDR_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, DDR_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, DDR_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, DDR_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, DDR_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, DDR_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, DDR_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, DDR_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, DDR_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, DDR_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, DDR_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, DDR_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, DDR_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, DDR_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c b/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c
new file mode 100644
index 0000000..b70d15d
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddr_patch_regs.c
@@ -0,0 +1,211 @@
+#include <stddef.h>
+#include <utils_def.h>
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include "regconfig.h"
+
+//regpatch_ddr3_x16_bga.c for 1866
+
+struct regpatch ddr3_1866_patch_regs[] = {
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x06060606},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000606},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x06060606},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06430643},
+	{0x08000a04, 0xFFFFFFFF, 0x06430643},
+	{0x08000a08, 0xFFFFFFFF, 0x06430643},
+	{0x08000a0c, 0xFFFFFFFF, 0x06430643},
+	{0x08000a10, 0xFFFFFFFF, 0x00000643},
+	{0x08000a14, 0xFFFFFFFF, 0x0a7e007e},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06480648},
+	{0x08000a44, 0xFFFFFFFF, 0x06480648},
+	{0x08000a48, 0xFFFFFFFF, 0x06480648},
+	{0x08000a4c, 0xFFFFFFFF, 0x06480648},
+	{0x08000a50, 0xFFFFFFFF, 0x00000648},
+	{0x08000a54, 0xFFFFFFFF, 0x0a7e007e},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x00020402},
+	{0x08000b04, 0xFFFFFFFF, 0x05020401},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x00313902},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x06000100},
+	{0x08000b34, 0xFFFFFFFF, 0x02010303},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x00323900},
+
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x00000a14},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x00000a14},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+};
+
+uint32_t ddr3_1866_patch_regs_count = ARRAY_SIZE(ddr3_1866_patch_regs);
+
+//regpatch_ddr2_1333_x16_qfn.c
+
+struct regpatch ddr2_1333_patch_regs[] = {
+	// tune damp //////
+	{0x08000150, 0xFFFFFFFF, 0x00000005},
+
+	// CSB & CA driving
+	{0x0800097c, 0xFFFFFFFF, 0x08080404},
+
+	// CLK driving
+	{0x08000980, 0xFFFFFFFF, 0x08080808},
+
+	// DQ driving // BYTE0
+	{0x08000a38, 0xFFFFFFFF, 0x00000808},
+	// DQS driving // BYTE0
+	{0x08000a3c, 0xFFFFFFFF, 0x04040404},
+	// DQ driving // BYTE1
+	{0x08000a78, 0xFFFFFFFF, 0x00000808},
+	// DQS driving // BYTE1
+	{0x08000a7c, 0xFFFFFFFF, 0x04040404},
+
+	//trigger level //////
+	// BYTE0
+	{0x08000b24, 0xFFFFFFFF, 0x00100010},
+	// BYTE1
+	{0x08000b54, 0xFFFFFFFF, 0x00100010},
+
+	//APHY TX VREFDQ rangex2 [1]
+	//VREF DQ   //
+	{0x08000410, 0xFFFFFFFF, 0x00120002},
+
+	//APHY TX VREFCA rangex2 [1]
+	//VREF CA  //
+	{0x08000414, 0xFFFFFFFF, 0x00100002},
+
+	// tx dline code
+	//  BYTE0 DQ
+	{0x08000a00, 0xFFFFFFFF, 0x06440644},
+	{0x08000a04, 0xFFFFFFFF, 0x06440644},
+	{0x08000a08, 0xFFFFFFFF, 0x06440644},
+	{0x08000a0c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a10, 0xFFFFFFFF, 0x00000644},
+	{0x08000a14, 0xFFFFFFFF, 0x0d000000},
+	//  BYTE1 DQ
+	{0x08000a40, 0xFFFFFFFF, 0x06440644},
+	{0x08000a44, 0xFFFFFFFF, 0x06440644},
+	{0x08000a48, 0xFFFFFFFF, 0x06440644},
+	{0x08000a4c, 0xFFFFFFFF, 0x06440644},
+	{0x08000a50, 0xFFFFFFFF, 0x00000644},
+	{0x08000a54, 0xFFFFFFFF, 0x0d000000},
+
+	//APHY RX TRIG rangex2[18] & disable lsmode[0]
+	//f0_param_phya_reg_rx_byte0_en_lsmode[0]
+	//f0_param_phya_reg_byte0_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE0 [0]
+	{0x08000500, 0xFFFFFFFF, 0x00041001},
+	//f0_param_phya_reg_rx_byte1_en_lsmode[0]
+	//f0_param_phya_reg_byte1_en_rec_vol_mode[12]
+	//f0_param_phya_reg_rx_byte0_force_en_lvstl_odt[16]
+	//f0_param_phya_reg_rx_byte0_sel_dqs_rec_vref_mode[8]
+	//param_phya_reg_rx_byte0_en_trig_lvl_rangex2[18]
+	// BYTE1 [0]
+	{0x08000540, 0xFFFFFFFF, 0x00041001},
+
+	////////  FOR U02 ///////
+	/////////// U02 enable DQS voltage mode receiver
+	// f0_param_phya_reg_tx_byte0_en_tx_de_dqs[20]
+	{0x08000504, 0xFFFFFFFF, 0x00100000},
+	// f0_param_phya_reg_tx_byte1_en_tx_de_dqs[20]
+	{0x08000544, 0xFFFFFFFF, 0x00100000},
+	/////////// U02 enable MASK voltage mode receiver
+	// param_phya_reg_rx_sel_dqs_wo_pream_mode[2]
+	{0x08000138, 0xFFFFFFFF, 0x00000014},
+
+	// BYTE0 RX DQ deskew
+	{0x08000b00, 0xFFFFFFFF, 0x02000202},
+	{0x08000b04, 0xFFFFFFFF, 0x00020000},
+	// BYTE0  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b08, 0xFFFFFFFF, 0x002d3202},
+
+	// BYTE1 RX DQ deskew
+	{0x08000b30, 0xFFFFFFFF, 0x04020603},
+	{0x08000b34, 0xFFFFFFFF, 0x00060203},
+	// BYTE1  DQ8 deskew [6:0] neg DQS  [15:8]  ;  pos DQS  [23:16]
+	{0x08000b38, 0xFFFFFFFF, 0x00313503},
+
+	//Read gate TX dline + shift
+	// BYTE0
+	{0x08000b0c, 0xFFFFFFFF, 0x0000081e},
+	// BYTE1
+	{0x08000b3c, 0xFFFFFFFF, 0x0000081e},
+
+	// CKE dline + shift CKE0 [6:0]+[13:8] ; CKE1 [22:16]+[29:24]
+	{0x08000930, 0xFFFFFFFF, 0x04000400},
+	// CSB dline + shift CSB0 [6:0]+[13:8] ; CSB1 [22:16]+[29:24]
+	{0x08000934, 0xFFFFFFFF, 0x04000400},
+};
+
+uint32_t ddr2_1333_patch_regs_count = ARRAY_SIZE(ddr2_1333_patch_regs);
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c
new file mode 100644
index 0000000..dd3b885
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/ddrc_init.c
@@ -0,0 +1,706 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+#include <bitwise_ops.h>
+#include <ddr_pkg_info.h>
+
+uint32_t ddr_data_rate = 1866;
+
+void ddrc_init(void)
+{
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		NOTICE("DDR3 1866 ddrc_init\n");
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		// PATCH0.use_blk_ext}:0:2:=0x1
+		// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+		// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+		// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+		// PATCH0.starve_stall_at_abr:5:1:=0x1
+		// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+		// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+		// PATCH0.pagematch_limit_threshold:8:3=0x3
+		// PATCH0.qos_sel:12:2:=0x2
+		// PATCH0.burst_rdwr_xpi:16:4:=0x4
+		// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+		// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+		// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+		// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+		// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+		// PATCH0.derate_sys_en:29:1:=0x1
+		// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+		mmio_wr32(0x08004000 + 0x44, 0x00000000);
+		// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+		// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+		// PATCH1.ref_adv_max:16:7:=0x0
+		mmio_wr32(0x08004000 + 0x148, 0x999F0000);
+		// PATCH4.t_phyd_rden:16:6=0x0
+		// PATCH4.phyd_rd_clk_stop:23:1=0x0
+		// PATCH4.t_phyd_wren:24:6=0x0
+		// PATCH4.phyd_wr_clk_stop:31:1=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x0, 0x81041401);
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		mmio_wr32(0x08004000 + 0x34, 0x00930001);
+		mmio_wr32(0x08004000 + 0x38, 0x00020000);
+		mmio_wr32(0x08004000 + 0x50, 0x00201070);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+		mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+		mmio_wr32(0x08004000 + 0xc0, 0x00000000);
+		mmio_wr32(0x08004000 + 0xc4, 0x00000000);
+	#ifdef DDR_INIT_SPEED_UP
+		mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+		mmio_wr32(0x08004000 + 0xd4, 0x00020000);
+	#else
+		mmio_wr32(0x08004000 + 0xd0, 0x000100E5);
+		mmio_wr32(0x08004000 + 0xd4, 0x006A0000);
+	#endif
+		mmio_wr32(0x08004000 + 0xdc, 0x1F140040);
+	#ifdef DDR_DODT
+		mmio_wr32(0x08004000 + 0xe0, 0x04600000);
+	#else
+		mmio_wr32(0x08004000 + 0xe0, 0x00600000);
+	#endif
+		mmio_wr32(0x08004000 + 0xe4, 0x000B03BF);
+		mmio_wr32(0x08004000 + 0x100, 0x0E111F10);
+		mmio_wr32(0x08004000 + 0x104, 0x00030417);
+		mmio_wr32(0x08004000 + 0x108, 0x0507060A);
+		mmio_wr32(0x08004000 + 0x10c, 0x00002007);
+		mmio_wr32(0x08004000 + 0x110, 0x07020307);
+		mmio_wr32(0x08004000 + 0x114, 0x05050303);
+		mmio_wr32(0x08004000 + 0x120, 0x00000907);
+		mmio_wr32(0x08004000 + 0x13c, 0x00000000);
+		mmio_wr32(0x08004000 + 0x180, 0xC0960026);
+		mmio_wr32(0x08004000 + 0x184, 0x00000001);
+		// phyd related
+		mmio_wr32(0x08004000 + 0x190, 0x048a8305);
+		// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+		// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+		// DFITMG0.dfi_t_rddata_en:16:7:=0xa
+		// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+		// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+		// DFITMG0.dfi_tphy_wrlat:0:6:=0x5
+		mmio_wr32(0x08004000 + 0x194, 0x00070202);
+		// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+		// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+		// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+		// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+		// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+		mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+		// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+		// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+		// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+		// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+		// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+		// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+		// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+		mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+		mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+		mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+		mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+		// address map, auto gen.
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x00070707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+		mmio_wr32(0x08004000 + 0x218, 0x06060606);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x06060606);
+		mmio_wr32(0x08004000 + 0x228, 0x06060606);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x240, 0x08000610);
+	#ifdef DDR_DODT
+		mmio_wr32(0x08004000 + 0x244, 0x00000001);
+	#else
+		mmio_wr32(0x08004000 + 0x244, 0x00000000);
+	#endif
+		mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+		// SCHED.opt_vprw_sch:31:1:=0x0
+		// SCHED.rdwr_idle_gap:24:7:=0x0
+		// SCHED.go2critical_hysteresis:16:8:=0x0
+		// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+		// SCHED.lpr_num_entries:8:7:=0x1f
+		// SCHED.autopre_rmw:7:1:=0x1
+		// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+		// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+		// SCHED.opt_wrcam_fill_level:4:1:=0x0
+		// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+		// SCHED.pageclose:2:1:=0x1
+		// SCHED.prefer_write:1:1:=0x0
+		// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x254, 0x00000000);
+		// SCHED1.page_hit_limit_rd:28:3:=0x0
+		// SCHED1.page_hit_limit_wr:24:3:=0x0
+		// SCHED1.visible_window_limit_rd:20:3:=0x0
+		// SCHED1.visible_window_limit_wr:16:3:=0x0
+		// SCHED1.delay_switch_write:12:4:=0x0
+		// SCHED1.pageclose_timer:0:8:=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x25c, 0x100000F0);
+		// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+		// PERFHPR1.hpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x264, 0x100000F0);
+		// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+		// PERFLPR1.lpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x26c, 0x100000F0);
+		// PERFWR1.w_xact_run_length:24:8:=0x20
+		// PERFWR1.w_max_starve:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x300, 0x00000000);
+		// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+		// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+		// DBG0.dis_collision_page_opt:4:1:=0x0
+		// DBG0.dis_act_bypass:2:1:=0x0
+		// DBG0.dis_rd_bypass:1:1:=0x0
+		// DBG0.dis_wc:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x304, 0x00000000);
+		// DBG1.dis_hif:1:1:=0x0
+		// DBG1.dis_dq:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+		mmio_wr32(0x08004000 + 0x320, 0x00000001);
+		// SWCTL.sw_done:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+		// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+		// POISONCFG.rd_poison_intr_en:20:1:=0x0
+		// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+		// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+		// POISONCFG.wr_poison_intr_en:4:1:=0x0
+		// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x400, 0x00000011);
+		// PCCFG.dch_density_ratio:12:2:=0x0
+		// PCCFG.bl_exp_mode:8:1:=0x0
+		// PCCFG.pagematch_limit:4:1:=0x1
+		// PCCFG.go2critical_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x404, 0x00006000);
+		// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_0.rd_port_aging_en:12:1:=0x0
+		// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_0.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x408, 0x00006000);
+		// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_0.wr_port_aging_en:12:1:=0x0
+		// PCFGW_0.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x490, 0x00000001);
+		// PCTRL_0.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x494, 0x00000007);
+		// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+		// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+		// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+		// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+		// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_1.rd_port_aging_en:12:1:=0x0
+		// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_1.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+		// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_1.wr_port_aging_en:12:1:=0x0
+		// PCFGW_1.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x540, 0x00000001);
+		// PCTRL_1.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x544, 0x00000007);
+		// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+		// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+		// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+		// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x564, 0x00006000);
+		// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_2.rd_port_aging_en:12:1:=0x0
+		// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_2.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x568, 0x00006000);
+		// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_2.wr_port_aging_en:12:1:=0x0
+		// PCFGW_2.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+		// PCTRL_2.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+		// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+		// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+		// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+		// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+	} else {
+		NOTICE("DDR2 1333 ddrc_init\n");
+		mmio_wr32(0x08004000 + 0xc, 0x63746371);
+		// PATCH0.use_blk_ext}:0:2:=0x1
+		// PATCH0.dis_auto_ref_cnt_fix:2:1:=0x0
+		// PATCH0.dis_auto_ref_algn_to_8:3:1:=0x0
+		// PATCH0.starve_stall_at_dfi_ctrlupd:4:1:=0x1
+		// PATCH0.starve_stall_at_abr:5:1:=0x1
+		// PATCH0.dis_rdwr_switch_at_abr:6:1:=0x1
+		// PATCH0.dfi_wdata_same_to_axi:7:1:=0x0
+		// PATCH0.pagematch_limit_threshold:8:3=0x3
+		// PATCH0.qos_sel:12:2:=0x2
+		// PATCH0.burst_rdwr_xpi:16:4:=0x4
+		// PATCH0.always_critical_when_urgent_hpr:20:1:=0x1
+		// PATCH0.always_critical_when_urgent_lpr:21:1:=0x1
+		// PATCH0.always_critical_when_urgent_wr:22:1:=0x1
+		// PATCH0.disable_hif_rcmd_stall_path:24:1:=0x1
+		// PATCH0.disable_hif_wcmd_stall_path:25:1:=0x1
+		// PATCH0.derate_sys_en:29:1:=0x1
+		// PATCH0.ref_4x_sys_high_temp:30:1:=0x1
+		mmio_wr32(0x08004000 + 0x44, 0x00000000);
+		// PATCH1.ref_adv_stop_threshold:0:7:=0x0
+		// PATCH1.ref_adv_dec_threshold:8:7:=0x0
+		// PATCH1.ref_adv_max:16:7:=0x0
+		mmio_wr32(0x08004000 + 0x148, 0x989D0000);
+		// PATCH4.t_phyd_rden:16:6=0x0
+		// PATCH4.phyd_rd_clk_stop:23:1=0x0
+		// PATCH4.t_phyd_wren:24:6=0x0
+		// PATCH4.phyd_wr_clk_stop:31:1=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x0, 0x81041400);
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		mmio_wr32(0x08004000 + 0x34, 0x006A0001);
+		mmio_wr32(0x08004000 + 0x38, 0x00020000);
+		mmio_wr32(0x08004000 + 0x50, 0x00201070);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+		mmio_wr32(0x08004000 + 0x64, 0x0051006E);
+	#ifdef DDR_INIT_SPEED_UP
+		mmio_wr32(0x08004000 + 0xd0, 0x00010002);
+		mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+	#else
+		mmio_wr32(0x08004000 + 0xd0, 0x00010043);
+		mmio_wr32(0x08004000 + 0xd4, 0x00000000);
+	#endif
+		mmio_wr32(0x08004000 + 0xdc, 0x03030040);
+		mmio_wr32(0x08004000 + 0xe0, 0x00800000);
+		mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+		mmio_wr32(0x08004000 + 0x104, 0x00030414);
+		mmio_wr32(0x08004000 + 0x108, 0x04050409);
+		mmio_wr32(0x08004000 + 0x10c, 0x00003004);
+		mmio_wr32(0x08004000 + 0x110, 0x05020406);
+		mmio_wr32(0x08004000 + 0x114, 0x01010303);
+		mmio_wr32(0x08004000 + 0x120, 0x00000505);
+		// phyd related
+		mmio_wr32(0x08004000 + 0x190, 0x04878304);
+		// DFITMG0.dfi_t_ctrl_delay:24:5:=0x4
+		// DFITMG0.dfi_rddata_use_dfi_phy_clk:23:1:=0x1
+		// DFITMG0.dfi_t_rddata_en:16:7:=0x6
+		// DFITMG0.dfi_wrdata_use_dfi_phy_clk:15:1:=0x1
+		// DFITMG0.dfi_tphy_wrdata:8:6:=0x3
+		// DFITMG0.dfi_tphy_wrlat:0:6:=0x4
+		mmio_wr32(0x08004000 + 0x194, 0x00070102);
+		// DFITMG1.dfi_t_cmd_lat:28:4:=0x0
+		// DFITMG1.dfi_t_parin_lat:24:2:=0x0
+		// DFITMG1.dfi_t_wrdata_delay:16:5:=0x7
+		// DFITMG1.dfi_t_dram_clk_disable:8:5:=0x2
+		// DFITMG1.dfi_t_dram_clk_enable:0:5:=0x2
+		mmio_wr32(0x08004000 + 0x198, 0x07c13121);
+		// DFILPCFG0.dfi_tlp_resp:24:5:=0x7
+		// DFILPCFG0.dfi_lp_wakeup_dpd:20:4:=0xc
+		// DFILPCFG0.dfi_lp_en_dpd:16:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_sr:12:4:=0x3
+		// DFILPCFG0.dfi_lp_en_sr:8:1:=0x1
+		// DFILPCFG0.dfi_lp_wakeup_pd:4:4:=0x2
+		// DFILPCFG0.dfi_lp_en_pd:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x19c, 0x00000021);
+		// DFILPCFG1.dfi_lp_wakeup_mpsm:4:4:=0x2
+		// DFILPCFG1.dfi_lp_en_mpsm:0:1:=0x1
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		mmio_wr32(0x08004000 + 0x1a4, 0x00FE00FF);
+		mmio_wr32(0x08004000 + 0x1a8, 0x80000000);
+		mmio_wr32(0x08004000 + 0x1b0, 0x000002C1);
+		mmio_wr32(0x08004000 + 0x1c0, 0x00000001);
+		mmio_wr32(0x08004000 + 0x1c4, 0x00000001);
+		// address map, auto gen.
+		// support from 0.5Gb to 4Gb
+		// R[17:13]B[2]R[12:0]B[1:0]C[9:0]
+		mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x204, 0x00140707);
+		mmio_wr32(0x08004000 + 0x208, 0x00000000);
+		mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+		mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+		mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+		mmio_wr32(0x08004000 + 0x218, 0x06060605);
+		mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+		mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+		mmio_wr32(0x08004000 + 0x224, 0x05050505);
+		mmio_wr32(0x08004000 + 0x228, 0x05050505);
+		mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x240, 0x07030710); // TBD
+		mmio_wr32(0x08004000 + 0x244, 0x00000000);
+		mmio_wr32(0x08004000 + 0x250, 0x00003F85);
+		// SCHED.opt_vprw_sch:31:1:=0x0
+		// SCHED.rdwr_idle_gap:24:7:=0x0
+		// SCHED.go2critical_hysteresis:16:8:=0x0
+		// SCHED.lpddr4_opt_act_timing:15:1:=0x0
+		// SCHED.lpr_num_entries:8:7:=0x1f
+		// SCHED.autopre_rmw:7:1:=0x1
+		// SCHED.dis_opt_ntt_by_pre:6:1:=0x0
+		// SCHED.dis_opt_ntt_by_act:5:1:=0x0
+		// SCHED.opt_wrcam_fill_level:4:1:=0x0
+		// SCHED.rdwr_switch_policy_sel:3:1:=0x0
+		// SCHED.pageclose:2:1:=0x0
+		// SCHED.prefer_write:1:1:=0x0
+		// SCHED.dis_opt_wrecc_collision_flush:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x254, 0x00000020);
+		// SCHED1.page_hit_limit_rd:28:3:=0x0
+		// SCHED1.page_hit_limit_wr:24:3:=0x0
+		// SCHED1.visible_window_limit_rd:20:3:=0x0
+		// SCHED1.visible_window_limit_wr:16:3:=0x0
+		// SCHED1.delay_switch_write:12:4:=0x0
+		// SCHED1.pageclose_timer:0:8:=0x0
+		// auto gen.
+		mmio_wr32(0x08004000 + 0x25c, 0x100000A8);
+		// PERFHPR1.hpr_xact_run_length:24:8:=0x20
+		// PERFHPR1.hpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x264, 0x100000A8);
+		// PERFLPR1.lpr_xact_run_length:24:8:=0x20
+		// PERFLPR1.lpr_max_starve:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x26c, 0x100000A8);
+		// PERFWR1.w_xact_run_length:24:8:=0x20
+		// PERFWR1.w_max_starve:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x300, 0x00000000);
+		// DBG0.dis_max_rank_wr_opt:7:1:=0x0
+		// DBG0.dis_max_rank_rd_opt:6:1:=0x0
+		// DBG0.dis_collision_page_opt:4:1:=0x0
+		// DBG0.dis_act_bypass:2:1:=0x0
+		// DBG0.dis_rd_bypass:1:1:=0x0
+		// DBG0.dis_wc:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x304, 0x00000000);
+		// DBG1.dis_hif:1:1:=0x0
+		// DBG1.dis_dq:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x30c, 0x00000000);
+		mmio_wr32(0x08004000 + 0x320, 0x00000001);
+		// SWCTL.sw_done:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x36c, 0x00000000);
+		// POISONCFG.rd_poison_intr_clr:24:1:=0x0
+		// POISONCFG.rd_poison_intr_en:20:1:=0x0
+		// POISONCFG.rd_poison_slverr_en:16:1:=0x0
+		// POISONCFG.wr_poison_intr_clr:8:1:=0x0
+		// POISONCFG.wr_poison_intr_en:4:1:=0x0
+		// POISONCFG.wr_poison_slverr_en:0:1:=0x0
+		mmio_wr32(0x08004000 + 0x400, 0x00000011);
+		// PCCFG.dch_density_ratio:12:2:=0x0
+		// PCCFG.bl_exp_mode:8:1:=0x0
+		// PCCFG.pagematch_limit:4:1:=0x1
+		// PCCFG.go2critical_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x404, 0x00006000);
+		// PCFGR_0.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_0.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_0.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_0.rd_port_aging_en:12:1:=0x0
+		// PCFGR_0.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_0.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x408, 0x00006000);
+		// PCFGW_0.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_0.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_0.wr_port_aging_en:12:1:=0x0
+		// PCFGW_0.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x490, 0x00000001);
+		// PCTRL_0.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x494, 0x00000007);
+		// PCFGQOS0_0.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_0.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_0.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_0.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_0.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x498, 0x0000006a);
+		// PCFGQOS1_0.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_0.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x49c, 0x00000e07);
+		// PCFGWQOS0_0.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_0.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_0.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_0.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_0.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x4a0, 0x01a801a8);
+		// PCFGWQOS1_0.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_0.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x4b4, 0x00006000);
+		// PCFGR_1.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_1.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_1.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_1.rd_port_aging_en:12:1:=0x0
+		// PCFGR_1.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_1.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x4b8, 0x00006000);
+		// PCFGW_1.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_1.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_1.wr_port_aging_en:12:1:=0x0
+		// PCFGW_1.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x540, 0x00000001);
+		// PCTRL_1.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x544, 0x00000007);
+		// PCFGQOS0_1.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_1.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_1.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_1.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_1.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x548, 0x0000006a);
+		// PCFGQOS1_1.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_1.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x54c, 0x00000e07);
+		// PCFGWQOS0_1.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_1.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_1.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_1.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_1.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x550, 0x01a801a8);
+		// PCFGWQOS1_1.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_1.wqos_map_timeout1:0:16:=0x1a8
+		mmio_wr32(0x08004000 + 0x564, 0x00006000);
+		// PCFGR_2.rdwr_ordered_en:16:1:=0x0
+		// PCFGR_2.rd_port_pagematch_en:14:1:=0x1
+		// PCFGR_2.rd_port_urgent_en:13:1:=0x1
+		// PCFGR_2.rd_port_aging_en:12:1:=0x0
+		// PCFGR_2.read_reorder_bypass_en:11:1:=0x0
+		// PCFGR_2.rd_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x568, 0x00006000);
+		// PCFGW_2.wr_port_pagematch_en:14:1:=0x1
+		// PCFGW_2.wr_port_urgent_en:13:1:=0x1
+		// PCFGW_2.wr_port_aging_en:12:1:=0x0
+		// PCFGW_2.wr_port_priority:0:10:=0x0
+		mmio_wr32(0x08004000 + 0x5f0, 0x00000001);
+		// PCTRL_2.port_en:0:1:=0x1
+		mmio_wr32(0x08004000 + 0x5f4, 0x00000007);
+		// PCFGQOS0_2.rqos_map_region2:24:8:=0x0
+		// PCFGQOS0_2.rqos_map_region1:20:4:=0x0
+		// PCFGQOS0_2.rqos_map_region0:16:4:=0x0
+		// PCFGQOS0_2.rqos_map_level2:8:8:=0x0
+		// PCFGQOS0_2.rqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x5f8, 0x0000006a);
+		// PCFGQOS1_2.rqos_map_timeoutr:16:16:=0x0
+		// PCFGQOS1_2.rqos_map_timeoutb:0:16:=0x6a
+		mmio_wr32(0x08004000 + 0x5fc, 0x00000e07);
+		// PCFGWQOS0_2.wqos_map_region2:24:8:=0x0
+		// PCFGWQOS0_2.wqos_map_region1:20:4:=0x0
+		// PCFGWQOS0_2.wqos_map_region0:16:4:=0x0
+		// PCFGWQOS0_2.wqos_map_level2:8:8:=0xe
+		// PCFGWQOS0_2.wqos_map_level1:0:8:=0x7
+		mmio_wr32(0x08004000 + 0x600, 0x01a801a8);
+		// PCFGWQOS1_2.wqos_map_timeout2:16:16:=0x1a8
+		// PCFGWQOS1_2.wqos_map_timeout1:0:16:=0x1a8
+	}
+}
+
+void ctrl_init_high_patch(void)
+{
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// enable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000002);
+		// enable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+		// enable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+		// change xpi to multi DDR burst
+		//mmio_wr32(0x08004000 + 0xc, 0x63786370);
+	} else {
+		// enable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000002);
+		// enable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0x00400018);
+		// enable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000000);
+		// change xpi to multi DDR burst
+		//mmio_wr32(0x08004000 + 0xc, 0x63786370);
+	}
+}
+
+void ctrl_init_low_patch(void)
+{
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// disable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		// disable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		// disable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+		// change xpi to single DDR burst
+		//mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	} else {
+		// disable auto PD/SR
+		mmio_wr32(0x08004000 + 0x30, 0x00000000);
+		// disable auto ctrl_upd
+		mmio_wr32(0x08004000 + 0x1a0, 0xC0400018);
+		// disable clock gating
+		mmio_wr32(0x0800a000 + 0x14, 0x00000fff);
+		// change xpi to single DDR burst
+		//mmio_wr32(0x08004000 + 0xc, 0x63746371);
+	}
+}
+
+void ctrl_init_update_by_dram_size(uint8_t dram_cap_in_mbyte)
+{
+	uint8_t dram_cap_in_mbyte_per_dev;
+
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = mmio_rd32(0x08004000 + 0x0);
+		dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+		dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+		dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+		switch (dram_cap_in_mbyte_per_dev) {
+		case 6:
+			mmio_wr32(0x08004000 + 0x64, 0x0071002A);
+			mmio_wr32(0x08004000 + 0x120, 0x00000903);
+			break;
+		case 7:
+			mmio_wr32(0x08004000 + 0x64, 0x00710034);
+			mmio_wr32(0x08004000 + 0x120, 0x00000903);
+			break;
+		case 8:
+			mmio_wr32(0x08004000 + 0x64, 0x0071004B);
+			mmio_wr32(0x08004000 + 0x120, 0x00000904);
+			break;
+		case 9:
+			mmio_wr32(0x08004000 + 0x64, 0x0071007A);
+			mmio_wr32(0x08004000 + 0x120, 0x00000905);
+			break;
+		case 10:
+			mmio_wr32(0x08004000 + 0x64, 0x007100A4);
+			mmio_wr32(0x08004000 + 0x120, 0x00000907);
+			break;
+		}
+		// toggle refresh_update_level
+		mmio_wr32(0x08004000 + 0x60, 0x00000002);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	} else {
+		rddata = mmio_rd32(0x08004000 + 0x0);
+		dram_cap_in_mbyte_per_dev = dram_cap_in_mbyte;
+		dram_cap_in_mbyte_per_dev >>= (1 - get_bits_from_value(rddata, 13, 12)); // change sys cap to x16 cap
+		dram_cap_in_mbyte_per_dev >>= (2 - get_bits_from_value(rddata, 31, 30)); // change x16 cap to device cap
+		switch (dram_cap_in_mbyte_per_dev) {
+		case 5:
+			mmio_wr32(0x08004000 + 0x64, 0x00510019);
+			mmio_wr32(0x08004000 + 0x100, 0x0B011610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000502);
+			break;
+		case 6:
+			mmio_wr32(0x08004000 + 0x64, 0x0051002C);
+			mmio_wr32(0x08004000 + 0x100, 0x0B011610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000503);
+			break;
+		case 7:
+			mmio_wr32(0x08004000 + 0x64, 0x0051002B);
+			mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000503);
+			break;
+		case 8:
+			mmio_wr32(0x08004000 + 0x64, 0x00510041);
+			mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000504);
+			break;
+		case 9:
+			mmio_wr32(0x08004000 + 0x64, 0x0051006E);
+			mmio_wr32(0x08004000 + 0x100, 0x0B0F1610);
+			mmio_wr32(0x08004000 + 0x120, 0x00000505);
+			break;
+		}
+
+		switch (dram_cap_in_mbyte_per_dev) {
+		case 5:
+			mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x204, 0x003F0606);
+			mmio_wr32(0x08004000 + 0x208, 0x00000000);
+			mmio_wr32(0x08004000 + 0x20c, 0x1F1F0000);
+			mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x214, 0x040F0404);
+			mmio_wr32(0x08004000 + 0x218, 0x04040404);
+			mmio_wr32(0x08004000 + 0x21c, 0x00000404);
+			mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+			mmio_wr32(0x08004000 + 0x224, 0x04040404);
+			mmio_wr32(0x08004000 + 0x228, 0x04040404);
+			mmio_wr32(0x08004000 + 0x22c, 0x001F1F04);
+			break;
+		case 6:
+			mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x204, 0x003F0707);
+			mmio_wr32(0x08004000 + 0x208, 0x00000000);
+			mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+			mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x214, 0x050F0505);
+			mmio_wr32(0x08004000 + 0x218, 0x05050505);
+			mmio_wr32(0x08004000 + 0x21c, 0x00000505);
+			mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+			mmio_wr32(0x08004000 + 0x224, 0x05050505);
+			mmio_wr32(0x08004000 + 0x228, 0x05050505);
+			mmio_wr32(0x08004000 + 0x22c, 0x001F1F05);
+			break;
+		case 7:
+		case 8:
+		case 9:
+			mmio_wr32(0x08004000 + 0x200, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x204, 0x00070707);
+			mmio_wr32(0x08004000 + 0x208, 0x00000000);
+			mmio_wr32(0x08004000 + 0x20c, 0x1F000000);
+			mmio_wr32(0x08004000 + 0x210, 0x00001F1F);
+			mmio_wr32(0x08004000 + 0x214, 0x060F0606);
+			mmio_wr32(0x08004000 + 0x218, 0x06060606);
+			mmio_wr32(0x08004000 + 0x21c, 0x00000606);
+			mmio_wr32(0x08004000 + 0x220, 0x00003F3F);
+			mmio_wr32(0x08004000 + 0x224, 0x06060606);
+			mmio_wr32(0x08004000 + 0x228, 0x06060606);
+			mmio_wr32(0x08004000 + 0x22c, 0x001F1F06);
+			break;
+		}
+		// toggle refresh_update_level
+		mmio_wr32(0x08004000 + 0x60, 0x00000002);
+		mmio_wr32(0x08004000 + 0x60, 0x00000000);
+	}
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/phy_init.c b/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/phy_init.c
new file mode 100644
index 0000000..db28655
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_config/ddr_auto_x16/phy_init.c
@@ -0,0 +1,281 @@
+#include <mmio.h>
+// #include <soc.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#include <ddr2_1333_init.h>
+#include <ddr3_1866_init.h>
+#include <ddr_pkg_info.h>
+// #include <printf.h>
+
+void phy_init(void)
+{
+	uint8_t ISDDR3 = 0;
+
+	if (get_ddr_type() == DDR_TYPE_DDR3)
+		ISDDR3 = 1;
+	else
+		ISDDR3 = 0;
+
+	NOTICE("ISDDR3=%d.\n", ISDDR3);
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_0_DATA : DDR2_PHY_REG_0_DATA);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_1_DATA : DDR2_PHY_REG_1_DATA);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_2_DATA : DDR2_PHY_REG_2_DATA);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_3_DATA : DDR2_PHY_REG_3_DATA);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_4_DATA : DDR2_PHY_REG_4_DATA);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_5_DATA : DDR2_PHY_REG_5_DATA);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_6_DATA : DDR2_PHY_REG_6_DATA);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_7_DATA : DDR2_PHY_REG_7_DATA);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_8_DATA : DDR2_PHY_REG_8_DATA);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_9_DATA : DDR2_PHY_REG_9_DATA);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_10_DATA : DDR2_PHY_REG_10_DATA);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_11_DATA : DDR2_PHY_REG_11_DATA);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_16_DATA : DDR2_PHY_REG_16_DATA);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_17_DATA : DDR2_PHY_REG_17_DATA);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_18_DATA : DDR2_PHY_REG_18_DATA);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_19_DATA : DDR2_PHY_REG_19_DATA);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_20_DATA : DDR2_PHY_REG_20_DATA);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_21_DATA : DDR2_PHY_REG_21_DATA);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_22_DATA : DDR2_PHY_REG_22_DATA);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_23_DATA : DDR2_PHY_REG_23_DATA);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_24_DATA : DDR2_PHY_REG_24_DATA);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_25_DATA : DDR2_PHY_REG_25_DATA);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_26_DATA : DDR2_PHY_REG_26_DATA);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_28_DATA : DDR2_PHY_REG_28_DATA);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_29_DATA : DDR2_PHY_REG_29_DATA);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_32_DATA : DDR2_PHY_REG_32_DATA);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_33_DATA : DDR2_PHY_REG_33_DATA);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_34_DATA : DDR2_PHY_REG_34_DATA);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_35_DATA : DDR2_PHY_REG_35_DATA);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_36_DATA : DDR2_PHY_REG_36_DATA);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_37_DATA : DDR2_PHY_REG_37_DATA);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_40_DATA : DDR2_PHY_REG_40_DATA);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_41_DATA : DDR2_PHY_REG_41_DATA);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_42_DATA : DDR2_PHY_REG_42_DATA);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_43_DATA : DDR2_PHY_REG_43_DATA);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_44_DATA : DDR2_PHY_REG_44_DATA);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_45_DATA : DDR2_PHY_REG_45_DATA);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_46_DATA : DDR2_PHY_REG_46_DATA);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_47_DATA : DDR2_PHY_REG_47_DATA);
+	mmio_wr32(0xf0 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_60_DATA : DDR2_PHY_REG_60_DATA);
+	mmio_wr32(0xf4 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_61_DATA : DDR2_PHY_REG_61_DATA);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_62_DATA : DDR2_PHY_REG_62_DATA);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_63_DATA : DDR2_PHY_REG_63_DATA);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_64_DATA : DDR2_PHY_REG_64_DATA);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_65_DATA : DDR2_PHY_REG_65_DATA);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_67_DATA : DDR2_PHY_REG_67_DATA);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_68_DATA : DDR2_PHY_REG_68_DATA);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_69_DATA : DDR2_PHY_REG_69_DATA);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_70_DATA : DDR2_PHY_REG_70_DATA);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_71_DATA : DDR2_PHY_REG_71_DATA);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_72_DATA : DDR2_PHY_REG_72_DATA);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_73_DATA : DDR2_PHY_REG_73_DATA);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_74_DATA : DDR2_PHY_REG_74_DATA);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_75_DATA : DDR2_PHY_REG_75_DATA);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_76_DATA : DDR2_PHY_REG_76_DATA);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_77_DATA : DDR2_PHY_REG_77_DATA);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_78_DATA : DDR2_PHY_REG_78_DATA);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_80_DATA : DDR2_PHY_REG_80_DATA);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_81_DATA : DDR2_PHY_REG_81_DATA);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_82_DATA : DDR2_PHY_REG_82_DATA);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_83_DATA : DDR2_PHY_REG_83_DATA);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_84_DATA : DDR2_PHY_REG_84_DATA);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_85_DATA : DDR2_PHY_REG_85_DATA);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_86_DATA : DDR2_PHY_REG_86_DATA);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_87_DATA : DDR2_PHY_REG_87_DATA);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_89_DATA : DDR2_PHY_REG_89_DATA);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_90_DATA : DDR2_PHY_REG_90_DATA);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_91_DATA : DDR2_PHY_REG_91_DATA);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_92_DATA : DDR2_PHY_REG_92_DATA);
+	mmio_wr32(0x174 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_93_DATA : DDR2_PHY_REG_93_DATA);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_96_DATA : DDR2_PHY_REG_96_DATA);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_97_DATA : DDR2_PHY_REG_97_DATA);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_98_DATA : DDR2_PHY_REG_98_DATA);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_99_DATA : DDR2_PHY_REG_99_DATA);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_100_DATA : DDR2_PHY_REG_100_DATA);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_128_DATA : DDR2_PHY_REG_128_DATA);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_129_DATA : DDR2_PHY_REG_129_DATA);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_130_DATA : DDR2_PHY_REG_130_DATA);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_136_DATA : DDR2_PHY_REG_136_DATA);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_137_DATA : DDR2_PHY_REG_137_DATA);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_138_DATA : DDR2_PHY_REG_138_DATA);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_0_F0_DATA : DDR2_PHY_REG_0_F0_DATA);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_1_F0_DATA : DDR2_PHY_REG_1_F0_DATA);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_2_F0_DATA : DDR2_PHY_REG_2_F0_DATA);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_3_F0_DATA : DDR2_PHY_REG_3_F0_DATA);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_4_F0_DATA : DDR2_PHY_REG_4_F0_DATA);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_5_F0_DATA : DDR2_PHY_REG_5_F0_DATA);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_6_F0_DATA : DDR2_PHY_REG_6_F0_DATA);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_7_F0_DATA : DDR2_PHY_REG_7_F0_DATA);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_64_F0_DATA : DDR2_PHY_REG_64_F0_DATA);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_65_F0_DATA : DDR2_PHY_REG_65_F0_DATA);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_66_F0_DATA : DDR2_PHY_REG_66_F0_DATA);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_67_F0_DATA : DDR2_PHY_REG_67_F0_DATA);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_68_F0_DATA : DDR2_PHY_REG_68_F0_DATA);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_69_F0_DATA : DDR2_PHY_REG_69_F0_DATA);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_70_F0_DATA : DDR2_PHY_REG_70_F0_DATA);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_71_F0_DATA : DDR2_PHY_REG_71_F0_DATA);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_72_F0_DATA : DDR2_PHY_REG_72_F0_DATA);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_80_F0_DATA : DDR2_PHY_REG_80_F0_DATA);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_81_F0_DATA : DDR2_PHY_REG_81_F0_DATA);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_82_F0_DATA : DDR2_PHY_REG_82_F0_DATA);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_83_F0_DATA : DDR2_PHY_REG_83_F0_DATA);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_84_F0_DATA : DDR2_PHY_REG_84_F0_DATA);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_85_F0_DATA : DDR2_PHY_REG_85_F0_DATA);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_86_F0_DATA : DDR2_PHY_REG_86_F0_DATA);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_87_F0_DATA : DDR2_PHY_REG_87_F0_DATA);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_88_F0_DATA : DDR2_PHY_REG_88_F0_DATA);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_320_F0_DATA : DDR2_PHY_REG_320_F0_DATA);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_331_F0_DATA : DDR2_PHY_REG_331_F0_DATA);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_332_F0_DATA : DDR2_PHY_REG_332_F0_DATA);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_333_F0_DATA : DDR2_PHY_REG_333_F0_DATA);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_334_F0_DATA : DDR2_PHY_REG_334_F0_DATA);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_336_F0_DATA : DDR2_PHY_REG_336_F0_DATA);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_348_F0_DATA : DDR2_PHY_REG_348_F0_DATA);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_349_F0_DATA : DDR2_PHY_REG_349_F0_DATA);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_350_F0_DATA : DDR2_PHY_REG_350_F0_DATA);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_351_F0_DATA : DDR2_PHY_REG_351_F0_DATA);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_352_F0_DATA : DDR2_PHY_REG_352_F0_DATA);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_384_F0_DATA : DDR2_PHY_REG_384_F0_DATA);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_385_F0_DATA : DDR2_PHY_REG_385_F0_DATA);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_386_F0_DATA : DDR2_PHY_REG_386_F0_DATA);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_387_F0_DATA : DDR2_PHY_REG_387_F0_DATA);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_388_F0_DATA : DDR2_PHY_REG_388_F0_DATA);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_389_F0_DATA : DDR2_PHY_REG_389_F0_DATA);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_390_F0_DATA : DDR2_PHY_REG_390_F0_DATA);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_391_F0_DATA : DDR2_PHY_REG_391_F0_DATA);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_392_F0_DATA : DDR2_PHY_REG_392_F0_DATA);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_393_F0_DATA : DDR2_PHY_REG_393_F0_DATA);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_394_F0_DATA : DDR2_PHY_REG_394_F0_DATA);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_395_F0_DATA : DDR2_PHY_REG_395_F0_DATA);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_396_F0_DATA : DDR2_PHY_REG_396_F0_DATA);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_397_F0_DATA : DDR2_PHY_REG_397_F0_DATA);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_398_F0_DATA : DDR2_PHY_REG_398_F0_DATA);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_399_F0_DATA : DDR2_PHY_REG_399_F0_DATA);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_400_F0_DATA : DDR2_PHY_REG_400_F0_DATA);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_401_F0_DATA : DDR2_PHY_REG_401_F0_DATA);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_402_F0_DATA : DDR2_PHY_REG_402_F0_DATA);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_403_F0_DATA : DDR2_PHY_REG_403_F0_DATA);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_404_F0_DATA : DDR2_PHY_REG_404_F0_DATA);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_405_F0_DATA : DDR2_PHY_REG_405_F0_DATA);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_406_F0_DATA : DDR2_PHY_REG_406_F0_DATA);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_407_F0_DATA : DDR2_PHY_REG_407_F0_DATA);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_408_F0_DATA : DDR2_PHY_REG_408_F0_DATA);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_409_F0_DATA : DDR2_PHY_REG_409_F0_DATA);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_410_F0_DATA : DDR2_PHY_REG_410_F0_DATA);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_411_F0_DATA : DDR2_PHY_REG_411_F0_DATA);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_412_F0_DATA : DDR2_PHY_REG_412_F0_DATA);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_413_F0_DATA : DDR2_PHY_REG_413_F0_DATA);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_414_F0_DATA : DDR2_PHY_REG_414_F0_DATA);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_415_F0_DATA : DDR2_PHY_REG_415_F0_DATA);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_448_F0_DATA : DDR2_PHY_REG_448_F0_DATA);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_449_F0_DATA : DDR2_PHY_REG_449_F0_DATA);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_450_F0_DATA : DDR2_PHY_REG_450_F0_DATA);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_451_F0_DATA : DDR2_PHY_REG_451_F0_DATA);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_452_F0_DATA : DDR2_PHY_REG_452_F0_DATA);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_453_F0_DATA : DDR2_PHY_REG_453_F0_DATA);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_454_F0_DATA : DDR2_PHY_REG_454_F0_DATA);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_455_F0_DATA : DDR2_PHY_REG_455_F0_DATA);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_456_F0_DATA : DDR2_PHY_REG_456_F0_DATA);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_457_F0_DATA : DDR2_PHY_REG_457_F0_DATA);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_460_F0_DATA : DDR2_PHY_REG_460_F0_DATA);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_461_F0_DATA : DDR2_PHY_REG_461_F0_DATA);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_462_F0_DATA : DDR2_PHY_REG_462_F0_DATA);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_463_F0_DATA : DDR2_PHY_REG_463_F0_DATA);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_464_F0_DATA : DDR2_PHY_REG_464_F0_DATA);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_465_F0_DATA : DDR2_PHY_REG_465_F0_DATA);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_466_F0_DATA : DDR2_PHY_REG_466_F0_DATA);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_467_F0_DATA : DDR2_PHY_REG_467_F0_DATA);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_468_F0_DATA : DDR2_PHY_REG_468_F0_DATA);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_469_F0_DATA : DDR2_PHY_REG_469_F0_DATA);
+#ifdef F1_TEST
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_0_F1_DATA : DDR2_PHY_REG_0_F1_DATA);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_1_F1_DATA : DDR2_PHY_REG_1_F1_DATA);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_2_F1_DATA : DDR2_PHY_REG_2_F1_DATA);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_3_F1_DATA : DDR2_PHY_REG_3_F1_DATA);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_4_F1_DATA : DDR2_PHY_REG_4_F1_DATA);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_5_F1_DATA : DDR2_PHY_REG_5_F1_DATA);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_6_F1_DATA : DDR2_PHY_REG_6_F1_DATA);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_7_F1_DATA : DDR2_PHY_REG_7_F1_DATA);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_64_F1_DATA : DDR2_PHY_REG_64_F1_DATA);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_65_F1_DATA : DDR2_PHY_REG_65_F1_DATA);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_66_F1_DATA : DDR2_PHY_REG_66_F1_DATA);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_67_F1_DATA : DDR2_PHY_REG_67_F1_DATA);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_68_F1_DATA : DDR2_PHY_REG_68_F1_DATA);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_69_F1_DATA : DDR2_PHY_REG_69_F1_DATA);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_70_F1_DATA : DDR2_PHY_REG_70_F1_DATA);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_71_F1_DATA : DDR2_PHY_REG_71_F1_DATA);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_72_F1_DATA : DDR2_PHY_REG_72_F1_DATA);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_80_F1_DATA : DDR2_PHY_REG_80_F1_DATA);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_81_F1_DATA : DDR2_PHY_REG_81_F1_DATA);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_82_F1_DATA : DDR2_PHY_REG_82_F1_DATA);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_83_F1_DATA : DDR2_PHY_REG_83_F1_DATA);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_84_F1_DATA : DDR2_PHY_REG_84_F1_DATA);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_85_F1_DATA : DDR2_PHY_REG_85_F1_DATA);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_86_F1_DATA : DDR2_PHY_REG_86_F1_DATA);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_87_F1_DATA : DDR2_PHY_REG_87_F1_DATA);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_88_F1_DATA : DDR2_PHY_REG_88_F1_DATA);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_320_F1_DATA : DDR2_PHY_REG_320_F1_DATA);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_331_F1_DATA : DDR2_PHY_REG_331_F1_DATA);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_332_F1_DATA : DDR2_PHY_REG_332_F1_DATA);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_333_F1_DATA : DDR2_PHY_REG_333_F1_DATA);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_334_F1_DATA : DDR2_PHY_REG_334_F1_DATA);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_336_F1_DATA : DDR2_PHY_REG_336_F1_DATA);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_348_F1_DATA : DDR2_PHY_REG_348_F1_DATA);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_349_F1_DATA : DDR2_PHY_REG_349_F1_DATA);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_350_F1_DATA : DDR2_PHY_REG_350_F1_DATA);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_351_F1_DATA : DDR2_PHY_REG_351_F1_DATA);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_352_F1_DATA : DDR2_PHY_REG_352_F1_DATA);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_384_F1_DATA : DDR2_PHY_REG_384_F1_DATA);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_385_F1_DATA : DDR2_PHY_REG_385_F1_DATA);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_386_F1_DATA : DDR2_PHY_REG_386_F1_DATA);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_387_F1_DATA : DDR2_PHY_REG_387_F1_DATA);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_388_F1_DATA : DDR2_PHY_REG_388_F1_DATA);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_389_F1_DATA : DDR2_PHY_REG_389_F1_DATA);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_390_F1_DATA : DDR2_PHY_REG_390_F1_DATA);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_391_F1_DATA : DDR2_PHY_REG_391_F1_DATA);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_392_F1_DATA : DDR2_PHY_REG_392_F1_DATA);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_393_F1_DATA : DDR2_PHY_REG_393_F1_DATA);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_394_F1_DATA : DDR2_PHY_REG_394_F1_DATA);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_395_F1_DATA : DDR2_PHY_REG_395_F1_DATA);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_396_F1_DATA : DDR2_PHY_REG_396_F1_DATA);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_397_F1_DATA : DDR2_PHY_REG_397_F1_DATA);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_398_F1_DATA : DDR2_PHY_REG_398_F1_DATA);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_399_F1_DATA : DDR2_PHY_REG_399_F1_DATA);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_400_F1_DATA : DDR2_PHY_REG_400_F1_DATA);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_401_F1_DATA : DDR2_PHY_REG_401_F1_DATA);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_402_F1_DATA : DDR2_PHY_REG_402_F1_DATA);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_403_F1_DATA : DDR2_PHY_REG_403_F1_DATA);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_404_F1_DATA : DDR2_PHY_REG_404_F1_DATA);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_405_F1_DATA : DDR2_PHY_REG_405_F1_DATA);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_406_F1_DATA : DDR2_PHY_REG_406_F1_DATA);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_407_F1_DATA : DDR2_PHY_REG_407_F1_DATA);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_408_F1_DATA : DDR2_PHY_REG_408_F1_DATA);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_409_F1_DATA : DDR2_PHY_REG_409_F1_DATA);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_410_F1_DATA : DDR2_PHY_REG_410_F1_DATA);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_411_F1_DATA : DDR2_PHY_REG_411_F1_DATA);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_412_F1_DATA : DDR2_PHY_REG_412_F1_DATA);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_413_F1_DATA : DDR2_PHY_REG_413_F1_DATA);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_414_F1_DATA : DDR2_PHY_REG_414_F1_DATA);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_415_F1_DATA : DDR2_PHY_REG_415_F1_DATA);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_448_F1_DATA : DDR2_PHY_REG_448_F1_DATA);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_449_F1_DATA : DDR2_PHY_REG_449_F1_DATA);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_450_F1_DATA : DDR2_PHY_REG_450_F1_DATA);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_451_F1_DATA : DDR2_PHY_REG_451_F1_DATA);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_452_F1_DATA : DDR2_PHY_REG_452_F1_DATA);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_453_F1_DATA : DDR2_PHY_REG_453_F1_DATA);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_454_F1_DATA : DDR2_PHY_REG_454_F1_DATA);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_455_F1_DATA : DDR2_PHY_REG_455_F1_DATA);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_456_F1_DATA : DDR2_PHY_REG_456_F1_DATA);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_457_F1_DATA : DDR2_PHY_REG_457_F1_DATA);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_460_F1_DATA : DDR2_PHY_REG_460_F1_DATA);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_461_F1_DATA : DDR2_PHY_REG_461_F1_DATA);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_462_F1_DATA : DDR2_PHY_REG_462_F1_DATA);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_463_F1_DATA : DDR2_PHY_REG_463_F1_DATA);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_464_F1_DATA : DDR2_PHY_REG_464_F1_DATA);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_465_F1_DATA : DDR2_PHY_REG_465_F1_DATA);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_466_F1_DATA : DDR2_PHY_REG_466_F1_DATA);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_467_F1_DATA : DDR2_PHY_REG_467_F1_DATA);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_468_F1_DATA : DDR2_PHY_REG_468_F1_DATA);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, ISDDR3 ? DDR_PHY_REG_469_F1_DATA : DDR2_PHY_REG_469_F1_DATA);
+#endif
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_pkg_info.c b/firmware/plat/cv181x/ddr/ddr_pkg_info.c
new file mode 100644
index 0000000..e48951f
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_pkg_info.c
@@ -0,0 +1,150 @@
+#include <platform_def.h>
+#include <ddr_pkg_info.h>
+#include <mmio.h>
+#include <bitwise_ops.h>
+#include <debug.h>
+
+uint8_t ddr_vendor;
+uint8_t ddr_capacity;
+uint8_t pkg;
+uint8_t ddr_type;
+
+void read_ddr_pkg_info(void)
+{
+	uint32_t conf_info = mmio_read_32(0x03000004);
+	uint32_t efuse_leakage = mmio_read_32(0x03050108);
+	uint32_t pkg_type;
+	uint32_t chip_id;
+
+#if defined(DBG_SHMOO) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+	NOTICE("conf_info(0x03000004)=0x%08x\n", conf_info);
+	NOTICE("efuse_leakage(0x03050108)=0x%08x\n", efuse_leakage);
+	NOTICE("FTSN3=0x%08x\n", mmio_read_32(0x0305010C));
+	NOTICE("FTSN4=0x%08x\n", mmio_read_32(0x03050110));
+#endif // DBG_SHMOO || DBG_SHMOO_CA || DBG_SHMOO_CS
+
+	pkg_type = FIELD_GET(conf_info, 30, 28);
+	NOTICE("pkg_type=%x\n", pkg_type);
+
+	switch (pkg_type) {
+	case 0x0: //BGA 10x10, SIP 2Gb DDR3
+		ddr_vendor = DDR_VENDOR_NY_2G;
+		ddr_capacity = DDR_CAPACITY_2G;
+		pkg = PKG_BGA;
+		break;
+	case 0x1: //BGA 10x10, SIP 4Gb DDR3
+		ddr_vendor = DDR_VENDOR_NY_4G;
+		ddr_capacity = DDR_CAPACITY_4G;
+		pkg = PKG_BGA;
+		break;
+	case 0x2: //BGA 10x10, SIP 1Gb DDR3
+		ddr_vendor = DDR_VENDOR_ESMT_1G;
+		ddr_capacity = DDR_CAPACITY_1G;
+		pkg = PKG_BGA;
+		break;
+	case 0x4: //2nd src need to read from efuse
+		NOTICE("2nd\n");
+		ddr_vendor = FIELD_GET(efuse_leakage, 25, 21);
+		ddr_capacity = FIELD_GET(efuse_leakage, 28, 26);
+		pkg = FIELD_GET(efuse_leakage, 31, 29);
+		break;
+	case 0x5: //QFN9x9, SIP 2Gb DDR3
+		ddr_vendor = DDR_VENDOR_NY_2G;
+		ddr_capacity = DDR_CAPACITY_2G;
+		pkg = PKG_QFN;
+		break;
+	case 0x6: //QFN9x9, SIP 1Gb DDR3
+		ddr_vendor = DDR_VENDOR_ESMT_1G;
+		ddr_capacity = DDR_CAPACITY_1G;
+		pkg = PKG_QFN;
+		break;
+	case 0x7: //QFN9x9, SIP 512Mb DDR2
+		ddr_vendor = DDR_VENDOR_ESMT_512M_DDR2;
+		ddr_capacity = DDR_CAPACITY_512M;
+		pkg = PKG_QFN;
+		break;
+	default:
+		NOTICE("unknown pkg_type=0x%x\n", pkg_type);
+	}
+
+	NOTICE("D%x_%x_%x\n", pkg, ddr_capacity, ddr_vendor);
+
+	// assign ddr_type
+	switch (ddr_vendor) {
+	case DDR_VENDOR_ESMT_512M_DDR2:
+	case DDR_VENDOR_ETRON_512M_DDR2:
+		NOTICE("DDR2");
+		ddr_type = DDR_TYPE_DDR2;
+		ddr_data_rate = 1333;
+		break;
+	case DDR_VENDOR_NY_4G:
+	case DDR_VENDOR_NY_2G:
+	case DDR_VENDOR_ESMT_1G:
+	case DDR_VENDOR_ETRON_1G:
+	case DDR_VENDOR_ESMT_2G:
+	case DDR_VENDOR_PM_2G:
+	case DDR_VENDOR_PM_1G:
+	case DDR_VENDOR_ESMT_N25_1G:
+		NOTICE("DDR3");
+		ddr_type = DDR_TYPE_DDR3;
+		ddr_data_rate = 1866;
+		break;
+	default:
+		NOTICE("unknown vendor=%d", ddr_vendor);
+		ddr_type = DDR_TYPE_UNKNOWN;
+	}
+
+	switch (ddr_capacity) {
+	case DDR_CAPACITY_512M:
+		NOTICE("-512M");
+		chip_id = (pkg == PKG_QFN ? 0x1810c : 0x1810f);
+		break;
+	case DDR_CAPACITY_1G:
+		NOTICE("-1G");
+		chip_id = (pkg == PKG_QFN ? 0x1811c : 0x1811f);
+		break;
+	case DDR_CAPACITY_2G:
+		NOTICE("-2G");
+		chip_id = (pkg == PKG_QFN ? 0x1812c : 0x1812f);
+		break;
+	case DDR_CAPACITY_4G:
+		NOTICE("-4G");
+		chip_id = 0x1813f;
+		break;
+	default:
+		NOTICE("-unknown capacity=%d", ddr_capacity);
+		chip_id = 0x0;
+	}
+	mmio_write_32(REG_GP_REG3, chip_id);
+
+	switch (pkg) {
+	case PKG_QFN:
+		NOTICE("-QFN\n");
+		break;
+	case PKG_BGA:
+		NOTICE("-BGA\n");
+		break;
+	default:
+		NOTICE("-unknown pkg=%d", pkg);
+	}
+}
+
+uint8_t get_ddr_vendor(void)
+{
+	return ddr_vendor;
+}
+
+uint8_t get_ddr_capacity(void)
+{
+	return ddr_capacity;
+}
+
+uint8_t get_pkg(void)
+{
+	return pkg;
+}
+
+uint8_t get_ddr_type(void)
+{
+	return ddr_type;
+}
diff --git a/firmware/plat/cv181x/ddr/ddr_sys.c b/firmware/plat/cv181x/ddr/ddr_sys.c
new file mode 100644
index 0000000..54cb5e2
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_sys.c
@@ -0,0 +1,10731 @@
+#include <mmio.h>
+#include <reg_soc.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+#include <bitwise_ops.h>
+#include <delay_timer.h>
+#include <cvx16_dram_cap_check.h>
+#include <cvx16_pinmux.h>
+#include <ddr_pkg_info.h>
+
+#define opdelay(_x) udelay((_x)/1000)
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
+// #pragma GCC diagnostic ignored "-Wunused-variable"
+
+uint32_t rddata;
+
+/*
+ * unused
+void check_rd32(uintptr_t addr, uint32_t expected)
+{
+	// uint32_t rdata;
+	// rdata = mmio_rd32(addr);
+	// if (rdata != expected)
+	//	mmio_wr32(TERM_SIM_ADDR, 0x0B0B0B0B); // fail
+}
+*/
+
+void ddr_debug_num_write(void)
+{
+	// debug_seqnum = debug_seqnum+1 ;
+	// mmio_wr32(4*(186 + PHY_BASE_ADDR)+CADENCE_PHYD,(debug_seqnum<<8));
+	// if(debug_seqnum ==255){ ;
+	// debug_seqnum1 = debug_seqnum1+1 ;
+	// mmio_wr32(4*(186 + PHY_BASE_ADDR)+CADENCE_PHYD,(debug_seqnum1<<8));
+	// debug_seqnum = 0 ;
+	// } ;
+}
+
+void cvx16_rdvld_train(void)
+{
+	uint32_t byte0_vld;
+	uint32_t byte1_vld;
+	uint32_t rdvld_offset;
+	uint32_t bist_result;
+	uint64_t err_data_odd;
+	uint64_t err_data_even;
+
+	cvx16_bist_wr_prbs_init();
+	// cvx16_bist_wr_sram_init();
+
+	byte0_vld = mmio_rd32(0x0B14 + PHYD_BASE_ADDR);
+	byte1_vld = mmio_rd32(0x0B44 + PHYD_BASE_ADDR);
+	rdvld_offset = mmio_rd32(0x0094 + PHYD_BASE_ADDR);
+	rdvld_offset = get_bits_from_value(rdvld_offset, 3, 0);
+
+	for (int i = 9; i > 1; i--) {
+		byte0_vld = modified_bits_by_value(byte0_vld, i, 20, 16);
+		mmio_wr32(0x0B14 + PHYD_BASE_ADDR, byte0_vld);
+		byte1_vld = modified_bits_by_value(byte1_vld, i, 20, 16);
+		mmio_wr32(0x0B44 + PHYD_BASE_ADDR, byte0_vld);
+		cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+
+		// KC_MSG(", bist_result = %x, err_data_odd = %x, err_data_even = %x\n",
+		//         bist_result,err_data_odd,err_data_even);
+		if (bist_result == 0) {
+			KC_MSG("vld end = %x, sel = %x", i, i + 1 + rdvld_offset);
+			i = i + 1 + rdvld_offset;
+			byte0_vld = modified_bits_by_value(byte0_vld, i, 20, 16);
+			mmio_wr32(0x0B14 + PHYD_BASE_ADDR, byte0_vld);
+			byte1_vld = modified_bits_by_value(byte1_vld, i, 20, 16);
+			mmio_wr32(0x0B44 + PHYD_BASE_ADDR, byte0_vld);
+			break;
+		}
+	}
+}
+
+void ddr_sys_suspend(void)
+{
+	uartlog("cvx16_ddr_sub_suspend\n");
+	// ddr_debug_wr32(0x3c);
+	// ddr_debug_num_write();
+	TJ_MSG("DDRC suspend start\n");
+
+	cvx16_ddrc_suspend();
+	TJ_MSG("DDRC suspend complete\n");
+
+	// save phyd setting to sram
+	cvx16_ddr_phyd_save(0x05026800);
+	// cvx16_ddr_phya_pd
+	cvx16_ddr_phya_pd();
+	// virtual_pwr_off();
+}
+
+void ddr_sys_resume(void)
+{
+	uint8_t dram_cap_in_mbyte;
+	// ddr_sub_resume1
+	// cvx16_ddr_sub_resume1();
+	// KC_MSG("ddr_sub_resume1\n");
+
+	// pll_init
+	cvx16_pll_init();
+	KC_MSG("pll_init_h finish\n");
+
+	// ctrl_init
+	ddrc_init();
+	KC_MSG("2nd ctrl_init_h finish\n");
+
+	// ddr_sub_resume2
+	cvx16_ddr_sub_resume2();
+	KC_MSG("ddr_sub_resume2\n");
+
+	// pinmux
+	//     cvx16_pinmux();
+	//     KC_MSG("cvx16_pinmux finish\n");
+
+	// ddr_sub_resume3
+	cvx16_ddr_sub_resume3();
+	KC_MSG("ddr_sub_resume3\n");
+
+	// ctrl_init_h.ctrl_high_patch=1;
+	//`uvm_send(ctrl_init_h);
+	ctrl_init_high_patch();
+
+	//    ctrl_init_detect_dram_size(&dram_cap_in_mbyte);
+	//    KC_MSG("ctrl_init_detect_dram_size finish\n");
+
+	// restory dram_cap_in_mbyte
+	rddata = mmio_rd32(0x0208 + PHYD_BASE_ADDR);
+	dram_cap_in_mbyte = rddata;
+
+	ctrl_init_update_by_dram_size(dram_cap_in_mbyte);
+	KC_MSG("ctrl_init_update_by_dram_size finish\n");
+
+	KC_MSG("dram_cap_in_mbyte = %x\n", dram_cap_in_mbyte);
+	cvx16_dram_cap_check(dram_cap_in_mbyte);
+	KC_MSG("cvx16_dram_cap_check finish\n");
+
+	// Write PCTRL.port_en = 1
+	for (int i = 0; i < 4; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+
+	//    ctrl_init_h.ctrl_high_patch=1;
+	//    `uvm_send(ctrl_init_h);
+
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_ddr_sub_resume2(void)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x44);
+	// ddr_debug_num_write();
+	//  Program INIT0.skip_dram_init = 0b11
+	rddata = mmio_rd32(cfg_base + 0xd0);
+	rddata = modified_bits_by_value(rddata, 0x3, 31, 30);
+	// rddata[31:30] = 0x3;
+	mmio_wr32(cfg_base + 0xd0, rddata);
+	// Program PWRCTL.selfref_sw = 0b1
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0x1, 5, 5);
+	// rddata[5:5] = 0x1;
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Program DFIMISC.dfi_init_complete_en to 1b0
+	rddata = mmio_rd32(cfg_base + 0x1b0);
+	rddata = modified_bits_by_value(rddata, 0x0, 0, 0);
+	// rddata[0:0] = 0x0;
+	mmio_wr32(cfg_base + 0x1b0, rddata);
+	// Remove the controller reset core_ddrc_rstn = 1b1 aresetn_n = 1b1
+	rddata = mmio_rd32(0x0800a020);
+	rddata = modified_bits_by_value(rddata, 0x0, 0, 0);
+	// rddata[0] = 0;
+	mmio_wr32(0x0800a020, rddata);
+}
+
+void cvx16_ddr_sub_resume3(void)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x45);
+	// ddr_debug_num_write();
+	// ddr_phyd_restore
+	cvx16_ddr_phyd_restore(0x05026800);
+	// setting_check
+	cvx16_setting_check();
+	KC_MSG("cvx16_setting_check  finish\n");
+
+	// ddr_phy_power_on_seq1
+	cvx16_ddr_phy_power_on_seq1();
+	// ddr_phy_power_on_seq2
+	cvx16_ddr_phy_power_on_seq2();
+	// set_dfi_init_start
+	cvx16_set_dfi_init_start();
+	// set_dfi_init_complete
+	cvx16_set_dfi_init_complete();
+	// synp setting
+	// deassert dfi_init_start, and enable the act on dfi_init_complete
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001b0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	// rddata[5] = 0b0;
+	mmio_wr32(cfg_base + 0x000001b0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	KC_MSG("dfi_init_complete finish\n");
+
+	// ddr_phy_power_on_seq3
+	cvx16_ddr_phy_power_on_seq3();
+	// Program SWCTL.sw_done = 0b0
+	rddata = mmio_rd32(cfg_base + 0x320);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	// rddata[0:0] = 0x0;
+	mmio_wr32(cfg_base + 0x320, rddata);
+	// Program DFIMISC.dfi_init_complete_en to 1b1
+	rddata = mmio_rd32(cfg_base + 0x1b0);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	// rddata[0:0] = 0x1;
+	mmio_wr32(cfg_base + 0x1b0, rddata);
+	// Program SWCTL.sw_done = 0b1
+	rddata = mmio_rd32(cfg_base + 0x320);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	// rddata[0:0] = 0x1;
+	mmio_wr32(cfg_base + 0x320, rddata);
+	// Program PWRCTL.selfref_sw = 1b0
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	// rddata[5:5] = 0x0;
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Poll STAT.selfref_type = 2b00
+	// do {
+	//    rddata = mmio_rd32(cfg_base + 0x4);
+	//} while (get_bits_from_value(rddata, 5, 4) != 0x0);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		if (get_bits_from_value(rddata, 5, 4) == 0x0) {
+			break;
+		}
+	}
+	// Poll STAT.operating_mode for Normal Mode entry
+	cvx16_polling_synp_normal_mode();
+}
+
+void cvx16_ddrc_suspend(void)
+{
+	uartlog("%s\n", __func__);
+	// ddr_debug_wr32(0x40);
+	// ddr_debug_num_write();
+	//  Write 0 to PCTRL_n.port_en
+	for (int i = 0; i < 4; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	// do {
+	//    rddata = mmio_rd32(cfg_base+0x3fc);
+	//} while (rddata != 0);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// Write 1 to PWRCTL.selfref_sw
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x1;
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	mmio_wr32(cfg_base + 0x30, rddata);
+// Poll STAT.selfref_type= 2b10
+// Poll STAT.selfref_state = 0b10 (LPDDR4 only)
+#ifndef LP4
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		if (get_bits_from_value(rddata, 5, 4) == 0x2) {
+			break;
+		}
+	}
+#else
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		if (get_bits_from_value(rddata, 9, 8) == 0x2) {
+			break;
+		}
+	}
+#endif
+}
+
+void cvx16_bist_wr_prbs_init(void)
+{
+	// reg [31:0] cmd[5:0];
+	// reg [31:0] sram_st;
+	// reg [31:0] sram_sp;
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x23);
+	ddr_debug_num_write();
+	KC_MSG("bist_wr_prbs_init\n");
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	sram_sp = 511;
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // W  1~17  prbs  repeat0
+	cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // R  1~17  prbs  repeat0
+	cmd[2] = 0; // NOP
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("bist_wr_prbs_init done\n");
+	KC_MSG("bist_wr_prbs_init done\n");
+}
+
+void cvx16_bist_wr_sram_init(void)
+{
+	const int byte_per_page = 256;
+	int axi_per_page = byte_per_page / 64;
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x23);
+	ddr_debug_num_write();
+	KC_MSG("bist_wr_sram_init\n");
+
+	// bist clock enable, axi_len 8
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x000C000C);
+	sram_st = 0;
+	fmax = 15;
+	fmin = 5;
+	sram_st = 0;
+	sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+	KC_MSG("sram_sp = %x\n", sram_sp);
+
+	// bist sso_period
+	mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (15 << 0); // W  1~17  sram  repeat0
+	cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (15 << 0); // R  1~17  sram  repeat0
+	//       NOP idle
+	cmd[2] = 0; // NOP
+	//       GOTO      addr_not_reset loop_cnt
+	cmd[3] = (3 << 30) | (0 << 20) | (1 << 0); // GOTO
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step to 2KB
+	mmio_wr32(DDR_BIST_BASE + 0x18, 2048 / axi_per_page / 16);
+#else
+	// TBD
+#endif
+	uartlog("bist_wr_sram_init done\n");
+	KC_MSG("bist_wr_sram_init done\n");
+}
+
+void cvx16_bist_wrlvl_init(void)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x23);
+	ddr_debug_num_write();
+	KC_MSG_TR("%s\n", __func__);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	// sram_sp = 511;
+	sram_sp = 0;
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // W  1~17  prbs  repeat0
+	// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+	//          (0 << 0); // R  1~17  prbs  repeat0
+	cmd[1] = 0; // NOP
+	cmd[2] = 0; // NOP
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("bist_wr_prbs_init done\n");
+	KC_MSG_TR("bist_wr_prbs_init done\n");
+}
+
+void cvx16_bist_rdglvl_init(void)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x231);
+	ddr_debug_num_write();
+	KC_MSG("%s\n", __func__);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	// sram_sp = 511;
+	sram_sp = 3;
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	// cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+	//          (0 << 0);  // W  1~17  prbs  repeat0
+	cmd[0] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // R  1~17  prbs  repeat0
+	// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+	//          (0 << 0);  // R  1~17  prbs  repeat0
+	cmd[1] = 0; // NOP
+	cmd[2] = 0; // NOP
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s done\n", __func__);
+	KC_MSG("%s done\n", __func__);
+}
+
+void cvx16_bist_rdlvl_init(uint32_t mode)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	// uint32_t sram_dq[1024];
+	int i;
+
+	// mode = 0x0  : MPR mode, DDR3 only.
+	// mode = 0x1  : sram write/read continuous goto
+	// mode = 0x2  : multi- bist write/read
+	// mode = 0x12 : with Error enject,  multi- bist write/read
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x232);
+	ddr_debug_num_write();
+	KC_MSG("%s mode = %x\n", __func__, mode);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	if (mode == 0x0) { // MPR mode
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		// cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // W  1~17  prbs  repeat0
+		cmd[0] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // R  1~17  prbs  repeat0
+		cmd[1] = 0; // NOP
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x1) { // sram write/read continuous goto
+		fmax = 15;
+		fmin = 5;
+		sram_st = 0;
+		sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+		KC_MSG("sram_sp = %x\n", sram_sp);
+
+		// bist sso_period
+		mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  sram  repeat0
+		cmd[3] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  sram  repeat0
+		//       GOTO      addr_not_reset loop_cnt
+		cmd[4] = (3 << 30) | (0 << 20) | (1 << 0); // GOTO
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x2) { // multi- bist write/read
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 7;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x12) { // with Error enject,  multi- bist write/read
+		//----for Error enject simulation only
+		rddata = mmio_rd32(0x0084 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x1d, 4, 0); // param_phyd_pirdlvl_trig_lvl_start
+		rddata = modified_bits_by_value(rddata, 0x1f, 12, 8); // param_phyd_pirdlvl_trig_lvl_end
+		mmio_wr32(0x0084 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 7;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x10) { // with Error enject,  multi- bist write/read
+		//----for Error enject simulation only
+		rddata = mmio_rd32(0x0084 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 4, 0); // param_phyd_pirdlvl_trig_lvl_start
+		rddata = modified_bits_by_value(rddata, 3, 12, 8); // param_phyd_pirdlvl_trig_lvl_end
+		mmio_wr32(0x0084 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		// cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // W  1~17  prbs  repeat0
+		cmd[0] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		// cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		//          (0 << 0);  // R  1~17  prbs  repeat0
+		cmd[1] = 0; //NOP
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	}
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s\n", __func__);
+	KC_MSG("%s\n", __func__);
+}
+
+void cvx16_bist_wdqlvl_init(uint32_t mode)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	// uint32_t wdqlvl_vref_start; //unused
+	// uint32_t wdqlvl_vref_end; //unused
+	// uint32_t wdqlvl_vref_step; //unused
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x233);
+	ddr_debug_num_write();
+	KC_MSG("%s mode = %x\n", __func__, mode);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	if (mode == 0x0) { // phyd pattern
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x1) { // bist write/read
+		sram_st = 0;
+		fmax = 15;
+		fmin = 5;
+		sram_st = 0;
+		sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+		KC_MSG("sram_sp = %x\n", sram_sp);
+
+		// bist sso_period
+		mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (511 << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // W  1~17  sram  repeat0
+		cmd[3] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (6 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (2 << 0); // R  1~17  sram  repeat0
+		//       GOTO      addr_not_reset loop_cnt
+		cmd[4] = (3 << 30) | (0 << 20) | (1 << 0); // GOTO
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x11) { // bist write/read
+		//----for Error enject simulation only
+		rddata = 0x00000000;
+		rddata = modified_bits_by_value(rddata, 0x1, 6, 0); // param_phyd_dfi_wdqlvl_vref_start
+		rddata = modified_bits_by_value(rddata, 0x3, 14, 8); // param_phyd_dfi_wdqlvl_vref_end
+		rddata = modified_bits_by_value(rddata, 0x1, 19, 16); // param_phyd_dfi_wdqlvl_vref_step
+		mmio_wr32(0x0190 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else if (mode == 0x12) { // bist write/read
+		//----for Error enject simulation only
+		rddata = 0x00000000;
+		rddata = modified_bits_by_value(rddata, 0x1d, 6, 0); // param_phyd_dfi_wdqlvl_vref_start
+		rddata = modified_bits_by_value(rddata, 0x1f, 14, 8); // param_phyd_dfi_wdqlvl_vref_end
+		rddata = modified_bits_by_value(rddata, 0x1, 19, 16); // param_phyd_dfi_wdqlvl_vref_step
+		mmio_wr32(0x0190 + PHYD_BASE_ADDR, rddata);
+		//----for Error enject simulation only
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	} else {
+		sram_st = 0;
+		// sram_sp = 511;
+		sram_sp = 3;
+		// cmd queue
+		//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+		//        repeat
+		cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // W  1~17  prbs  repeat0
+		cmd[1] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (5 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+			 (0 << 0); // R  1~17  prbs  repeat0
+		cmd[2] = 0; // NOP
+		cmd[3] = 0; // NOP
+		cmd[4] = 0; // NOP
+		cmd[5] = 0; // NOP
+	}
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s done\n", __func__);
+	KC_MSG("%s done\n", __func__);
+}
+
+void cvx16_bist_wdmlvl_init(void)
+{
+	uint32_t cmd[6];
+	uint32_t sram_st;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+	int i;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x233);
+	ddr_debug_num_write();
+	KC_MSG("%s\n", __func__);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	sram_st = 0;
+	fmax = 15;
+	fmin = 5;
+	sram_st = 0;
+	sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+	KC_MSG("sram_sp = %x\n", sram_sp);
+
+	// bist sso_period
+	mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+	// cmd queue
+	//        op_code         start              stop        pattern    dq_inv     dm_inv    dq_rotate
+	//        repeat
+	cmd[0] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (3 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // bist write pat 3 = 0x0f
+	cmd[1] = (1 << 30) | (sram_st << 21) | (sram_sp << 12) | (7 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // bist write pat 7 = sso_8x1 DM toggle verison
+	cmd[2] = (2 << 30) | (sram_st << 21) | (sram_sp << 12) | (7 << 9) | (0 << 8) | (0 << 7) | (0 << 4) |
+		 (0 << 0); // bist read pat 7
+	cmd[3] = 0; // NOP
+	cmd[4] = 0; // NOP
+	cmd[5] = 0; // NOP
+	// write cmd queue
+	for (i = 0; i < 6; i = i + 1) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	};
+	// specified DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x000fffff);
+#ifdef X16_MODE
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+#else
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+#endif
+	uartlog("%s done\n", __func__);
+	KC_MSG("%s done\n", __func__);
+}
+
+void cvx16_bist_start_check(uint32_t *bist_result, uint64_t *err_data_odd, uint64_t *err_data_even)
+{
+	uint64_t err_data_even_l;
+	uint64_t err_data_even_h;
+	uint64_t err_data_odd_l;
+	uint64_t err_data_odd_h;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x25);
+	ddr_debug_num_write();
+#ifdef X16_MODE
+	// bist enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00030003);
+	uartlog("bist start\n");
+	KC_MSG("bist start\n");
+
+#else
+	// bist enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+	uartlog("bist start\n");
+	KC_MSG("bist start\n");
+
+#endif
+	// polling bist done
+	//    while (get_bits_from_value(2)  == 0x0 = mmio_rd32(DDR_BIST_BASE + 0x80),2);
+	while (1) {
+		rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		if (get_bits_from_value(rddata, 2, 2) == 1) {
+			break;
+		}
+	}
+	uartlog("bist done\n");
+	KC_MSG("Read bist done %x ...\n", rddata);
+
+	if (get_bits_from_value(rddata, 3, 3) == 1) {
+		// opdelay(10);
+		*bist_result = 0;
+		uartlog("bist fail\n");
+		uartlog("err data\n");
+		// read err_data
+		err_data_odd_l = mmio_rd32(DDR_BIST_BASE + 0x88);
+		err_data_odd_h = mmio_rd32(DDR_BIST_BASE + 0x8c);
+		err_data_even_l = mmio_rd32(DDR_BIST_BASE + 0x90);
+		err_data_even_h = mmio_rd32(DDR_BIST_BASE + 0x94);
+		*err_data_odd = err_data_odd_h << 32 | err_data_odd_l;
+		*err_data_even = err_data_even_h << 32 | err_data_even_l;
+	} else {
+		// opdelay(10);
+		*bist_result = 1;
+		uartlog("bist pass\n");
+		*err_data_odd = 0;
+		*err_data_even = 0;
+	}
+	// bist disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00050000);
+}
+
+void cvx16_bist_tx_shift_delay(uint32_t shift_delay)
+{
+	uint32_t shift_tmp;
+	uint32_t delay_tmp;
+	// uint32_t oenz_shift_tmp; //unused
+	uint32_t oenz_lead;
+	uint32_t tdfi_phy_wrdata;
+	// uint32_t dlie_sum_great; //unused
+	uint32_t dlie_sub;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x26);
+	ddr_debug_num_write();
+	shift_tmp = get_bits_from_value(shift_delay, 13, 8);
+	delay_tmp = get_bits_from_value(shift_delay, 6, 0);
+	// tdfi_phy_wrdata
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	tdfi_phy_wrdata = get_bits_from_value(rddata, 2, 0);
+	oenz_lead = get_bits_from_value(rddata, 6, 3);
+	KC_MSG("shift_delay = %x, oenz_lead = %x, tdfi_phy_wrdata = %x\n", shift_delay, oenz_lead,
+	       tdfi_phy_wrdata);
+
+	if ((shift_tmp + (tdfi_phy_wrdata << 1)) > oenz_lead) {
+		dlie_sub = shift_tmp + (tdfi_phy_wrdata << 1) - oenz_lead;
+	} else {
+		dlie_sub = 0;
+	}
+	KC_MSG("dlie_sub = %x\n", dlie_sub);
+
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = (shift_tmp << 24) + (delay_tmp << 16) + (shift_tmp << 8) + delay_tmp;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(0x0A18 + i * 0x40 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, dlie_sub, 29, 24);
+		mmio_wr32(0x0A18 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_bist_rx_delay(uint32_t delay)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x27);
+	ddr_debug_num_write();
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, delay, 15, 8);
+		rddata = modified_bits_by_value(rddata, delay, 23, 16);
+		mmio_wr32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_bist_rx_deskew_delay(uint32_t delay)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x28);
+	ddr_debug_num_write();
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = (delay << 24) + (delay << 16) + (delay << 8) + delay;
+		mmio_wr32(0x0B00 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B04 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, delay, 6, 0);
+		mmio_wr32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_ca_shift_delay(uint32_t shift_delay)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x57);
+	ddr_debug_num_write();
+	rddata = (shift_delay << 16) + shift_delay;
+	mmio_wr32(0x0900 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0904  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0908  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x090C  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0910  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0914  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0918  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x091C  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0920  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0924  + PHYD_BASE_ADDR,  rddata);
+	// mmio_wr32(0x0928  + PHYD_BASE_ADDR,  rddata);
+	mmio_wr32(0x092C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0930  + PHYD_BASE_ADDR,  rddata);//CKE
+	// mmio_wr32(0x0934  + PHYD_BASE_ADDR,  rddata);//cs
+	// mmio_wr32(0x0938  + PHYD_BASE_ADDR,  rddata);//reset_n
+	cvx16_dll_sw_clr();
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_cs_shift_delay(uint32_t shift_delay)
+{
+	uartlog("cvx16_cs_shift_delay\n");
+	ddr_debug_wr32(0x57);
+	ddr_debug_num_write();
+	rddata = (shift_delay << 16) + shift_delay;
+	// mmio_wr32(0x0900 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0904 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0908 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x090C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0910 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0914 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0918 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x091C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0920 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0924 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0928 + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x092C + PHYD_BASE_ADDR, rddata);
+	// mmio_wr32(0x0930 + PHYD_BASE_ADDR, rddata); //cke
+	mmio_wr32(0x0934 + PHYD_BASE_ADDR, rddata); //cs
+	// mmio_wr32(0x0938 + PHYD_BASE_ADDR, rddata); //reset_n
+	cvx16_dll_sw_clr();
+	KC_MSG("cvx16_cs_shift_delay Fisish\n");
+}
+
+void cvx16_synp_mrw(uint32_t addr, uint32_t data)
+{
+	uint32_t init_dis_auto_zq;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x21);
+	ddr_debug_num_write();
+	// ZQCTL0.dis_auto_zq to 1.
+	rddata = mmio_rd32(cfg_base + 0x180);
+	// if (rddata[31] == 0b0) {
+	if (get_bits_from_value(rddata, 31, 31) == 0) {
+		init_dis_auto_zq = 0;
+		// rddata[31] = 1;
+		rddata = modified_bits_by_value(rddata, 1, 31, 31);
+		mmio_wr32(cfg_base + 0x180, rddata);
+		uartlog("non-lp4 Write ZQCTL0.dis_auto_zq to 1\n");
+		// opdelay(256);
+		uartlog("Wait tzqcs = 128 cycles\n");
+	} else {
+		init_dis_auto_zq = 1;
+	}
+	// Poll MRSTAT.mr_wr_busy until it is 0
+	uartlog("Poll MRSTAT.mr_wr_busy until it is 0\n");
+	rddata = 0;
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x18);
+		if (get_bits_from_value(rddata, 0, 0) == 0) {
+			break;
+		}
+	}
+	uartlog("non-lp4 Poll MRSTAT.mr_wr_busy finish\n");
+	// Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs) MRCTRL1.mr_data
+	// rddata[31:0]  = 0;
+	// rddata[0]     = 0;       // mr_type  0:write   1:read
+	// rddata[5:4]   = 1;       // mr_rank
+	// rddata[15:12] = addr;    // mr_addr
+	rddata = modified_bits_by_value(rddata, 0, 31, 0);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 5, 4);
+	rddata = modified_bits_by_value(rddata, addr, 15, 12);
+	mmio_wr32(cfg_base + 0x10, rddata);
+	uartlog("non-lp4 Write the MRCTRL0\n");
+	// rddata[31:0] = 0;
+	// rddata[15:0] = data;     // mr_data
+	rddata = modified_bits_by_value(rddata, 0, 31, 0);
+	rddata = modified_bits_by_value(rddata, data, 31, 0);
+	mmio_wr32(cfg_base + 0x14, rddata);
+	uartlog("non-lp4 Write the MRCTRL1\n");
+	// Write MRCTRL0.mr_wr to 1
+	rddata = mmio_rd32(cfg_base + 0x10);
+	// rddata[31] = 1;
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x10, rddata);
+	uartlog("non-lp4 Write MRCTRL0.mr_wr to 1\n");
+	if (init_dis_auto_zq == 0) {
+		// ZQCTL0.dis_auto_zq to 0.
+		rddata = mmio_rd32(cfg_base + 0x180);
+		// rddata[31] = 0;
+		rddata = modified_bits_by_value(rddata, 0, 31, 31);
+		mmio_wr32(cfg_base + 0x180, rddata);
+		uartlog("non-lp4 Write ZQCTL0.dis_auto_zq to 0\n");
+	}
+}
+
+void cvx16_chg_pll_freq(void)
+{
+	uint32_t EN_PLL_SPEED_CHG;
+	uint32_t CUR_PLL_SPEED;
+	uint32_t NEXT_PLL_SPEED;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x04);
+	ddr_debug_num_write();
+	// Change PLL frequency
+	// TOP_REG_RESETZ_DIV =0
+	rddata = 0x00000000;
+	mmio_wr32(0x04 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_RESETZ_DQS =0
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_DDRPLL_MAS_RSTZ_DIV  =0
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 7, 7);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	uartlog("RSTZ_DIV=0\n");
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	EN_PLL_SPEED_CHG = get_bits_from_value(rddata, 0, 0);
+	CUR_PLL_SPEED = get_bits_from_value(rddata, 5, 4);
+	NEXT_PLL_SPEED = get_bits_from_value(rddata, 9, 8);
+	KC_MSG("CUR_PLL_SPEED = %x, NEXT_PLL_SPEED = %x, EN_PLL_SPEED_CHG=%x\n", CUR_PLL_SPEED, NEXT_PLL_SPEED,
+	       EN_PLL_SPEED_CHG);
+
+	if (EN_PLL_SPEED_CHG) {
+		if (NEXT_PLL_SPEED == 0) { // next clk_div40
+			rddata = modified_bits_by_value(rddata, NEXT_PLL_SPEED, 5, 4);
+			rddata = modified_bits_by_value(rddata, CUR_PLL_SPEED, 9, 8);
+			mmio_wr32(0x4c + CV_DDR_PHYD_APB, rddata);
+			cvx16_clk_div40();
+			uartlog("clk_div40\n");
+			KC_MSG("clk_div40\n");
+		} else {
+			if (NEXT_PLL_SPEED == 0x2) { // next clk normal
+				rddata = modified_bits_by_value(rddata, NEXT_PLL_SPEED, 5, 4);
+				rddata = modified_bits_by_value(rddata, CUR_PLL_SPEED, 9, 8);
+				mmio_wr32(0x4c + CV_DDR_PHYD_APB, rddata);
+				cvx16_clk_normal();
+				uartlog("clk_normal\n");
+				KC_MSG("clk_normal\n");
+			} else {
+				if (NEXT_PLL_SPEED == 0x1) { // next clk normal div_2
+					rddata = modified_bits_by_value(rddata, NEXT_PLL_SPEED, 5, 4);
+					rddata = modified_bits_by_value(rddata, CUR_PLL_SPEED, 9, 8);
+					mmio_wr32(0x4c + CV_DDR_PHYD_APB, rddata);
+					cvx16_clk_div2();
+					uartlog("clk_div2\n");
+					KC_MSG("clk_div2\n");
+				}
+			}
+		}
+		//         opdelay(100000);  //  1000ns
+	}
+	// TOP_REG_RESETZ_DIV  =1
+	rddata = 0x00000001;
+	mmio_wr32(0x04 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	// rddata[7]   = 1;    //TOP_REG_DDRPLL_MAS_RSTZ_DIV
+	rddata = modified_bits_by_value(rddata, 1, 7, 7);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	uartlog("RSTZ_DIV=1\n");
+	// rddata[0]   = 1;    //TOP_REG_RESETZ_DQS
+	rddata = 0x00000001;
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, rddata);
+	uartlog("TOP_REG_RESETZ_DQS\n");
+	KC_MSG("Wait for DRRPLL_SLV_LOCK=1...\n");
+
+#ifdef REAL_LOCK
+	rddata = modified_bits_by_value(rddata, 0, 15, 15);
+	while (get_bits_from_value(rddata, 15, 15) == 0) {
+		rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+		KC_MSG("REAL_LOCK.\n");
+
+		opdelay(200);
+	}
+#else
+	KC_MSG("check PLL lock...  pll init\n");
+
+#endif
+	//} Change PLL frequency
+}
+
+void cvx16_dll_cal(void)
+{
+	uint32_t EN_PLL_SPEED_CHG;
+	uint32_t CUR_PLL_SPEED;
+	uint32_t NEXT_PLL_SPEED;
+
+	KC_MSG("Do DLLCAL ...\n");
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2b);
+	ddr_debug_num_write();
+	// TOP_REG_EN_PLL_SPEED_CHG
+	//     <= #RD (~pwstrb_mask[0] & TOP_REG_EN_PLL_SPEED_CHG) |  pwstrb_mask_pwdata[0];
+	// TOP_REG_CUR_PLL_SPEED   [1:0]
+	//     <= #RD (~pwstrb_mask[5:4] & TOP_REG_CUR_PLL_SPEED[1:0]) |  pwstrb_mask_pwdata[5:4];
+	// TOP_REG_NEXT_PLL_SPEED  [1:0]
+	//     <= #RD (~pwstrb_mask[9:8] & TOP_REG_NEXT_PLL_SPEED[1:0]) |  pwstrb_mask_pwdata[9:8];
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	EN_PLL_SPEED_CHG = get_bits_from_value(rddata, 0, 0);
+	CUR_PLL_SPEED = get_bits_from_value(rddata, 5, 4);
+	NEXT_PLL_SPEED = get_bits_from_value(rddata, 9, 8);
+	KC_MSG("CUR_PLL_SPEED = %x, NEXT_PLL_SPEED = %x, EN_PLL_SPEED_CHG=%x\n", CUR_PLL_SPEED, NEXT_PLL_SPEED,
+	       EN_PLL_SPEED_CHG);
+
+	if (CUR_PLL_SPEED != 0) { // only do calibration and update when high speed
+		// param_phyd_dll_rx_start_cal <= int_regin[1];
+		// param_phyd_dll_tx_start_cal <= int_regin[17];
+		rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 17, 17);
+		mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+		// param_phyd_dll_rx_start_cal <= int_regin[1];
+		// param_phyd_dll_tx_start_cal <= int_regin[17];
+		rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 1, 1);
+		rddata = modified_bits_by_value(rddata, 1, 17, 17);
+		mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+		rddata = 0x00000000;
+		while (get_bits_from_value(rddata, 16, 16) == 0) {
+			rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		}
+		KC_MSG("DLL lock !\n");
+
+		uartlog("DLL lock\n");
+		// opdelay(1000);
+		uartlog("Do DLLUPD\n");
+		// cvx16_dll_cal_status();
+	} else { // stop calibration and update when low speed
+		// param_phyd_dll_rx_start_cal <= int_regin[1];
+		// param_phyd_dll_tx_start_cal <= int_regin[17];
+		rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 17, 17);
+		mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	}
+	KC_MSG("Do DLLCAL Finish\n");
+
+	uartlog("Do DLLCAL Finish\n");
+}
+
+void cvx16_dll_cal_phyd_hw(void)
+{
+	KC_MSG("Do DLLCAL phyd_hw ...\n");
+
+	uartlog("cvx16_dll_cal phyd_hw\n");
+	ddr_debug_wr32(0x2b);
+	ddr_debug_num_write();
+	KC_MSG("DLLCAL HW mode cntr_mode 0\n");
+
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0010, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0010, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("Do DLLCAL cntr_mode 0 Finish\n");
+
+	uartlog("Do DLLCAL cntr_mode 0 Finish\n");
+	// opdelay(1000);
+	KC_MSG("DLLCAL HW mode cntr_mode 1\n");
+
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0110, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0110, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("Do DLLCAL cntr_mode 1 Finish\n");
+
+	uartlog("Do DLLCAL cntr_mode 1 Finish\n");
+	// opdelay(1000);
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b1110, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b1110, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	uartlog("Do DLLCAL cntr_mode hwrst_time 1 Finish\n");
+}
+
+void cvx16_dll_cal_phya_enautok(void)
+{
+	KC_MSG("Do DLLCAL enautok ...\n");
+
+	uartlog("cvx16_dll_cal enautok\n");
+	ddr_debug_wr32(0x2b);
+	ddr_debug_num_write();
+	KC_MSG("DLLCAL enautok\n");
+
+	// param_phyd_dll_rx_sw_mode    [0]
+	// param_phyd_dll_rx_start_cal  [1]
+	// param_phyd_dll_rx_cntr_mode  [2]
+	// param_phyd_dll_rx_hwrst_time [3]
+	// param_phyd_dll_tx_sw_mode    [16]
+	// param_phyd_dll_tx_start_cal  [17]
+	// param_phyd_dll_tx_cntr_mode  [18]
+	// param_phyd_dll_tx_hwrst_time [19]
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0b0000, 3, 0);
+	rddata = modified_bits_by_value(rddata, 0b0000, 19, 16);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_ddrdll_enautok [0]
+	// param_phya_reg_tx_ddrdll_enautok [16]
+	rddata = mmio_rd32(0x0140 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 16, 16);
+	mmio_wr32(0x0140 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 16, 16) & get_bits_from_value(rddata, 0, 0)) != 0) {
+			break;
+		}
+	}
+	KC_MSG("DLL lock !\n");
+
+	uartlog("DLL lock\n");
+	// opdelay(1000);
+	uartlog("Do DLLUPD\n");
+	// cvx16_dll_cal_status();
+	// param_phyd_dll_rx_start_cal <= int_regin[1];
+	// param_phyd_dll_tx_start_cal <= int_regin[17];
+	rddata = mmio_rd32(0x0040 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 17, 17);
+	mmio_wr32(0x0040 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("Do DLLCAL enautok\n");
+
+	uartlog("Do DLLCAL enautok Finish\n");
+}
+
+void cvx16_ddr_zqcal_isr8(void)
+{
+	uint32_t KP40_GOLDEN;
+	uint32_t KN40_GOLDEN;
+	uint32_t dram_class;
+	// uint32_t wr_odt_en; //unused
+	// uint32_t rtt_wr; //unused
+	int i;
+	// VDDQ_TXr       = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// ZQ clock on
+	rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 12, 12); // TOP_REG_CG_EN_ZQ
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	// param_phyd_zqcal_hw_mode       <= `PI_SD int_regin[24];
+	// sw mode
+	// param_phyd_zqcal_hw_mode = 0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_zqcal_done  <= `PI_SD int_regin[3];
+	rddata = mmio_rd32(0x0158 + PHYD_BASE_ADDR);
+	KC_MSG("Check ZQ Calibration param_phya_reg_zqcal_done = %x\n", get_bits_from_value(rddata, 14, 14));
+
+	if (get_bits_from_value(rddata, 0, 0) == 0) { // initial ZQCAL
+		rddata = mmio_rd32(0x0050 + PHYD_BASE_ADDR);
+		// dram_class = rddata[11:8];  //DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		dram_class = get_bits_from_value(
+			rddata, 3, 0); // DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		KC_MSG("dram_class = %x...\n", dram_class);
+
+		KC_MSG("DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011\n");
+
+		//    ->ydh_zq_event;
+		// a.
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+		// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 5, 5);
+		mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// b.
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+		rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+		// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+		rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// c.
+		// param_phya_reg_vref_pd  <= `PI_SD int_regin[9];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[9] = 0;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		// param_phya_reg_vref_sel[4:0] <= `PI_SD int_regin[14:10];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[14:10] = 0b01111;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		//    ->ydh_zq_event;
+		// d.
+		// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 0);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_SEL_GPIO
+		//      <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+		// TOP_REG_TX_GPIO_OENZ
+		//      <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+		rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 7, 6);
+		mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+		//------------------------------
+		// CMP offset Cal.
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x3, 4, 0);
+		rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+		rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		for (i = 0; i < 32; i = i + 1) {
+			// opdelay(128);
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 24, 24)) { // param_phya_to_reg_zq_cmp_out
+				rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 12, 8) < 0x1f) { // param_phya_reg_tx_zq_cmp_offset
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 12, 8) + 1), 12, 8);
+					mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration overflow - param_phya_reg_tx_zq_cmp_offset[4:0]: %x\n",
+					       get_bits_from_value(rddata, 12, 8));
+				}
+			} else {
+				rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 12, 8) > 0) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 12, 8) - 1), 12, 8);
+					mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration underflow - param_phya_reg_tx_zq_cmp_offset[4:0]: %x\n",
+					       get_bits_from_value(rddata, 12, 8));
+				}
+			}
+		}
+		//------------------------------
+		// ZQ PL
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		////param_phya_reg_tx_zq_drvn
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		for (i = 0; i < 32; i = i + 1) {
+			//        repeat(128) @(posedge clk);
+			// opdelay(128);
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 24, 24)) { // param_phya_to_reg_zq_cmp_out
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 20, 16) < 0x1f) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 20, 16) + 1), 20, 16);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration overflow - param_phya_reg_tx_zq_drvn[4:0]: %x\n",
+					       get_bits_from_value(rddata, 20, 16));
+				}
+			} else {
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 20, 16) > 0) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 20, 16) - 1), 20, 16);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration underflow - param_phya_reg_tx_zq_drvn[4:0]: %x\n",
+					       get_bits_from_value(rddata, 20, 16));
+				}
+			}
+		}
+		KN40_GOLDEN = get_bits_from_value(rddata, 20, 16);
+		//------------------------------
+		// ZQ PH
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x11, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		////param_phya_reg_tx_zq_drvp
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		for (i = 0; i < 32; i = i + 1) {
+			// opdelay(128);
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 24, 24)) { // param_phya_to_reg_zq_cmp_out
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 28, 24) > 0) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 28, 24) - 1), 28, 24);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+					KC_MSG("ZQ Calibration underflow - param_phya_reg_tx_zq_drvp[4:0]: %x\n",
+					       get_bits_from_value(rddata, 28, 24));
+				}
+			} else {
+				rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 28, 24) < 0x1f) {
+					rddata = modified_bits_by_value(
+						rddata, (get_bits_from_value(rddata, 28, 24) + 1), 28, 24);
+					mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+				} else {
+				}
+			}
+		}
+		KP40_GOLDEN = get_bits_from_value(rddata, 28, 24);
+		//------------------------------
+		// ZQ Complete
+		//------------------------------
+		uartlog("hw_done\n");
+		// param_phya_reg_zqcal_done  <= `PI_SD int_regin[0];
+		rddata = 0x00000001;
+		mmio_wr32(0x0158 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+		// ZQ clock off
+		rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // TOP_REG_CG_EN_ZQ
+		mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("ZQ Complete ...\n");
+
+		cvx16_zqcal_status();
+	} //} initial ZQCAL
+	else {
+		KC_MSG("Not need ZQCAL\n");
+	}
+}
+
+void cvx16_ddr_zqcal_hw_isr8(uint32_t hw_mode)
+{
+	uint32_t dram_class;
+	// uint32_t wr_odt_en; //unused
+	// uint32_t rtt_wr; //unused
+	// int i; //unused
+
+	uartlog("ddr_zqcal_hw_isr8\n");
+	ddr_debug_wr32(0x2c);
+	ddr_debug_num_write();
+	// VDDQ_TXr        = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// ZQ clock on
+	rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 12, 12); // TOP_REG_CG_EN_ZQ
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	// param_phyd_zqcal_hw_mode =1
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, hw_mode, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_zqcal_done  <= `PI_SD int_regin[3];
+	rddata = mmio_rd32(0x0158 + PHYD_BASE_ADDR);
+	KC_MSG("Check ZQ Calibration param_phya_reg_zqcal_done = %x\n", get_bits_from_value(rddata, 0, 0));
+
+	if (get_bits_from_value(rddata, 0, 0) == 0) { // initial ZQCAL
+		rddata = mmio_rd32(0x0050 + PHYD_BASE_ADDR);
+		// dram_class = rddata[11:8];  //DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		dram_class = get_bits_from_value(
+			rddata, 3, 0); // DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+		KC_MSG("dram_class = %x...\n", dram_class);
+
+		KC_MSG("DDR2:0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011\n");
+
+		//    ->ydh_zq_event;
+		// a.
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+		// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+		rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 5, 5);
+		mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// b.
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+		rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+		// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+		rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+		rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+		mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+		//    ->ydh_zq_event;
+		// c.
+		// param_phya_reg_vref_pd  <= `PI_SD int_regin[9];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[9] = 0;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		// param_phya_reg_vref_sel[4:0] <= `PI_SD int_regin[14:10];
+		//     REGREAD(4 + PHY_BASE_ADDR, rddata);
+		//     rddata[14:10] = 0b01111;
+		//     REGWR  (4 + PHY_BASE_ADDR, rddata, 0);
+		//    ->ydh_zq_event;
+		// d.
+		// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+		rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 1, 0);
+		mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_SEL_GPIO
+		//     <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+		// TOP_REG_TX_GPIO_OENZ
+		//     <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+		rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 7, 6);
+		mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+		//------------------------------
+		// CMP offset Cal.
+		//------------------------------
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("zq_cmp_en\n");
+
+		//------------------------------
+		// ZQ Complete
+		//------------------------------
+		uartlog("wait hw_done\n");
+		// param_phyd_to_reg_zqcal_hw_done
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		while (get_bits_from_value(rddata, 16, 16) == 0) {
+			rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+			KC_MSG("wait param_phyd_to_reg_zqcal_hw_done ...\n");
+
+			// opdelay(100);
+		}
+		uartlog("hw_done\n");
+		// param_phya_reg_zqcal_done  <= `PI_SD int_regin[0];
+		rddata = 0x00000001;
+		mmio_wr32(0x0158 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+		// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+		// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+		// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+		// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+		// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+		// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+		rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 4, 0);
+		mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+		// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+		rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 1, 31, 31);
+		mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+		// param_phyd_zqcal_hw_mode =0
+		rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 18, 16);
+		mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+		// ZQ clock off
+		rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // TOP_REG_CG_EN_ZQ
+		mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("ZQ Complete ...\n");
+
+		cvx16_zqcal_status();
+	} else {
+		KC_MSG("Not need ZQCAL\n");
+	}
+}
+
+void cvx16_clk_normal(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x03);
+	ddr_debug_num_write();
+	KC_MSG("back to original frequency !!!\n\n");
+
+	rddata = mmio_rd32(0x0c + CV_DDR_PHYD_APB);
+	// rddata[13] TOP_REG_DDRPLL_SEL_LOW_SPEED 0
+	// rddata[14] TOP_REG_DDRPLL_MAS_DIV_OUT_SEL 0
+	rddata = modified_bits_by_value(rddata, 0, 13, 13);
+	rddata = modified_bits_by_value(rddata, 0, 14, 14);
+	mmio_wr32(0x0c + CV_DDR_PHYD_APB, rddata);
+#ifdef SSC_EN
+	//==============================================================
+	// Enable SSC
+	//==============================================================
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 1, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // extpulse
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_EN\n");
+#else
+#ifdef SSC_BYPASS
+	rddata = (reg_set & 0xfc000000) + 0x04000000; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 1, 6, 6); // ssc_syn_fix_div
+	uartlog("SSC_BYPASS\n");
+#else
+	//==============================================================
+	// SSC_EN =0
+	//==============================================================
+	uartlog("SSC_EN =0\n");
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_OFF\n");
+#endif // SSC_BYPASS
+#endif // SSC_EN
+	uartlog("back to original frequency\n");
+}
+
+void cvx16_clk_div2(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x01);
+	ddr_debug_num_write();
+	KC_MSG("div2 original frequency !!!\n\n");
+
+	rddata = mmio_rd32(0x0c + CV_DDR_PHYD_APB);
+	// rddata[14] = 1  ;  // TOP_REG_DDRPLL_MAS_DIV_OUT_SEL 1
+	rddata = modified_bits_by_value(rddata, 1, 14, 14);
+	mmio_wr32(0x0c + CV_DDR_PHYD_APB, rddata);
+	uartlog("div2 original frequency\n");
+}
+
+void cvx16_INT_ISR_08(void)
+{
+	uint32_t EN_PLL_SPEED_CHG;
+	uint32_t CUR_PLL_SPEED;
+	uint32_t NEXT_PLL_SPEED;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x1c);
+	ddr_debug_num_write();
+	// param_phyd_clkctrl_init_complete   <= int_regin[0];
+	rddata = 0x00000000;
+	mmio_wr32(0x0118 + PHYD_BASE_ADDR, rddata);
+	//----------------------------------------------------
+	rddata = mmio_rd32(0x4c + CV_DDR_PHYD_APB);
+	EN_PLL_SPEED_CHG = get_bits_from_value(rddata, 0, 0);
+	CUR_PLL_SPEED = get_bits_from_value(rddata, 5, 4);
+	NEXT_PLL_SPEED = get_bits_from_value(rddata, 9, 8);
+	KC_MSG("CUR_PLL_SPEED = %x, NEXT_PLL_SPEED = %x, EN_PLL_SPEED_CHG=%x\n", CUR_PLL_SPEED, NEXT_PLL_SPEED,
+	       EN_PLL_SPEED_CHG);
+
+	//----------------------------------------------------
+	cvx16_ddr_phy_power_on_seq2();
+	cvx16_set_dfi_init_complete();
+}
+
+void cvx16_clk_div40(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x02);
+	ddr_debug_num_write();
+	KC_MSG("Enter low D40 frequency !!!\n\n");
+
+	rddata = mmio_rd32(0x0c + CV_DDR_PHYD_APB);
+	// TOP_REG_DDRPLL_SEL_LOW_SPEED =1
+	rddata = modified_bits_by_value(rddata, 1, 13, 13);
+	mmio_wr32(0x0c + CV_DDR_PHYD_APB, rddata);
+	uartlog("Enter low D40 frequency\n");
+}
+
+void cvx16_ddr_phy_power_on_seq1(void)
+{
+	// power_seq_1
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x0e);
+	ddr_debug_num_write();
+	// RESETZ/CKE PD=0
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	// TOP_REG_TX_CA_PD_CKE0
+	rddata = modified_bits_by_value(rddata, 0, 24, 24);
+	// TOP_REG_TX_CA_PD_RESETZ
+	rddata = modified_bits_by_value(rddata, 0, 30, 30);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("RESET PD !!!\n");
+
+	// CA PD=0
+	// All PHYA CA PD=0
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 0);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("All PHYA CA PD=0 ...\n");
+
+	// TOP_REG_TX_SEL_GPIO = 1 (DQ)
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 7, 7);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_SEL_GPIO = 1\n");
+
+	// DQ PD=0
+	// TOP_REG_TX_BYTE0_PD
+	// TOP_REG_TX_BYTE1_PD
+	rddata = 0x00000000;
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TX_BYTE PD=0 ...\n");
+
+	// TOP_REG_TX_SEL_GPIO = 0 (DQ)
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 7, 7);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_SEL_GPIO = 0\n");
+
+	// power_seq_1
+}
+
+void cvx16_ddr_phy_power_on_seq2(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x0f);
+	ddr_debug_num_write();
+	// Change PLL frequency
+	KC_MSG("Change PLL frequency if necessary ...\n");
+
+	cvx16_chg_pll_freq();
+	// OEN
+	// param_phyd_sel_cke_oenz        <= `PI_SD int_regin[0];
+	rddata = mmio_rd32(0x0154 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_tx_ca_oenz          <= `PI_SD int_regin[0];
+	// param_phyd_tx_ca_clk0_oenz     <= `PI_SD int_regin[8];
+	// param_phyd_tx_ca_clk1_oenz     <= `PI_SD int_regin[16];
+	rddata = 0x00000000;
+	mmio_wr32(0x0130 + PHYD_BASE_ADDR, rddata);
+	// Do DLLCAL if necessary
+	KC_MSG("Do DLLCAL if necessary ...\n");
+
+	cvx16_dll_cal();
+	KC_MSG("Do DLLCAL done\n");
+
+	//    KC_MSG("Do ZQCAL if necessary ...\n");
+
+	// cvx16_ddr_zqcal_hw_isr8(0x7);//zqcal hw mode, bit0: offset_cal, bit1:pl_en, bit2:step2_en
+	// KC_MSG("Do ZQCAL done\n");
+
+	KC_MSG("cv181x without ZQ Calibration ...\n");
+
+	// cvx16_ddr_zq240_cal();//zq240_cal
+	// KC_MSG("Do cvx16_ddr_zq240_cal done\n");
+
+	KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	// zq calculate variation
+	//  zq_cal_var();
+	KC_MSG("zq calculate variation not run\n");
+
+	// CA PD =0
+	// All PHYA CA PD=0
+	rddata = 0x80000000;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("All PHYA CA PD=0 ...\n");
+
+	// BYTE PD =0
+	rddata = 0x00000000;
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TX_BYTE PD=0 ...\n");
+
+	// power_on_2
+}
+
+void cvx16_ddr_phy_power_on_seq3(void)
+{
+	// power on 3
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x10);
+	ddr_debug_num_write();
+	// RESETYZ/CKE OENZ
+	// param_phyd_sel_cke_oenz        <= `PI_SD int_regin[0];
+	rddata = mmio_rd32(0x0154 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_tx_ca_oenz          <= `PI_SD int_regin[0];
+	// param_phyd_tx_ca_clk0_oenz     <= `PI_SD int_regin[8];
+	// param_phyd_tx_ca_clk1_oenz     <= `PI_SD int_regin[16];
+	rddata = 0x00000000;
+	mmio_wr32(0x0130 + PHYD_BASE_ADDR, rddata);
+	uartlog("[KC Info] --> ca_oenz  ca_clk_oenz !!!\n");
+
+	// clock gated for power save
+	// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_byte1_en_extend_oenz_gated_dline <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_byte2_en_extend_oenz_gated_dline <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_byte3_en_extend_oenz_gated_dline <= `PI_SD int_regin[3];
+	rddata = mmio_rd32(0x0204 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 18);
+	mmio_wr32(0x0204 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0224 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 18);
+	mmio_wr32(0x0224 + PHYD_BASE_ADDR, rddata);
+	uartlog("[KC Info] --> en clock gated for power save !!!\n");
+
+	// power on 3
+}
+
+void cvx16_wait_for_dfi_init_complete(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x13);
+	ddr_debug_num_write();
+	// synp setting
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x000001bc);
+		//} while ((rddata & 0x00000001) != 1);
+		if (get_bits_from_value(rddata, 0, 0) == 1) {
+			break;
+		}
+	}
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001b0);
+	rddata = modified_bits_by_value(rddata, 5, 5, 0);
+	mmio_wr32(cfg_base + 0x000001b0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	KC_MSG("dfi_init_complete finish\n");
+}
+
+void cvx16_ctrlupd_short(void)
+{
+	// ctrlupd short
+	uartlog("cvx16ctrlupd_short\n");
+	ddr_debug_wr32(0x2a);
+	ddr_debug_num_write();
+	// for gate track
+	// dis_auto_ctrlupd [31] =0, dis_auto_ctrlupd_srx [30] =0, ctrlupd_pre_srx [29] =1 @ 0x1a0
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	// original        rddata[31:29] = 0b001;
+	rddata = modified_bits_by_value(rddata, 1, 31, 29);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	// dfi_t_ctrlupd_interval_min_x1024 [23:16] = 4, dfi_t_ctrlupd_interval_max_x1024 [7:0] = 8 @ 0x1a4
+	rddata = mmio_rd32(cfg_base + 0x000001a4);
+	// original        rddata[23:16] = 0x04;
+	rddata = modified_bits_by_value(rddata, 4, 23, 16);
+	// original        rddata[7:0] = 0x08;
+	rddata = modified_bits_by_value(rddata, 8, 7, 0);
+	mmio_wr32(cfg_base + 0x000001a4, rddata);
+}
+
+void cvx16_polling_dfi_init_start(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x11);
+	ddr_debug_num_write();
+	while (1) {
+		rddata = mmio_rd32(0x3028 + PHYD_BASE_ADDR);
+		if ((get_bits_from_value(rddata, 8, 8) == 1)) {
+			break;
+		}
+	}
+}
+
+void cvx16_set_dfi_init_complete(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x48);
+	ddr_debug_num_write();
+#ifdef REAL_LOCK
+	opdelay(20000);
+#endif
+	// rddata[8] = 1;
+	rddata = 0x00000010;
+	mmio_wr32(0x0120 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("set init_complete = 1 ...\n");
+
+	// param_phyd_clkctrl_init_complete   <= int_regin[0];
+	rddata = 0x00000001;
+	mmio_wr32(0x0118 + PHYD_BASE_ADDR, rddata);
+}
+
+void cvx16_polling_synp_normal_mode(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x14);
+	ddr_debug_num_write();
+	// synp ctrl operating_mode
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x00000004);
+		KC_MSG("operating_mode = %x\n", get_bits_from_value(rddata, 2, 0));
+
+		if (get_bits_from_value(rddata, 2, 0) == 1) {
+			break;
+		}
+	}
+}
+
+void cvx16_dfi_ca_park_prbs(uint32_t cap_enable)
+{
+	uint32_t dfi_ca_park_misc;
+	uint32_t dfi_ca_park_retain_cycle;
+	uint32_t dfi_ca_park_ca_ref;
+	uint32_t dfi_ca_park_ca_park;
+
+	// param_phyd_sw_dfi_phyupd_req =1
+	rddata = 0x00000001;
+	mmio_wr32(0x0174 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		// param_phyd_to_reg_dfi_phyupd_req  8   8
+		// param_phyd_to_reg_dfi_phyupd_ack  9   9
+		rddata = mmio_rd32(0x3030 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 9, 8) == 3) {
+			break;
+		}
+	}
+	// DDR3
+	//   cfg_det_en = 0b1;
+	//   cfg_cs_det_en = 0b1;
+	//   cap_prbs_en = 0b1;
+	//   cfg_cs_polarity = 0b1;
+	//   cap_prbs_1t = 0b0;
+	//   cfg_ca_reference = {0b0,0x0_ffff,0x7,0x0,0b1,0b0,0b1,0b1};
+	//   cfg_cs_retain_cycle = 0b0000_0001;
+	//   cfg_ca_retain_cycle = 0b0000_0000;
+	//   cfg_ca_park_value = 0x3fff_ffff;
+	if (cap_enable == 1) {
+		dfi_ca_park_misc = 0x1B;
+		mmio_wr32(DDR_TOP_BASE + 0x00, dfi_ca_park_misc);
+		KC_MSG("dfi_ca_park_prbs enable = 1\n");
+	} else {
+		dfi_ca_park_misc = 0x0;
+		mmio_wr32(DDR_TOP_BASE + 0x00, dfi_ca_park_misc);
+		KC_MSG("dfi_ca_park_prbs enable = 0\n");
+	}
+	dfi_ca_park_retain_cycle = 0x01;
+	mmio_wr32(DDR_TOP_BASE + 0x04, dfi_ca_park_retain_cycle);
+	dfi_ca_park_ca_ref = 0x1ffffcb;
+	mmio_wr32(DDR_TOP_BASE + 0x08, dfi_ca_park_ca_ref);
+	dfi_ca_park_ca_park = 0x3fffffff;
+	mmio_wr32(DDR_TOP_BASE + 0x0c, dfi_ca_park_ca_park);
+
+	// param_phyd_sw_dfi_phyupd_req_clr =1
+	rddata = 0x00000010;
+	mmio_wr32(0x0174 + PHYD_BASE_ADDR, rddata);
+}
+
+void cvx16_wrlvl_req(void)
+{
+#ifndef DDR2
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	uint32_t wr_odt_en;
+	uint32_t rtt_wr;
+	uint32_t rtt_nom;
+	uint32_t port_num;
+
+	// Note: training need ctrl_low_patch first
+	mmio_wr32(0x005C + PHYD_BASE_ADDR, 0x00FE0000); //wrlvl response only DQ0
+	// Write 0 to PCTRL_n.port_en, without port 0
+	// port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2e);
+	ddr_debug_num_write();
+	KC_MSG_TR("%s\n", __func__);
+
+	// save ctrl wr_odt_en
+	rddata = mmio_rd32(cfg_base + 0x244);
+	wr_odt_en = get_bits_from_value(rddata, 0, 0);
+	// bist setting for dfi wrlvl
+	cvx16_bist_wrlvl_init();
+	// // RFSHCTL3.dis_auto_refresh =1
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+#ifdef DDR3
+	rtt_nom = 0;
+	if (wr_odt_en == 1) {
+		KC_MSG_TR("wr_odt_en =1 ...\n");
+
+		// save rtt_wr
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rtt_wr = get_bits_from_value(rddata, 26, 25);
+		if (rtt_wr != 0x0) {
+			// disable rtt_wr
+			rddata = modified_bits_by_value(rddata, 0, 26, 25);
+			cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+			// set rtt_nom
+			rddata = mmio_rd32(cfg_base + 0xdc);
+			rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+			rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 1, 1), 6,
+							 6); // rtt_nom[1]=rtt_wr[1]
+			rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 0, 0), 2,
+							 2); // rtt_nom[1]=rtt_wr[0]
+			uartlog("dodt for wrlvl setting\n");
+		}
+	} else {
+		uartlog("rtt_nom for wrlvl setting\n");
+		KC_MSG_TR("wr_odt_en =0 ...\n");
+
+		// set rtt_nom = 120ohm
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+		rtt_nom = modified_bits_by_value(rtt_nom, 1, 6, 6); // rtt_nom[1]=1
+		rtt_nom = modified_bits_by_value(rtt_nom, 0, 2, 2); // rtt_nom[1]=0
+		cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+	}
+	rtt_nom = modified_bits_by_value(rtt_nom, 1, 7, 7); // Write leveling enable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+	KC_MSG_TR("DDR3 MRS rtt_nom ...\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rtt_nom = 0;
+		if (wr_odt_en == 1) {
+			KC_MSG_TR("wr_odt_en =1 ...\n");
+
+			// save rtt_wr
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rtt_wr = get_bits_from_value(rddata, 26, 25);
+			if (rtt_wr != 0x0) {
+				// disable rtt_wr
+				rddata = modified_bits_by_value(rddata, 0, 26, 25);
+				cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+				// set rtt_nom
+				rddata = mmio_rd32(cfg_base + 0xdc);
+				rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+				rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 1, 1), 6,
+								6); // rtt_nom[1]=rtt_wr[1]
+				rtt_nom = modified_bits_by_value(rtt_nom, get_bits_from_value(rtt_wr, 0, 0), 2,
+								2); // rtt_nom[1]=rtt_wr[0]
+				uartlog("dodt for wrlvl setting\n");
+			}
+		} else {
+			uartlog("rtt_nom for wrlvl setting\n");
+			KC_MSG_TR("wr_odt_en =0 ...\n");
+
+			// set rtt_nom = 120ohm
+			rddata = mmio_rd32(cfg_base + 0xdc);
+			rtt_nom = modified_bits_by_value(rddata, 0, 9, 9); // rtt_nom[2]=0
+			rtt_nom = modified_bits_by_value(rtt_nom, 1, 6, 6); // rtt_nom[1]=1
+			rtt_nom = modified_bits_by_value(rtt_nom, 0, 2, 2); // rtt_nom[1]=0
+			cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+		}
+		rtt_nom = modified_bits_by_value(rtt_nom, 1, 7, 7); // Write leveling enable
+		cvx16_synp_mrw(0x1, get_bits_from_value(rtt_nom, 15, 0));
+		KC_MSG_TR("DDR3 MRS rtt_nom ...\n");
+	}
+#endif
+#ifdef DDR4
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	rddata = modified_bits_by_value(rddata, 1, 7, 7); // Write leveling enable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+#endif
+	rddata = mmio_rd32(0x0180 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_wrlvl_req
+	rddata = modified_bits_by_value(rddata, wr_odt_en, 4, 4); // param_phyd_dfi_wrlvl_odt_en
+	mmio_wr32(0x0180 + PHYD_BASE_ADDR, rddata);
+	KC_MSG_TR("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 0, 0) == 0x1) {
+			// bist clock disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+			break;
+		}
+	}
+
+	// RFSHCTL3.dis_auto_refresh =0
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+	mmio_wr32(cfg_base + 0x60, rddata);
+
+#ifdef DDR3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rddata=modified_bits_by_value(rddata, 0, 7, 7); //Write leveling disable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2e);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// rddata=modified_bits_by_value(rddata, 0, 7, 7); //Write leveling disable
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 16)); // MR2
+		uartlog("%s\n", __func__);
+		ddr_debug_wr32(0x2e);
+		ddr_debug_num_write();
+	}
+#endif
+#ifdef DDR4
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rddata=modified_bits_by_value(rddata, 0, 7, 7); //Write leveling disable
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 0));
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2e);
+	ddr_debug_num_write();
+#endif
+	// // RFSHCTL3.dis_auto_refresh =0
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_wrlvl_status();
+	cvx16_clk_gating_enable();
+#endif // not DDR2
+}
+
+void cvx16_rdglvl_req(void)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#ifdef DDR3
+	uint32_t ddr3_mpr_mode;
+#endif //DDR3
+#ifdef DDR2_3
+		uint32_t ddr3_mpr_mode;
+#endif
+	uint32_t port_num;
+	// Note: training need ctrl_low_patch first
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   // this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	// RFSHCTL3.dis_auto_refresh =1
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata=modified_bits_by_value(rddata, 1, 0, 0); //RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2f);
+	ddr_debug_num_write();
+	KC_MSG_TR("%s\n", __func__);
+
+#ifdef DDR3
+	rddata = mmio_rd32(0x0184 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (ddr3_mpr_mode) {
+		// RFSHCTL3.dis_auto_refresh =1
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+	}
+#endif
+#ifdef DDR2_3
+
+	rddata = mmio_rd32(0x0184 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// RFSHCTL3.dis_auto_refresh =1
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		}
+	}
+#endif
+	// bist setting for dfi rdglvl
+	cvx16_bist_rdglvl_init();
+	rddata = mmio_rd32(0x0184 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdglvl_req
+	mmio_wr32(0x0184 + PHYD_BASE_ADDR, rddata);
+	KC_MSG_TR("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 1, 1) == 0x1) {
+			// bist clock disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+			break;
+		}
+	}
+#ifdef DDR3
+	if (ddr3_mpr_mode) {
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		// RFSHCTL3.dis_auto_refresh =0
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+	}
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x2f);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+			// RFSHCTL3.dis_auto_refresh =0
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+		}
+		uartlog("%s\n", __func__);
+		ddr_debug_wr32(0x2f);
+		ddr_debug_num_write();
+	}
+#endif
+	// RFSHCTL3.dis_auto_refresh =0
+	// rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata=modified_bits_by_value(rddata, 0, 0, 0); //RFSHCTL3.dis_auto_refresh
+	// mmio_wr32(cfg_base + 0x60, rddata);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_rdglvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_rdlvl_req(uint32_t mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#ifdef DDR3
+	uint32_t ddr3_mpr_mode;
+#endif //DDR3
+#ifdef DDR2_3
+	uint32_t ddr3_mpr_mode;
+#endif
+	uint32_t port_num;
+	uint32_t vref_training_en;
+	// uint32_t code_neg; //unused
+	// uint32_t code_pos; //unused
+	// Note: training need ctrl_low_patch first
+	// mode = 0x0  : MPR mode, DDR3 only.
+	// mode = 0x1  : sram write/read continuous goto
+	// mode = 0x2  : multi- bist write/read
+	// mode = 0x10 : with Error enject,  multi- bist write/read
+	// mode = 0x12 : with Error enject,  multi- bist write/read
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	//    //RFSHCTL3.dis_auto_refresh =1
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 1, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("%s\n", __func__);
+
+	//deskew start from 0x20
+	rddata = mmio_rd32(0x0080 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x20, 22, 16); //param_phyd_pirdlvl_deskew_start
+	rddata = modified_bits_by_value(rddata, 0x1F, 30, 24); //param_phyd_pirdlvl_deskew_end
+	mmio_wr32(0x0080 + PHYD_BASE_ADDR,  rddata);
+
+	// save param_phyd_pirdlvl_vref_training_en
+	rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+	vref_training_en = get_bits_from_value(rddata, 2, 2);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_pirdlvl_rx_init_deskew_en
+	rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // param_phyd_pirdlvl_rdvld_training_en = 0
+	mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+#ifdef DDR3
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (ddr3_mpr_mode) {
+		// RFSHCTL3.dis_auto_refresh =1
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+	}
+#endif
+#ifdef DDR2_3
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// RFSHCTL3.dis_auto_refresh =1
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		}
+	}
+#endif
+	// bist setting for dfi rdglvl
+	cvx16_bist_rdlvl_init(mode);
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+	mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dfi_rdlvl_req 1\n");
+
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+			break;
+		}
+	}
+	if (vref_training_en == 0x1) {
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+		// final training, keep rx trig_lvl
+		KC_MSG("final training, keep rx trig_lvl\n");
+
+		rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+		mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("dfi_rdlvl_req 2\n");
+
+		KC_MSG("wait retraining finish ...\n");
+
+		while (1) {
+			//[0] param_phyd_dfi_wrlvl_done
+			//[1] param_phyd_dfi_rdglvl_done
+			//[2] param_phyd_dfi_rdlvl_done
+			//[3] param_phyd_dfi_wdqlvl_done
+			rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+				break;
+			}
+		}
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref_training_en, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+	}
+
+#ifdef DDR3
+	if (ddr3_mpr_mode) {
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		// RFSHCTL3.dis_auto_refresh =0
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+	}
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+			// RFSHCTL3.dis_auto_refresh =0
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+		}
+		uartlog("%s\n", __func__);
+		ddr_debug_wr32(0x30);
+		ddr_debug_num_write();
+	}
+#endif
+
+	cvx16_rdvld_train();
+
+	//    //RFSHCTL3.dis_auto_refresh =0
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 0, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_rdlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_rdlvl_sw_req(uint32_t mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#ifdef DDR3
+	uint32_t ddr3_mpr_mode;
+#endif //DDR3
+#ifdef DDR2_3
+	uint32_t ddr3_mpr_mode;
+#endif
+	uint32_t port_num;
+	uint32_t vref_training_en;
+	uint32_t byte0_pirdlvl_sw_upd_ack;
+	uint32_t byte1_pirdlvl_sw_upd_ack;
+	uint32_t rx_vref_sel;
+	uint32_t byte0_data_rise_fail;
+	uint32_t byte0_data_fall_fail;
+	uint32_t byte1_data_rise_fail;
+	uint32_t byte1_data_fall_fail;
+	uint32_t dlie_code;
+	uint32_t byte0_all_le_found;
+	uint32_t byte0_all_te_found;
+	uint32_t byte1_all_le_found;
+	uint32_t byte1_all_te_found;
+	// uint32_t code_neg; //unused
+	// uint32_t code_pos; //unused
+	uint32_t byte0_cur_pirdlvl_st;
+	uint32_t byte1_cur_pirdlvl_st;
+	uint32_t sw_upd_req_start;
+
+	sw_upd_req_start = 0;
+	// mode = 0x0  : MPR mode, DDR3 only.
+	// mode = 0x1  : sram write/read continuous goto
+	// mode = 0x2  : multi- bist write/read
+	// mode = 0x10 : with Error enject,  multi- bist write/read
+	// mode = 0x12 : with Error enject,  multi- bist write/read
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	//    //RFSHCTL3.dis_auto_refresh =1
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 1, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("%s\n", __func__);
+
+	//deskew start from 0x20
+	rddata = mmio_rd32(0x0080 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x20, 22, 16); //param_phyd_pirdlvl_deskew_start
+	rddata = modified_bits_by_value(rddata, 0x1F, 30, 24); //param_phyd_pirdlvl_deskew_end
+	mmio_wr32(0x0080 + PHYD_BASE_ADDR,  rddata);
+
+	// save param_phyd_pirdlvl_vref_training_en
+	rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+	vref_training_en = get_bits_from_value(rddata, 2, 2);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_pirdlvl_rx_init_deskew_en
+	rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // param_phyd_pirdlvl_rdvld_training_en = 0
+	mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+
+#ifdef DDR3
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (ddr3_mpr_mode) {
+		// RFSHCTL3.dis_auto_refresh =1
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+	}
+#endif
+#ifdef DDR2_3
+
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	ddr3_mpr_mode = get_bits_from_value(rddata, 4, 4);
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// RFSHCTL3.dis_auto_refresh =1
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 1, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 1, 2, 2); // Dataflow from MPR
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		}
+	}
+#endif
+
+	// bist setting for dfi rdglvl
+	cvx16_bist_rdlvl_init(mode);
+	// SW mode
+	rddata = mmio_rd32(0x0090 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 9, 9); // param_phyd_pirdlvl_sw
+	mmio_wr32(0x0090 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+	mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dfi_rdlvl_req 1\n");
+
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+			break;
+		}
+		while (1) {
+			rddata = mmio_rd32(0x31B0 + PHYD_BASE_ADDR);
+			byte0_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte0_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte0_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte0_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			rddata = mmio_rd32(0x31B0 + 0x40 + PHYD_BASE_ADDR);
+			byte1_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte1_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte1_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte1_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			KC_MSG("=1 byte0_pirdlvl_sw_upd_ack = %x, byte1_pirdlvl_sw_upd_ack = %x\n",
+			       byte0_pirdlvl_sw_upd_ack, byte1_pirdlvl_sw_upd_ack);
+
+			if ((byte0_all_le_found == 0) && (byte0_all_te_found == 0) && (byte1_all_le_found == 0) &&
+			    (byte1_all_te_found == 0)) {
+				sw_upd_req_start = 0x1;
+			} else {
+				if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+				    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1) &&
+				    ((byte0_cur_pirdlvl_st == 0x0) && (byte1_cur_pirdlvl_st == 0x0))) {
+					sw_upd_req_start = 0x0;
+				}
+			}
+			// KC_MSG("sw_upd_req_start = %x\n", sw_upd_req_start);
+
+			if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte0_all_le_found & byte0_all_te_found)) &&
+			    ((byte1_pirdlvl_sw_upd_ack == 0x1) || (byte1_all_le_found & byte1_all_te_found))) {
+				rddata = mmio_rd32(0x0B24 + PHYD_BASE_ADDR);
+				rx_vref_sel = get_bits_from_value(rddata, 4, 0);
+				rddata = mmio_rd32(0x0B08 + PHYD_BASE_ADDR);
+				dlie_code = get_bits_from_value(rddata, 15, 8);
+				rddata = mmio_rd32(0x31B4 + PHYD_BASE_ADDR);
+				if (byte0_all_te_found) {
+					byte0_data_rise_fail = 0xff;
+					byte0_data_fall_fail = 0xff;
+				} else {
+					byte0_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+					byte0_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				rddata = mmio_rd32(0x31B4 + 0x40 + PHYD_BASE_ADDR);
+				if (byte1_all_te_found) {
+					byte1_data_rise_fail = 0xff;
+					byte1_data_fall_fail = 0xff;
+				} else {
+					byte1_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+					byte1_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+				    ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+					SHMOO_MSG("vref = %02x, sw_rdq_training_start = %08x , ",
+						  rx_vref_sel, dlie_code);
+					SHMOO_MSG("err_data_rise/err_data_fall = %08x, %08x\n",
+						  ((byte0_data_rise_fail & 0x000000FF) |
+						   ((byte1_data_rise_fail & 0x000000FF) << 8)),
+						   ((byte0_data_fall_fail & 0x000000FF) |
+						   ((byte1_data_fall_fail & 0x000000FF) << 8)));
+				}
+				//if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1))
+				//    || ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+				if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+				    (sw_upd_req_start == 0x1)) {
+					rddata = mmio_rd32(0x0090 + PHYD_BASE_ADDR);
+					rddata = modified_bits_by_value(rddata, 1, 10,
+									10); // param_phyd_pirdlvl_sw_upd_req
+					mmio_wr32(0x0090 + PHYD_BASE_ADDR, rddata);
+				}
+				KC_MSG("byte0_all_le_found, byte0_all_te_found, ");
+				KC_MSG("byte1_all_le_found, byte1_all_te_found");
+				KC_MSG(" =%x %x %x %x\n",
+				       byte0_all_le_found, byte0_all_te_found,
+				       byte1_all_le_found, byte1_all_te_found);
+
+				break;
+			}
+			if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+			    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1)) {
+				break;
+			}
+
+			rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+				break;
+			}
+		}
+	}
+	if (vref_training_en == 0x1) {
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+		// final training, keep rx trig_lvl
+		KC_MSG("final training, keep rx trig_lvl\n");
+
+		rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_rdlvl_req
+		mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("dfi_rdlvl_req 2\n");
+
+		KC_MSG("wait retraining finish ...\n");
+
+		while (1) {
+			rddata = mmio_rd32(0x31B0 + PHYD_BASE_ADDR);
+			byte0_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte0_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte0_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte0_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			rddata = mmio_rd32(0x31B0 + 0x40 + PHYD_BASE_ADDR);
+			byte1_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte1_all_le_found = get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+			byte1_all_te_found = get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+			byte1_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+			KC_MSG("Wait all_found clear  ");
+			KC_MSG("byte0_all_le_found | byte0_all_te_found = %x, ",
+			       (byte0_all_le_found | byte0_all_te_found));
+			KC_MSG("byte1_all_le_found | byte1_all_te_found = %x\n",
+			       (byte1_all_le_found | byte1_all_te_found));
+
+			if ((byte0_all_le_found == 0) && (byte0_all_te_found == 0) &&
+			    (byte1_all_le_found == 0) && (byte1_all_te_found == 0)) {
+				break;
+			}
+		}
+		while (1) {
+			//[0] param_phyd_dfi_wrlvl_done
+			//[1] param_phyd_dfi_rdglvl_done
+			//[2] param_phyd_dfi_rdlvl_done
+			//[3] param_phyd_dfi_wdqlvl_done
+			rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+				break;
+			}
+			while (1) {
+				rddata = mmio_rd32(0x31B0 + PHYD_BASE_ADDR);
+				byte0_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+				byte0_all_le_found =
+					get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+				byte0_all_te_found =
+					get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+				byte0_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+				rddata = mmio_rd32(0x31B0 + 0x40 + PHYD_BASE_ADDR);
+				byte1_pirdlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+				byte1_all_le_found =
+					get_bits_from_value(rddata, 5, 5) & get_bits_from_value(rddata, 7, 7);
+				byte1_all_te_found =
+					get_bits_from_value(rddata, 4, 4) & get_bits_from_value(rddata, 6, 6);
+				byte1_cur_pirdlvl_st = get_bits_from_value(rddata, 23, 20);
+				KC_MSG("=1 byte0_pirdlvl_sw_upd_ack = %x, byte1_pirdlvl_sw_upd_ack = %x\n",
+				       byte0_pirdlvl_sw_upd_ack, byte1_pirdlvl_sw_upd_ack);
+
+				if ((byte0_all_le_found == 0) && (byte0_all_te_found == 0) &&
+				    (byte1_all_le_found == 0) && (byte1_all_te_found == 0)) {
+					sw_upd_req_start = 0x1;
+				} else {
+					if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+					    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1) &&
+					    ((byte0_cur_pirdlvl_st == 0x0) && (byte1_cur_pirdlvl_st == 0x0))) {
+						sw_upd_req_start = 0x0;
+					}
+				}
+				// KC_MSG("sw_upd_req_start = %x\n", sw_upd_req_start);
+
+				if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte0_all_le_found & byte0_all_te_found)) &&
+				    ((byte1_pirdlvl_sw_upd_ack == 0x1) || (byte1_all_le_found & byte1_all_te_found))) {
+					//if ((byte0_pirdlvl_sw_upd_ack == 0x1) && (byte1_pirdlvl_sw_upd_ack == 0x1)) {
+					rddata = mmio_rd32(0x0B24 + PHYD_BASE_ADDR);
+					rx_vref_sel = get_bits_from_value(rddata, 4, 0);
+					rddata = mmio_rd32(0x0B08 + PHYD_BASE_ADDR);
+					dlie_code = get_bits_from_value(rddata, 15, 8);
+					rddata = mmio_rd32(0x31B4 + PHYD_BASE_ADDR);
+					if (byte0_all_te_found) {
+						byte0_data_rise_fail = 0xff;
+						byte0_data_fall_fail = 0xff;
+					} else {
+						byte0_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+						byte0_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+					}
+					rddata = mmio_rd32(0x31B4 + 0x40 + PHYD_BASE_ADDR);
+					if (byte1_all_te_found) {
+						byte1_data_rise_fail = 0xff;
+						byte1_data_fall_fail = 0xff;
+					} else {
+						byte1_data_rise_fail = get_bits_from_value(rddata, 24, 16);
+						byte1_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+					}
+					if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+					    ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+						SHMOO_MSG("vref = %02x, sw_rdq_training_start = %08x , ",
+							  rx_vref_sel, dlie_code);
+						SHMOO_MSG("err_data_rise/err_data_fall = %08x, %08x\n",
+						       ((byte0_data_rise_fail & 0x000000FF) |
+							((byte1_data_rise_fail & 0x000000FF) << 8)),
+						       ((byte0_data_fall_fail & 0x000000FF) |
+							((byte1_data_fall_fail & 0x000000FF) << 8)));
+					}
+					// if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1))
+					//     || ((byte0_cur_pirdlvl_st != 0x0) && (byte1_cur_pirdlvl_st != 0x0))) {
+					if (((byte0_pirdlvl_sw_upd_ack == 0x1) || (byte1_pirdlvl_sw_upd_ack == 0x1)) &&
+					    (sw_upd_req_start == 0x1)) {
+						rddata = mmio_rd32(0x0090 + PHYD_BASE_ADDR);
+						rddata = modified_bits_by_value(rddata, 1, 10,
+										10); // param_phyd_pirdlvl_sw_upd_req
+						mmio_wr32(0x0090 + PHYD_BASE_ADDR, rddata);
+					}
+					KC_MSG("byte0_all_le_found, byte0_all_te_found, ");
+					KC_MSG("byte1_all_le_found, byte1_all_te_found");
+					KC_MSG(" =%x %x %x %x\n",
+					       byte0_all_le_found, byte0_all_te_found,
+					       byte1_all_le_found, byte1_all_te_found);
+
+					break;
+				}
+				if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) &&
+				    (byte1_all_le_found == 0x1) && (byte1_all_te_found == 0x1)) {
+					break;
+				}
+
+				rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+				if (get_bits_from_value(rddata, 2, 2) == 0x1) {
+					break;
+				}
+			}
+		}
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref_training_en, 2, 2); // param_phyd_pirdlvl_vref_training_en
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+	}
+
+#ifdef DDR3
+	if (ddr3_mpr_mode) {
+		// MR3
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+		cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+		// RFSHCTL3.dis_auto_refresh =0
+		rddata = mmio_rd32(cfg_base + 0x60);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+		mmio_wr32(cfg_base + 0x60, rddata);
+	}
+	uartlog("cvx16_rdlvl_req\n");
+	ddr_debug_wr32(0x30);
+	ddr_debug_num_write();
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		if (ddr3_mpr_mode) {
+			// MR3
+			rddata = mmio_rd32(cfg_base + 0xe0);
+			rddata = modified_bits_by_value(rddata, 0, 2, 2); // Normal operation
+			cvx16_synp_mrw(0x3, get_bits_from_value(rddata, 15, 0));
+			// RFSHCTL3.dis_auto_refresh =0
+			rddata = mmio_rd32(cfg_base + 0x60);
+			rddata = modified_bits_by_value(rddata, 0, 0, 0); // RFSHCTL3.dis_auto_refresh
+			mmio_wr32(cfg_base + 0x60, rddata);
+		}
+		uartlog("cvx16_rdlvl_req\n");
+		ddr_debug_wr32(0x30);
+		ddr_debug_num_write();
+	}
+#endif
+
+	cvx16_rdvld_train();
+
+	//    //RFSHCTL3.dis_auto_refresh =0
+	//    rddata = mmio_rd32(cfg_base + 0x60);
+	//    rddata=modified_bits_by_value(rddata, 0, 0, 0); //RFSHCTL3.dis_auto_refresh
+	//    mmio_wr32(cfg_base + 0x60, rddata);
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_rdlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_wdqlvl_req(uint32_t data_mode, uint32_t lvl_mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	// uint32_t bist_data_mode; //unused
+	uint32_t port_num;
+	// Note: training need ctrl_low_patch first
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	uartlog("cvx16_wdqlvl_req\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("cvx16_wdqlvl_req\n");
+
+	// param_phyd_piwdqlvl_dq_mode
+	//     <= #RD (~pwstrb_mask[12] & param_phyd_piwdqlvl_dq_mode) |  pwstrb_mask_pwdata[12];
+	// param_phyd_piwdqlvl_dm_mode
+	//     <= #RD (~pwstrb_mask[13] & param_phyd_piwdqlvl_dm_mode) |  pwstrb_mask_pwdata[13];
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	// lvl_mode =0x0, wdmlvl
+	// lvl_mode =0x1, wdqlvl
+	// lvl_mode =0x2, wdqlvl and wdmlvl
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x1) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 0, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x2) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	}
+	mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+	if (lvl_mode == 0x0) {
+		rddata = mmio_rd32(cfg_base + 0xC);
+		rddata = modified_bits_by_value(rddata, 1, 7, 7);
+		mmio_wr32(cfg_base + 0xC, rddata);
+		//        cvx16_bist_wdmlvl_init(sram_sp);
+		cvx16_bist_wdmlvl_init();
+	} else {
+		// bist setting for dfi rdglvl
+		// data_mode = 0x0 : phyd pattern
+		// data_mode = 0x1 : bist read/write
+		// data_mode = 0x11: with Error enject,  multi- bist write/read
+		// data_mode = 0x12: with Error enject,  multi- bist write/read
+		//         cvx16_bist_wdqlvl_init(data_mode, sram_sp);
+		cvx16_bist_wdqlvl_init(data_mode);
+	}
+	uartlog("cvx16_wdqlvl_req\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x018C + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_wdqlvl_req
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 1, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	}
+	if ((data_mode == 0x1) || (data_mode == 0x11) || (data_mode == 0x12)) {
+		rddata = modified_bits_by_value(rddata, 1, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 0, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	}
+	mmio_wr32(0x018C + PHYD_BASE_ADDR, rddata);
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 3, 3) == 0x1) {
+			break;
+		}
+	}
+	rddata = mmio_rd32(cfg_base + 0xC);
+	rddata = modified_bits_by_value(rddata, 0, 7, 7);
+	mmio_wr32(cfg_base + 0xC, rddata);
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_wdqlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_wdqlvl_sw_req(uint32_t data_mode, uint32_t lvl_mode)
+{
+	uint32_t selfref_sw;
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	// uint32_t bist_data_mode; //unused
+	uint32_t port_num;
+	uint32_t byte0_piwdqlvl_sw_upd_ack;
+	uint32_t byte1_piwdqlvl_sw_upd_ack;
+	uint32_t tx_vref_sel;
+	uint32_t byte0_data_rise_fail;
+	uint32_t byte0_data_fall_fail;
+	uint32_t byte1_data_rise_fail;
+	uint32_t byte1_data_fall_fail;
+	uint32_t dlie_code;
+	uint32_t byte0_all_le_found;
+	uint32_t byte0_all_te_found;
+	uint32_t byte1_all_le_found;
+	uint32_t byte1_all_te_found;
+	// uint32_t sram_sp;
+	//  Write 0 to PCTRL_n.port_en, without port 0
+	//  port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// disable PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	selfref_sw = get_bits_from_value(rddata, 5, 5);
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, 0, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	cvx16_clk_gating_disable();
+	uartlog("cvx16_wdqlvl_sw_req\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	cvx16_dfi_ca_park_prbs(1);
+	KC_MSG("cvx16_wdqlvl_sw_req\n");
+
+	// param_phyd_piwdqlvl_dq_mode
+	//     <= #RD (~pwstrb_mask[12] & param_phyd_piwdqlvl_dq_mode) |  pwstrb_mask_pwdata[12];
+	// param_phyd_piwdqlvl_dm_mode
+	//     <= #RD (~pwstrb_mask[13] & param_phyd_piwdqlvl_dm_mode) |  pwstrb_mask_pwdata[13];
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	// lvl_mode =0x0, wdmlvl
+	// lvl_mode =0x1, wdqlvl
+	// lvl_mode =0x2, wdqlvl and wdmlvl
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x1) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 0, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	} else if (lvl_mode == 0x2) {
+		rddata = modified_bits_by_value(rddata, 1, 12, 12); // param_phyd_piwdqlvl_dq_mode
+		rddata = modified_bits_by_value(rddata, 1, 13, 13); // param_phyd_piwdqlvl_dm_mode
+	}
+	mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+	if (lvl_mode == 0x0) {
+		//        cvx16_bist_wdmlvl_init(sram_sp);
+		cvx16_bist_wdmlvl_init();
+	} else {
+		// bist setting for dfi rdglvl
+		// data_mode = 0x0 : phyd pattern
+		// data_mode = 0x1 : bist read/write
+		// data_mode = 0x11: with Error enject,  multi- bist write/read
+		// data_mode = 0x12: with Error enject,  multi- bist write/read
+		//         cvx16_bist_wdqlvl_init(data_mode, sram_sp);
+		cvx16_bist_wdqlvl_init(data_mode);
+	}
+	uartlog("cvx16_wdqlvl_req sw\n");
+	ddr_debug_wr32(0x31);
+	ddr_debug_num_write();
+	// SW mode
+	rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 7, 7); // param_phyd_piwdqlvl_sw
+	mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x018C + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_dfi_wdqlvl_req
+	if (lvl_mode == 0x0) {
+		rddata = modified_bits_by_value(rddata, 0, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 1, 10, 10); // param_phyd_dfi_wdqlvl_vref_train_en
+	}
+	if ((data_mode == 0x1) || (data_mode == 0x11) || (data_mode == 0x12)) {
+		rddata = modified_bits_by_value(rddata, 1, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	} else {
+		rddata = modified_bits_by_value(rddata, 0, 4, 4); // param_phyd_dfi_wdqlvl_bist_data_en
+	}
+	mmio_wr32(0x018C + PHYD_BASE_ADDR, rddata);
+	KC_MSG("wait retraining finish ...\n");
+
+	while (1) {
+		//[0] param_phyd_dfi_wrlvl_done
+		//[1] param_phyd_dfi_rdglvl_done
+		//[2] param_phyd_dfi_rdlvl_done
+		//[3] param_phyd_dfi_wdqlvl_done
+		rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 3, 3) == 0x1) {
+			break;
+		}
+		while (1) {
+			rddata = mmio_rd32(0x32A4 + PHYD_BASE_ADDR);
+			byte0_piwdqlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte0_all_le_found = get_bits_from_value(rddata, 18, 18);
+			byte0_all_te_found = get_bits_from_value(rddata, 17, 17);
+			rddata = mmio_rd32(0x32E4 + PHYD_BASE_ADDR);
+			byte1_piwdqlvl_sw_upd_ack = get_bits_from_value(rddata, 0, 0);
+			byte1_all_le_found = get_bits_from_value(rddata, 18, 18);
+			byte1_all_te_found = get_bits_from_value(rddata, 17, 17);
+			KC_MSG("=1 byte0_piwdqlvl_sw_upd_ack = %x, byte1_piwdqlvl_sw_upd_ack = %x ",
+			       byte0_piwdqlvl_sw_upd_ack, byte1_piwdqlvl_sw_upd_ack);
+			KC_MSG("byte0_all_found = %x, byte1_all_found = %x\n",
+			       (byte0_all_le_found & byte0_all_te_found),
+			       (byte1_all_le_found & byte1_all_te_found));
+
+			if (((byte0_piwdqlvl_sw_upd_ack == 0x1) || (byte0_all_le_found & byte0_all_te_found)) &&
+			    ((byte1_piwdqlvl_sw_upd_ack == 0x1) || (byte1_all_le_found & byte1_all_te_found))) {
+				rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+				tx_vref_sel = get_bits_from_value(rddata, 20, 16);
+				rddata = mmio_rd32(0x32A8 + PHYD_BASE_ADDR);
+				dlie_code = get_bits_from_value(rddata, 30, 18);
+				if (byte0_all_te_found) {
+					byte0_data_rise_fail = 0xff;
+					byte0_data_fall_fail = 0xff;
+				} else {
+					byte0_data_rise_fail = get_bits_from_value(rddata, 17, 9);
+					byte0_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				rddata = mmio_rd32(0x32E8 + PHYD_BASE_ADDR);
+				if (byte1_all_te_found) {
+					byte1_data_rise_fail = 0xff;
+					byte1_data_fall_fail = 0xff;
+				} else {
+					byte1_data_rise_fail = get_bits_from_value(rddata, 17, 9);
+					byte1_data_fall_fail = get_bits_from_value(rddata, 8, 0);
+				}
+				if ((byte0_piwdqlvl_sw_upd_ack == 0x1) || (byte1_piwdqlvl_sw_upd_ack == 0x1)) {
+					SHMOO_MSG("vref = %02x, sw_wdq_training_start = %08x , ",
+					       tx_vref_sel, dlie_code);
+
+					SHMOO_MSG("err_data_rise/err_data_fall = %08x, %08x\n",
+					       ((byte0_data_rise_fail & 0x000000FF) |
+						((byte1_data_rise_fail & 0x000000FF) << 8)),
+					       ((byte0_data_fall_fail & 0x000000FF) |
+						((byte1_data_fall_fail & 0x000000FF) << 8)));
+				}
+				rddata = mmio_rd32(0x00BC + PHYD_BASE_ADDR);
+				rddata = modified_bits_by_value(rddata, 1, 8, 8); // param_phyd_piwdqlvl_sw_upd_req
+				mmio_wr32(0x00BC + PHYD_BASE_ADDR, rddata);
+				KC_MSG("param_phyd_piwdqlvl_sw_upd_req = %x\n",
+				       get_bits_from_value(rddata, 8, 8));
+
+				KC_MSG("byte0_all_le_found, byte0_all_te_found, ");
+				KC_MSG("byte1_all_le_found, byte1_all_te_found");
+				KC_MSG("= %x %x %x %x\n",
+				       byte0_all_le_found, byte0_all_te_found,
+				       byte1_all_le_found, byte1_all_te_found);
+
+				break;
+			}
+			if ((byte0_all_le_found == 0x1) && (byte0_all_te_found == 0x1) && (byte1_all_le_found == 0x1) &&
+			    (byte1_all_te_found == 0x1)) {
+				break;
+			}
+		}
+	}
+	// bist clock disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+	cvx16_dfi_ca_park_prbs(0);
+	// restore PWRCTL.powerdown_en, PWRCTL.selfref_en
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, selfref_sw, 5, 5); // PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3); // PWRCTL.en_dfi_dram_clk_disable
+	// rddata=modified_bits_by_value(rddata, 0, 2, 2); //PWRCTL.deeppowerdown_en, non-mDDR/non-LPDDR2/non-LPDDR3,
+							   //this register must not be set to 1
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1); // PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0); // PWRCTL.selfref_en
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 1 to PCTRL_n.port_en
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	// cvx16_wdqlvl_status();
+	cvx16_clk_gating_enable();
+}
+
+void cvx16_wrlvl_status(void)
+{
+#ifdef DBG_SHMOO
+	NOTICE("cvx16_wrlvl_status\n");
+	ddr_debug_wr32(0x32);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x3100 + PHYD_BASE_ADDR);
+	NOTICE("wrlvl_byte0_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("wrlvl_byte0_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3104 + PHYD_BASE_ADDR);
+	NOTICE("wrlvl_byte1_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("wrlvl_byte1_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x3108 + PHYD_BASE_ADDR);
+	// NOTICE("wrlvl_byte2_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("wrlvl_byte2_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x310C + PHYD_BASE_ADDR);
+	// NOTICE("wrlvl_byte3_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("wrlvl_byte3_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3110 + PHYD_BASE_ADDR);
+	NOTICE("wrlvl_byte0_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	NOTICE("wrlvl_byte1_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	// rddata = mmio_rd32(0x3114 + PHYD_BASE_ADDR);
+	// NOTICE("wrlvl_byte2_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	// NOTICE("wrlvl_byte3_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	rddata = mmio_rd32(0x0A14 + PHYD_BASE_ADDR);
+	NOTICE("byte0 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A34 + PHYD_BASE_ADDR);
+	NOTICE("byte0 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A54 + PHYD_BASE_ADDR);
+	NOTICE("byte1 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A74 + PHYD_BASE_ADDR);
+	NOTICE("byte1 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0A94 + PHYD_BASE_ADDR);
+	// NOTICE("byte2 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0AB4 + PHYD_BASE_ADDR);
+	// NOTICE("byte2 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0AD4 + PHYD_BASE_ADDR);
+	// NOTICE("byte3 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0AE4 + PHYD_BASE_ADDR);
+	// NOTICE("byte3 tx dqs raw delay_dqsn/delay_dqsp = %x\n", rddata);
+#endif //DBG_SHMOO
+}
+
+void cvx16_rdglvl_status(void)
+{
+#ifdef DBG_SHMOO
+	NOTICE("cvx16_rdglvl_status\n");
+	ddr_debug_wr32(0x33);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x3140 + PHYD_BASE_ADDR);
+	NOTICE("rdglvl_byte0_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("rdglvl_byte0_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3144 + PHYD_BASE_ADDR);
+	NOTICE("rdglvl_byte1_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	NOTICE("rdglvl_byte1_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x3148 + PHYD_BASE_ADDR);
+	// NOTICE("rdglvl_byte2_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("rdglvl_byte2_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	// rddata = mmio_rd32(0x314C + PHYD_BASE_ADDR);
+	// NOTICE("rdglvl_byte3_hard0 = %x\n", get_bits_from_value(rddata, 13, 0));
+	// NOTICE("rdglvl_byte3_hard1 = %x\n", get_bits_from_value(rddata, 29, 16));
+
+	rddata = mmio_rd32(0x3150 + PHYD_BASE_ADDR);
+	NOTICE("rdglvl_byte0_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	NOTICE("rdglvl_byte1_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	// rddata = mmio_rd32(0x3154 + PHYD_BASE_ADDR);
+	// NOTICE("rdglvl_byte2_status = %x\n", get_bits_from_value(rddata, 15, 0));
+	// NOTICE("rdglvl_byte3_status = %x\n", get_bits_from_value(rddata, 31, 16));
+
+	rddata = mmio_rd32(0x0B0C + PHYD_BASE_ADDR);
+	NOTICE("byte0 mask shift/delay = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0B3C + PHYD_BASE_ADDR);
+	NOTICE("byte1 mask shift/delay = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0B6C + PHYD_BASE_ADDR);
+	// NOTICE("byte2 mask shift/delay = %x\n", rddata);
+
+	// rddata = mmio_rd32(0x0B9C + PHYD_BASE_ADDR);
+	// NOTICE("byte3 mask shift/delay = %x\n", rddata);
+
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	// raw
+	rddata = mmio_rd32(0x0B20 + PHYD_BASE_ADDR);
+	NOTICE("raw byte0 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+
+	rddata = mmio_rd32(0x0B50 + PHYD_BASE_ADDR);
+	NOTICE("raw byte1 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+
+	// rddata = mmio_rd32(0x0B80 + PHYD_BASE_ADDR);
+	// NOTICE("raw byte2 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+
+	// rddata = mmio_rd32(0x0BB0 + PHYD_BASE_ADDR);
+	// NOTICE("raw byte3 mask delay = %x\n", get_bits_from_value(rddata, 14, 8));
+#endif //DBG_SHMOO
+}
+
+void cvx16_rdlvl_status(void)
+{
+#ifdef DBG_SHMOO
+	uint32_t i;
+
+	NOTICE("cvx16_rdlvl_status\n");
+	ddr_debug_wr32(0x34);
+	ddr_debug_num_write();
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3180 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3184 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3188 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x318C + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3190 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3194 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x3198 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x319C + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A0 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x31A4 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq0_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq1_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq2_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq3_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A8 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq4_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+		NOTICE("rdlvl_byte%x_dq5_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+		NOTICE("rdlvl_byte%x_dq6_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+		NOTICE("rdlvl_byte%x_dq7_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31AC + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_byte%x_dq8_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x31B0 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_status0_byte%x = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x31B4 + i * 0x40 + PHYD_BASE_ADDR);
+		NOTICE("rdlvl_status1_byte%x = %x\n", i, rddata);
+	}
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B00 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq3210 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B04 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq7654 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x rdqspos/neg/deskewdq8 = %x\n", i, rddata);
+	}
+	// rdvld
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B14 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x_rdvld = %x\n", i, get_bits_from_value(rddata, 20, 16));
+	}
+	// trig_lvl
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x trig_lvl_dq = %x, trig_lvl_dqs = %x\n", i, get_bits_from_value(rddata, 4, 0),
+		       get_bits_from_value(rddata, 20, 16));
+	}
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B18 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq3210_raw = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B1C + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x deskewdq7654_raw = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B20 + i * 0x30 + PHYD_BASE_ADDR);
+		NOTICE("byte%x rdqspos/neg/mask/deskewdq8 = %x\n", i, rddata);
+	}
+#endif // DBG_SHMOO
+}
+
+void cvx16_wdqlvl_status(void)
+{
+#ifdef DBG_SHMOO
+	NOTICE("cvx16_wdqlvl_status\n");
+	ddr_debug_wr32(0x35);
+	ddr_debug_num_write();
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3280 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq0_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq1_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3284 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq2_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq3_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3288 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq4_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq5_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x328C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq6_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq7_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3290 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq8_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq0_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3294 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq1_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq2_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3298 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq3_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq4_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x329C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq5_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq6_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x32A0 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq7_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq8_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x32A4 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_status0 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x32A8 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_status1 = %x\n", i, rddata);
+	}
+	// wdq shift
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0A00 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq0 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq1 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A04 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq2 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq3 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A08 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq4 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq5 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A0C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq6 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+		NOTICE("piwdqlvl_byte%x_dq7 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A10 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq8 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+	}
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	NOTICE("piwdqlvl tx vref = %x\n", get_bits_from_value(rddata, 20, 16));
+
+	// RAW DLINE_UPD
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, 0xffffffff);
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0A20 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq0 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq1 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A24 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq2 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq3 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A28 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq4 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq5 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A2C + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq6 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+		NOTICE("piwdqlvl_byte%x_dq7 raw delay = %x\n", i, get_bits_from_value(rddata, 22, 16));
+
+		rddata = mmio_rd32(0x0A30 + 0x40 * i + PHYD_BASE_ADDR);
+		NOTICE("piwdqlvl_byte%x_dq8 raw delay = %x\n", i, get_bits_from_value(rddata, 6, 0));
+	}
+#endif //DBG_SHMOO
+}
+
+void cvx16_dll_cal_status(void)
+{
+#ifdef DBG_SHMOO
+	uint32_t err_cnt;
+	uint32_t rx_dll_code;
+	uint32_t tx_dll_code;
+
+	NOTICE("cvx16_dll_cal_status\n");
+	ddr_debug_wr32(0x37);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x3018 + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_rx_dll_code0= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_rx_dll_code1= %x ...\n", get_bits_from_value(rddata, 15, 8));
+	NOTICE("param_phyd_to_reg_rx_dll_code2= %x ...\n", get_bits_from_value(rddata, 23, 16));
+	NOTICE("param_phyd_to_reg_rx_dll_code3= %x ...\n", get_bits_from_value(rddata, 31, 24));
+
+	rddata = mmio_rd32(0x301c + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_rx_dll_max= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_rx_dll_min= %x ...\n", get_bits_from_value(rddata, 15, 8));
+
+	rddata = mmio_rd32(0x3020 + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_tx_dll_code0= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_tx_dll_code1= %x ...\n", get_bits_from_value(rddata, 15, 8));
+	NOTICE("param_phyd_to_reg_tx_dll_code2= %x ...\n", get_bits_from_value(rddata, 23, 16));
+	NOTICE("param_phyd_to_reg_tx_dll_code3= %x ...\n", get_bits_from_value(rddata, 31, 24));
+
+	rddata = mmio_rd32(0x3024 + PHYD_BASE_ADDR);
+	NOTICE("param_phyd_to_reg_tx_dll_max= %x ...\n", get_bits_from_value(rddata, 7, 0));
+	NOTICE("param_phyd_to_reg_tx_dll_min= %x ...\n", get_bits_from_value(rddata, 15, 8));
+
+	err_cnt = 0;
+	rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+	rx_dll_code = get_bits_from_value(rddata, 15, 8);
+	tx_dll_code = get_bits_from_value(rddata, 31, 24);
+#ifdef _mem_freq_2133
+	if (!((rx_dll_code > 0x26) && (rx_dll_code < 0x2b))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x26~0x2b --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x26) && (tx_dll_code < 0x2b))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x26~0x2b --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_3200
+	if (!((rx_dll_code > 0x15) && (rx_dll_code < 0x22))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x15~0x22 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x15) && (tx_dll_code < 0x22))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x15~0x22 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1866
+	if (!((rx_dll_code > 0x2b) && (rx_dll_code < 0x30))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x2b~0x30 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x2b) && (tx_dll_code < 0x30))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x2b~0x30 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1600
+	if (!((rx_dll_code > 0x2a) && (rx_dll_code < 0x44))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x2a~0x44 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x2a) && (tx_dll_code < 0x44))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x2a~0x44 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_2400
+	if (!((rx_dll_code > 0x21) && (rx_dll_code < 0x25))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x21~0x25 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x21) && (tx_dll_code < 0x25))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x21~0x25 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_2666
+	if (!((rx_dll_code > 0x1e) && (rx_dll_code < 0x22))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x1e~0x22 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x1e) && (tx_dll_code < 0x22))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x1e~0x22 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1333
+	if (!((rx_dll_code > 0x3d) && (rx_dll_code < 0x44))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x3e~0x42 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x3d) && (tx_dll_code < 0x44))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x3e~0x42 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+#ifdef _mem_freq_1066
+	if (!((rx_dll_code > 0x4e) && (rx_dll_code < 0x52))) {
+		NOTICE("Info!! rx_dll_code dly_sel result fail, not 0x4e~0x52 --%x--\n", rx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+	if (!((tx_dll_code > 0x4e) && (tx_dll_code < 0x52))) {
+		NOTICE("Info!! tx_dll_code dly_sel result fail, not 0x4e~0x52 --%x--\n", tx_dll_code);
+
+		err_cnt = err_cnt + 1;
+	}
+#endif
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	if (err_cnt != 0x0) {
+		NOTICE("*****************************************\n");
+		NOTICE("DLL_CAL ERR!!! err_cnt = %x...\n", err_cnt);
+		NOTICE("*****************************************\n");
+	} else {
+		NOTICE("*****************************************\n");
+		NOTICE("DLL_CAL PASS!!!\n");
+		NOTICE("*****************************************\n");
+	}
+#endif //DBG_SHMOO
+}
+
+void cvx16_zqcal_status(void)
+{
+	uint32_t zq_drvn;
+	uint32_t zq_drvp;
+
+	uartlog("cvx16_zqcal_status\n");
+	ddr_debug_wr32(0x36);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+	zq_drvn = get_bits_from_value(rddata, 20, 16);
+	zq_drvp = get_bits_from_value(rddata, 28, 24);
+	if ((zq_drvn >= 0x07) && (zq_drvn <= 0x9)) {
+		KC_MSG("ZQ Complete ... param_phya_reg_tx_zq_drvn = %x\n", zq_drvn);
+	} else {
+		KC_MSG("ZQ Complete ... INFO! param_phya_reg_tx_zq_drvn != 0b01000 +- 1, read:value: %x\n",
+		       zq_drvn);
+	}
+	if ((zq_drvp >= 0x07) && (zq_drvp <= 0x9)) {
+		KC_MSG("ZQ Complete ... param_phya_reg_tx_zq_drvp = %x\n", zq_drvp);
+	} else {
+		KC_MSG("ZQ Complete ... INFO! param_phya_reg_tx_zq_drvp != 0b01000 +- 1, read value: %x\n",
+		       zq_drvp);
+	}
+}
+
+void cvx16_training_status(void)
+{
+	uint32_t i;
+
+	uartlog("cvx16_training_status\n");
+	// wrlvl
+	rddata = mmio_rd32(0x0A14 + PHYD_BASE_ADDR);
+	uartlog("byte0 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0A54 + PHYD_BASE_ADDR);
+	uartlog("byte1 tx dqs shift/delay_dqsn/delay_dqsp = %x\n", rddata);
+
+	// rdglvl
+	rddata = mmio_rd32(0x0B0C + PHYD_BASE_ADDR);
+	uartlog("byte0 mask shift/delay = %x\n", rddata);
+
+	rddata = mmio_rd32(0x0B3C + PHYD_BASE_ADDR);
+	uartlog("byte1 mask shift/delay = %x\n", rddata);
+
+	// rdlvl
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3180 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3184 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_rise_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_rise_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_rise_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3188 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_rise_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x318C + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3190 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_rise_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_rise_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_rise_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x3194 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_rise_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x3198 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x319C + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_fall_le = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_fall_le = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_fall_le = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A0 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_fall_le = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		rddata = mmio_rd32(0x31A4 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq0_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq1_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq2_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq3_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31A8 + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq4_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+
+		KC_MSG("rdlvl_byte%x_dq5_fall_te = %x\n", i, get_bits_from_value(rddata, 15, 8));
+
+		KC_MSG("rdlvl_byte%x_dq6_fall_te = %x\n", i, get_bits_from_value(rddata, 23, 16));
+
+		KC_MSG("rdlvl_byte%x_dq7_fall_te = %x\n", i, get_bits_from_value(rddata, 31, 24));
+
+		rddata = mmio_rd32(0x31AC + i * 0x40 + PHYD_BASE_ADDR);
+		KC_MSG("rdlvl_byte%x_dq8_fall_te = %x\n", i, get_bits_from_value(rddata, 7, 0));
+	}
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B00 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x deskewdq3210 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B04 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x deskewdq7654 = %x\n", i, rddata);
+
+		rddata = mmio_rd32(0x0B08 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x rdqspos/neg/deskewdq8 = %x\n", i, rddata);
+	}
+	// rdvld
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B14 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x_rdvld = %x\n", i, get_bits_from_value(rddata, 20, 16));
+	}
+	// trig_lvl
+	for (i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR);
+		uartlog("byte%x trig_lvl_dq = %x, trig_lvl_dqs = %x\n", i, get_bits_from_value(rddata, 4, 0),
+		       get_bits_from_value(rddata, 20, 16));
+	}
+	// wdqlvl
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x3280 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq0_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq1_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3284 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq2_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq3_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3288 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq4_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq5_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x328C + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq6_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq7_le = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3290 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq8_le = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq0_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3294 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq1_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq2_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x3298 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq3_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq4_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x329C + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq5_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq6_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x32A0 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq7_te = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq8_te = %x\n", i, get_bits_from_value(rddata, 29, 16));
+	}
+	// wdq shift
+	for (int i = 0; i < 2; i = i + 1) {
+		rddata = mmio_rd32(0x0A00 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq0 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq1 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A04 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq2 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq3 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A08 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq4 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq5 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A0C + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq6 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+
+		KC_MSG("piwdqlvl_byte%x_dq7 shift/delay = %x\n", i, get_bits_from_value(rddata, 29, 16));
+
+		rddata = mmio_rd32(0x0A10 + 0x40 * i + PHYD_BASE_ADDR);
+		KC_MSG("piwdqlvl_byte%x_dq8 shift/delay = %x\n", i, get_bits_from_value(rddata, 13, 0));
+	}
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	KC_MSG("piwdqlvl tx vref = %x\n", get_bits_from_value(rddata, 20, 16));
+}
+
+void cvx16_setting_check(void)
+{
+	uint32_t dfi_tphy_wrlat;
+	uint32_t dfi_tphy_wrdata;
+	uint32_t dfi_t_rddata_en;
+	uint32_t dfi_t_ctrl_delay;
+	uint32_t dfi_t_wrdata_delay;
+	uint32_t phy_reg_version;
+
+	uartlog("cvx16_setting_check\n");
+	ddr_debug_wr32(0x0a);
+	ddr_debug_num_write();
+	phy_reg_version = mmio_rd32(0x3000 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(cfg_base + 0x190);
+	dfi_tphy_wrlat = get_bits_from_value(rddata, 5, 0); // DFITMG0.dfi_tphy_wrlat
+	dfi_tphy_wrdata = get_bits_from_value(rddata, 13, 8); // DFITMG0.dfi_tphy_wrdata
+	dfi_t_rddata_en = get_bits_from_value(rddata, 22, 16); // DFITMG0.dfi_t_rddata_en
+	dfi_t_ctrl_delay = get_bits_from_value(rddata, 29, 24); // DFITMG0.dfi_t_ctrl_delay
+	rddata = mmio_rd32(cfg_base + 0x194);
+	dfi_t_wrdata_delay = get_bits_from_value(rddata, 20, 16); // DFITMG1.dfi_t_wrdata_delay
+	KC_MSG("phy_reg_version = %x, dfi_t_ctrl_delay = %x, dfi_t_rddata_en = %x\n", phy_reg_version,
+	       dfi_t_ctrl_delay, dfi_t_rddata_en);
+
+	KC_MSG("dfi_tphy_wrlat  = %x, dfi_tphy_wrdata  = %x, dfi_t_wrdata_delay = %x\n", dfi_tphy_wrlat,
+	       dfi_tphy_wrdata, dfi_t_wrdata_delay);
+
+	if (dfi_t_ctrl_delay != 0x4) {
+		KC_MSG("ERR !!! dfi_t_ctrl_delay not 0x4\n");
+	}
+#ifndef DDR2_3
+#ifdef _mem_freq_2133
+	if (dfi_tphy_wrlat != 0x6) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x6\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0xa) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0xa\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#ifdef _mem_freq_1866
+	if (dfi_tphy_wrlat != 0x5) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x5\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0xa) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0xa\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#ifdef _mem_freq_1600
+	if (dfi_tphy_wrlat != 0x4) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x4\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x8) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x8\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#ifdef _mem_freq_1333
+#ifdef ESMT_ETRON_1333
+	if (dfi_tphy_wrlat != 0x4) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x4\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x7) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x7\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#else
+	if (dfi_tphy_wrlat != 0x2) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x2\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x5) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x5\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#endif
+#ifdef _mem_freq_1066
+	if (dfi_tphy_wrlat != 0x2) {
+		KC_MSG("ERR !!! dfi_tphy_wrlat not 0x2\n");
+	}
+	if (dfi_tphy_wrdata != 0x3) {
+		KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+	}
+	if (dfi_t_rddata_en != 0x5) {
+		KC_MSG("ERR !!! dfi_t_rddata_en not 0x5\n");
+	}
+	if (dfi_t_wrdata_delay != 0x7) {
+		KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+	}
+#endif
+#else
+	if (get_ddr_type() == DDR_TYPE_DDR3) {//DDR3:1866
+		if (dfi_tphy_wrlat != 0x5) {
+			KC_MSG("ERR !!! dfi_tphy_wrlat not 0x5\n");
+		}
+		if (dfi_tphy_wrdata != 0x3) {
+			KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+		}
+		if (dfi_t_rddata_en != 0xa) {
+			KC_MSG("ERR !!! dfi_t_rddata_en not 0xa\n");
+		}
+		if (dfi_t_wrdata_delay != 0x7) {
+			KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+		}
+	} else {
+	#ifdef ESMT_ETRON_1333
+		if (dfi_tphy_wrlat != 0x4) {
+			KC_MSG("ERR !!! dfi_tphy_wrlat not 0x4\n");
+		}
+		if (dfi_tphy_wrdata != 0x3) {
+			KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+		}
+		if (dfi_t_rddata_en != 0x7) {
+			KC_MSG("ERR !!! dfi_t_rddata_en not 0x7\n");
+		}
+		if (dfi_t_wrdata_delay != 0x7) {
+			KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+		}
+	#else
+		if (dfi_tphy_wrlat != 0x2) {
+			KC_MSG("ERR !!! dfi_tphy_wrlat not 0x2\n");
+		}
+		if (dfi_tphy_wrdata != 0x3) {
+			KC_MSG("ERR !!! dfi_tphy_wrdata not 0x3\n");
+		}
+		if (dfi_t_rddata_en != 0x5) {
+			KC_MSG("ERR !!! dfi_t_rddata_en not 0x5\n");
+		}
+		if (dfi_t_wrdata_delay != 0x7) {
+			KC_MSG("ERR !!! dfi_t_wrdata_delay not 0x7\n");
+		}
+	#endif
+	}
+#endif
+}
+
+void cvx16_ddr_freq_change_htol(void)
+{
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#if defined(DDR3) || defined(DDR4) || defined(DDR2_3)
+	uint32_t rtt_nom = 0;
+#ifdef DDR4
+	uint32_t rtt_park;
+#endif //DDR4
+	uint32_t rtt_wr = 0;
+	uint32_t mwr_temp;
+#endif //defined(DDR3) || defined(DDR4)
+	uint32_t port_num;
+	// Note: freq_change_htol need ctrl_low_patch first
+	KC_MSG("HTOL Frequency Change Start\n");
+
+	uartlog("cvx16_ddr_freq_change_htol\n");
+	ddr_debug_wr32(0x38);
+	ddr_debug_num_write();
+	// TOP_REG_EN_PLL_SPEED_CHG =1, TOP_REG_NEXT_PLL_SPEED = 0b01, TOP_REG_CUR_PLL_SPEED=0b10
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	// rddata[0]     = 1;        //TOP_REG_EN_PLL_SPEED_CHG
+	// rddata[5:4]   = 0b10;    //TOP_REG_CUR_PLL_SPEED
+	// rddata[9:8]   = 0b01;    //TOP_REG_NEXT_PLL_SPEED
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 2, 5, 4);
+	rddata = modified_bits_by_value(rddata, 1, 9, 8);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	// clock gating disable
+	cvx16_clk_gating_disable();
+	// save lowpower setting
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// en_dfi_dram_clk_disable = rddata[3];
+	// powerdown_en            = rddata[1];
+	// selfref_en              = rddata[0];
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 0 to PCTRL_n.port_en, without port 0
+	// port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+	// 3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+	rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+// 5. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable RTT_NOM:
+//    a. DDR3: Write ????to MR1[9], MR1[6] and MR1[2]
+//    b. DDR4: Write ????to MR1[10:8]
+// 6. For DDR4 only: Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to write ????to
+//    MR5[8:6] to disable RTT_PARK
+// 7. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to write ????to MR2[10:9], to
+//    disable RTT_WR (and therefore disable dynamic ODT). This applies for both DDR3 and DDR4.
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = rddata[10:8];
+	rtt_nom = get_bits_from_value(rddata, 10, 8);
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 11) << 11 | get_bits_from_value(rddata, 7, 0);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], 0b000, rddata[7:0]});
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+	KC_MSG("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// rtt_park = rddata[8:6];
+	rtt_park = get_bits_from_value(rddata, 8, 6);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], 0b000, rddata[5:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 9) << 9 | get_bits_from_value(rddata, 5, 0);
+	cvx16_synp_mrw(0x5, mwr_temp);
+	uartlog("write ????to MR5[8:6] to disable RTT_PARK\n");
+	KC_MSG("write ????to MR5[8:6] to disable RTT_PARK\n");
+
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// rtt_wr = rddata[25:24];
+	rtt_wr = get_bits_from_value(rddata, 25, 24);
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 31, 26) << 10 | get_bits_from_value(rddata, 23, 16);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], 0b00, rddata[23:16]});
+	cvx16_synp_mrw(0x2, mwr_temp);
+	uartlog("write ????to MR2[10:9], to disable RTT_WR\n");
+	KC_MSG("write ????to MR2[10:9], to disable RTT_WR\n");
+
+#endif
+#ifdef DDR3
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+	rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+		  get_bits_from_value(rddata, 2, 2);
+	// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+		   get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+	KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// rtt_wr = rddata[25:24];
+	rtt_wr = get_bits_from_value(rddata, 25, 24);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], 0b00, rddata[23:16]});
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 10 | get_bits_from_value(rddata, 23, 16));
+	uartlog("write ????to MR2[10:9], to disable RTT_WR\n");
+	KC_MSG("write ????to MR2[10:9], to disable RTT_WR\n");
+
+#endif
+#ifdef DDR2
+	KC_MSG("DDR2\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+		rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+			get_bits_from_value(rddata, 2, 2);
+		// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+		mwr_temp = 0;
+		mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+			get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+		cvx16_synp_mrw(0x1, mwr_temp);
+		uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+		KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+
+		// read mr2 @INIT4
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		// rtt_wr = rddata[25:24];
+		rtt_wr = get_bits_from_value(rddata, 25, 24);
+		// cvx16_synp_mrw(0x2,  {rddata[31:26], 0b00, rddata[23:16]});
+		cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 10 | get_bits_from_value(rddata, 23, 16));
+		uartlog("write ????to MR2[10:9], to disable RTT_WR\n");
+		KC_MSG("write ????to MR2[10:9], to disable RTT_WR\n");
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		KC_MSG("DDR2\n");
+	}
+#endif
+	// 20200206
+	//  3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+	rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+// 8. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable the DLL. The timing of
+// this MRS is automatically handled by the uMCTL2.
+// a. DDR3: Write ????to MR1[0]
+// b. DDR4: Write ????to MR1[0]
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1);
+	uartlog("DDR4: Write ????to MR1[0]\n");
+	KC_MSG("DDR4: Write ????to MR1[0]\n");
+
+#endif
+#ifdef DDR3
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	mwr_temp = modified_bits_by_value(rddata, 1, 0, 0);
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+	cvx16_synp_mrw(0x1, mwr_temp);
+#endif
+#ifdef DDR2
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	////read EMR1 @INIT3
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	////DDR2: Write ????to EMR1
+	////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = mmio_rd32(cfg_base + 0x30);
+		// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+		// rddata[1] = 0x0; //PWRCTL.powerdown_en
+		// rddata[0] = 0x0; //PWRCTL.selfref_en
+		rddata = modified_bits_by_value(rddata, 0, 3, 3);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0);
+		mmio_wr32(cfg_base + 0x30, rddata);
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		mwr_temp = modified_bits_by_value(rddata, 1, 0, 0);
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+		cvx16_synp_mrw(0x1, mwr_temp);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		rddata = mmio_rd32(cfg_base + 0x30);
+		// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+		// rddata[1] = 0x0; //PWRCTL.powerdown_en
+		// rddata[0] = 0x0; //PWRCTL.selfref_en
+		rddata = modified_bits_by_value(rddata, 0, 3, 3);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0);
+		mmio_wr32(cfg_base + 0x30, rddata);
+		////read EMR1 @INIT3
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		////DDR2: Write ????to EMR1
+		////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 1);
+	}
+#endif
+	// 9. Put the SDRAM into self-refresh mode by setting PWRCTL.selfref_sw = 1, and polling STAT.operating_
+	// mode to ensure the DDRC has entered self-refresh.
+	// Write 1 to PWRCTL.selfref_sw
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x1; //PWRCTL.selfref_sw
+	// rddata[3] = 0x0; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+// Poll STAT.selfref_type= 2b10
+// Poll STAT.selfref_state = 0b10 (LPDDR4 only)
+#ifndef LP4
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_state = 0b10\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 2) {
+			break;
+		}
+	}
+	// 11. Set the MSTR.dll_off_mode = 1.
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x1;
+	rddata = modified_bits_by_value(rddata, 1, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#else
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type= 2b10\n");
+
+		if ((get_bits_from_value(rddata, 9, 8) == 0x2)) {
+			break;
+		}
+	}
+#endif
+	// Change PLL frequency
+	cvx16_chg_pll_freq();
+	KC_MSG("cvx16_chg_pll_freq done ...\n");
+
+	// test only when dll_cal is not use
+	//     #ifdef DDR3
+	//         //param_phyd_dll_sw_code    <= `PI_SD int_regin[23:16]
+	//         //param_phyd_dll_sw_code_mode    <= `PI_SD int_regin[8];
+	//         REGREAD(169 + PHY_BASE_ADDR, rddata);
+	//         rddata[23:16] = 0x54;
+	//         rddata[8] = 0b1;
+	//         REGWR  (169 + PHY_BASE_ADDR, rddata, 0);
+	uartlog("param_phyd_dll_sw_code\n");
+	//        //param_phyd_dll_sw_clr          <= `PI_SD int_regin[7];
+	//        rddata[7] = 0b1;
+	//        REGWR  (169 + PHY_BASE_ADDR, rddata, 0);
+	//        rddata[7] = 0b0;
+	//        REGWR  (169 + PHY_BASE_ADDR, rddata, 0);
+	//    #endif
+	// dll_cal
+	cvx16_dll_cal();
+	KC_MSG("Do DLLCAL done ...\n");
+
+	// refresh requirement
+	// Program controller
+	rddata = mmio_rd32(cfg_base + 0x64);
+	// rddata[27:16] = rddata[27:17];
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 27, 17), 27, 16);
+	// rddata[9:0] = rddata[9:1] + rddata[0];
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 9, 1) + get_bits_from_value(rddata, 0, 0),
+					9, 0);
+	mmio_wr32(cfg_base + 0x64, rddata);
+	rddata = mmio_rd32(cfg_base + 0x68);
+	// rddata[23:16] = rddata[23:17] + rddata[16];
+	rddata = modified_bits_by_value(
+		rddata, get_bits_from_value(rddata, 23, 17) + get_bits_from_value(rddata, 16, 16), 23, 16);
+	mmio_wr32(cfg_base + 0x68, rddata);
+//    // program phyupd_mask
+//    rddata = mmio_rd32(0x0800a504);
+//    //rddata[27:16] = rddata[27:17] + rddata[16];
+//    rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 27, 17) +
+//                                    get_bits_from_value(rddata, 16, 16), 27, 16);
+//    mmio_wr32(0x0800a504, rddata);
+//    rddata = mmio_rd32(0x0800a500);
+//    //rddata[31:16] = rddata[31:17];
+//    rddata=modified_bits_by_value(rddata, get_bits_from_value(rddata, 31, 17), 31, 16);
+//    mmio_wr32(0x0800a500, rddata);
+#ifndef LP4
+	// 9. Set MSTR.dll_off_mode = 0
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x0;
+	rddata = modified_bits_by_value(rddata, 0, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#endif
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type = 2b00\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 0) {
+			break;
+		}
+	}
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.operating_mode for Normal Mode entry\n");
+
+		if (get_bits_from_value(rddata, 1, 0) == 1) {
+			break;
+		}
+	}
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+	uartlog("DDR4: Write ????to MR1[0]\n");
+	KC_MSG("DDR4: Write ????to MR1[0]\n");
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// opdelay(1).2us; //wait tDLLK ??
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	uartlog("15. Perform an MRS command\n");
+	KC_MSG("15. Perform an MRS command\n");
+
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], rtt_nom[2:0], rddata[7:0]});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 11) << 11 | get_bits_from_value(rtt_nom, 2, 0) << 8 |
+				    get_bits_from_value(rddata, 7, 0));
+	uartlog("enable RTT_NOM\n");
+	KC_MSG("enable RTT_NOM\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], rtt_park[2:0], rddata[5:0]});
+	cvx16_synp_mrw(0x5, get_bits_from_value(rddata, 15, 9) << 9 | get_bits_from_value(rtt_park, 2, 0) << 6 |
+				    get_bits_from_value(rddata, 5, 0));
+	uartlog("enable RTT_PARK\n");
+	KC_MSG("enable RTT_PARK\n");
+
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], rtt_wr[1:0], rddata[23:16]});
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 11 | get_bits_from_value(rtt_wr, 1, 0) << 8 |
+				    get_bits_from_value(rddata, 23, 16));
+	uartlog("enable RTT_WR\n");
+	KC_MSG("enable RTT_WR\n");
+
+#endif
+#ifdef DDR3
+	////read mr1 @INIT3
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	////DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	// read mr2 @INIT4
+	rddata = mmio_rd32(cfg_base + 0xe0);
+	// cvx16_synp_mrw(0x2,  {rddata[31:26], rtt_wr[1:0], rddata[23:16]});
+	cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 11 | get_bits_from_value(rtt_wr, 1, 0) << 8 |
+				    get_bits_from_value(rddata, 23, 16));
+	uartlog("enable RTT_WR\n");
+	KC_MSG("enable RTT_WR\n");
+
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// cvx16_synp_mrw(0x1,
+	//      {rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rtt_nom, 2, 2) << 9 |
+				    get_bits_from_value(rddata, 8, 7) << 7 | get_bits_from_value(rtt_nom, 1, 1) << 5 |
+				    get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rtt_nom, 0, 0) << 2 |
+				    get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+	uartlog("enable RTT_NOM\n");
+	KC_MSG("enable RTT_NOM %x\n", rtt_nom);
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	KC_MSG("15. Perform an MRS command\n");
+
+	// opdelay(2).2us; //don't remove. wait tDLLK ??
+	opdelay(2200);
+#endif
+#ifdef DDR2
+	// reset the DLL
+	// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+	// The uMCTL2 sets this bit appropriately.
+	// read EMR1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	////DDR2: Write ????to EMR1
+	////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	KC_MSG("15. Perform an MRS command\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		////read mr1 @INIT3
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		////DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+		// read mr2 @INIT4
+		rddata = mmio_rd32(cfg_base + 0xe0);
+		// cvx16_synp_mrw(0x2,  {rddata[31:26], rtt_wr[1:0], rddata[23:16]});
+		cvx16_synp_mrw(0x2, get_bits_from_value(rddata, 31, 26) << 11 | get_bits_from_value(rtt_wr, 1, 0) << 8 |
+						get_bits_from_value(rddata, 23, 16));
+		uartlog("enable RTT_WR\n");
+		KC_MSG("enable RTT_WR\n");
+
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// cvx16_synp_mrw(0x1,
+		//      {rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 |
+					get_bits_from_value(rtt_nom, 2, 2) << 9 |
+					get_bits_from_value(rddata, 8, 7) << 7 |
+					get_bits_from_value(rtt_nom, 1, 1) << 5 |
+					get_bits_from_value(rddata, 5, 3) << 3 |
+					get_bits_from_value(rtt_nom, 0, 0) << 2 |
+					get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+		uartlog("enable RTT_NOM\n");
+		KC_MSG("enable RTT_NOM %x\n", rtt_nom);
+
+		// read mr0 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+		// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+		// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+					get_bits_from_value(rddata, 23, 16));
+		KC_MSG("15. Perform an MRS command\n");
+
+		// opdelay(2).2us; //don't remove. wait tDLLK ??
+		opdelay(2200);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		// reset the DLL
+		// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+		// The uMCTL2 sets this bit appropriately.
+		// read EMR1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		////DDR2: Write ????to EMR1
+		////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+					get_bits_from_value(rddata, 23, 16));
+		KC_MSG("15. Perform an MRS command\n");
+	}
+#endif
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	uartlog("restore selfref_en powerdown_en\n");
+#ifdef DDR4
+	rddata = mmio_rd32(0x0b0c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) >> 1), 6, 0);
+	mmio_wr32(0x0b0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0b3c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) >> 1), 6, 0);
+	mmio_wr32(0x0b3c + PHYD_BASE_ADDR, rddata);
+	cvx16_dll_sw_upd();
+#endif
+	uartlog("rdlvl_gate\n");
+	//        KC_MSG("pi_rdlvl_gate_req done ...\n");
+
+	//    #endif
+	cvx16_clk_gating_enable();
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	KC_MSG("HTOL Frequency Change Finished\n");
+}
+
+void cvx16_ddr_freq_change_ltoh(void)
+{
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+#if defined(DDR3) || defined(DDR4) || defined(DDR2_3)
+	uint32_t rtt_nom = 0;
+#ifdef DDR4
+	uint32_t rtt_park;
+#endif //DDR4
+	uint32_t mwr_temp;
+#endif // defined(DDR3) || defined(DDR4)
+
+	uint32_t port_num;
+
+	// Note: freq_change_ltoh need ctrl_low_patch first
+	KC_MSG("LTOH Frequency Change Start\n");
+
+	uartlog("cvx16_ddr_freq_change_ltoh\n");
+	ddr_debug_wr32(0x39);
+	ddr_debug_num_write();
+	// TOP_REG_EN_PLL_SPEED_CHG =1, TOP_REG_NEXT_PLL_SPEED = 0b01, TOP_REG_CUR_PLL_SPEED=0b10
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	// rddata[0]     = 1;        //TOP_REG_EN_PLL_SPEED_CHG
+	// rddata[5:4]   = 0b01;    //TOP_REG_CUR_PLL_SPEED
+	// rddata[9:8]   = 0b10;    //TOP_REG_NEXT_PLL_SPEED
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 5, 4);
+	rddata = modified_bits_by_value(rddata, 2, 9, 8);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	// clock gating disable
+	cvx16_clk_gating_disable();
+	// save lowpower setting
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// en_dfi_dram_clk_disable = rddata[3];
+	//  powerdown_en            = rddata[1];
+	//  selfref_en              = rddata[0];
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// Write 0 to PCTRL_n.port_en, without port 0
+	// port number = 0,1,2,3
+	port_num = 0x4;
+	for (int i = 1; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x0);
+	}
+	// Poll PSTAT.rd_port_busy_n = 0
+	// Poll PSTAT.wr_port_busy_n = 0
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x3fc);
+		KC_MSG("Poll PSTAT.rd_port_busy_n =0\n");
+
+		if (rddata == 0) {
+			break;
+		}
+	}
+// 3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+//   rddata = mmio_rd32(cfg_base + 0x60);
+////rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+//  rddata = modified_bits_by_value(rddata, 1, 0, 0);
+//  mmio_wr32(cfg_base + 0x60, rddata);
+// 5. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable RTT_NOM:
+//    a. DDR3: Write ????to MR1[9], MR1[6] and MR1[2]
+//    b. DDR4: Write ????to MR1[10:8]
+// 6. For DDR4 only: Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to write ????to
+//    MR5[8:6] to disable RTT_PARK
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = rddata[10:8];
+	rtt_nom = get_bits_from_value(rddata, 10, 8);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], 0b000, rddata[7:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 11) << 11 | get_bits_from_value(rddata, 7, 0);
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+	KC_MSG("disable RTT_NOM DDR4: Write ????to MR1[10:8]\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// rtt_park = rddata[8:6];
+	rtt_park = get_bits_from_value(rddata, 8, 6);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], 0b000, rddata[5:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 9) << 9 | get_bits_from_value(rddata, 5, 0);
+	uartlog("write ????to MR5[8:6] to disable RTT_PARK\n");
+	KC_MSG("write ????to MR5[8:6] to disable RTT_PARK\n");
+
+#endif
+#ifdef DDR3
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+	rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+		  get_bits_from_value(rddata, 2, 2);
+	// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+	mwr_temp = 0;
+	mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+		   get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+	cvx16_synp_mrw(0x1, mwr_temp);
+	uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+	KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+
+#endif
+#ifdef DDR2
+	KC_MSG("DDR2\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// rtt_nom = {rddata[9], rddata[6], rddata[2]};
+		rtt_nom = get_bits_from_value(rddata, 9, 9) << 3 | get_bits_from_value(rddata, 6, 6) |
+			get_bits_from_value(rddata, 2, 2);
+		// cvx16_synp_mrw(0x1,  {rddata[15:10], 0b0, rddata[8:7], 0b0, rddata[5:3], 0b0, rddata[1:0]});
+		mwr_temp = 0;
+		mwr_temp = get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rddata, 8, 7) << 7 |
+			get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rddata, 1, 0);
+		cvx16_synp_mrw(0x1, mwr_temp);
+		uartlog("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+		KC_MSG("disable RTT_NOM DDR3: Write ????to MR1[9], MR1[6] and MR1[2]\n");
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		KC_MSG("DDR2\n");
+	}
+#endif
+	// 20200206
+	//  3. Set RFSHCTL3.dis_auto_refresh=1, to disable automatic refreshes
+	rddata = mmio_rd32(cfg_base + 0x60);
+	// rddata[0] = 0x1; //RFSHCTL3.dis_auto_refresh
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+// 8. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to disable the DLL. The timing of
+// this MRS is automatically handled by the uMCTL2.
+// a. DDR3: Write ????to MR1[0]
+// b. DDR4: Write ????to MR1[0]
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 0);
+	uartlog("DDR4: Write ????to MR1[0]\n");
+	KC_MSG("DDR4: Write ????to MR1[0]\n");
+
+#endif
+#ifdef DDR3
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+#endif
+#ifdef DDR2
+	KC_MSG("DDR2\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		KC_MSG("DDR2\n");
+	}
+#endif
+	// 9. Put the SDRAM into self-refresh mode by setting PWRCTL.selfref_sw = 1, and polling STAT.operating_
+	// mode to ensure the DDRC has entered self-refresh.
+	// Write 1 to PWRCTL.selfref_sw
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x1; //PWRCTL.selfref_sw
+	// rddata[3] = 0x1; //PWRCTL.en_dfi_dram_clk_disable
+	// rddata[1] = 0x0; //PWRCTL.powerdown_en
+	// rddata[0] = 0x0; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+// Poll STAT.selfref_type= 2b10
+// Poll STAT.selfref_state = 0b10 (LPDDR4 only)
+#ifndef LP4
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_state = 0b10\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 2) {
+			break;
+		}
+	}
+	// 11. Set the MSTR.dll_off_mode = 1.
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x1;
+	rddata = modified_bits_by_value(rddata, 1, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#else
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type= 2b10\n");
+
+		if (get_bits_from_value(rddata, 9, 8) == 2) {
+			break;
+		}
+	}
+#endif
+	// Change PLL frequency
+	cvx16_chg_pll_freq();
+	KC_MSG("cvx16_chg_pll_freq done ...\n");
+
+	cvx16_dll_cal();
+	// refresh requirement
+	// Program controller
+	rddata = mmio_rd32(cfg_base + 0x64);
+	// rddata[27:16] = {rddata[26:16], 0b0};
+	// rddata[9:0] = {rddata[8:0], 0b0};
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 26, 16) << 1, 27, 16);
+	mmio_wr32(cfg_base + 0x64, rddata);
+	rddata = mmio_rd32(cfg_base + 0x68);
+	// rddata[23:16] = {rddata[22:16], 0b0};
+	rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 22, 16) << 1, 23, 16);
+	mmio_wr32(cfg_base + 0x68, rddata);
+//    // program phyupd_mask
+//    rddata = mmio_rd32(0x0800a504);
+//    //rddata[27:16] = {rddata[26:16],0b0};
+//    rddata=modified_bits_by_value(rddata, get_bits_from_value(rddata, 26, 16)<<1, 27, 16);
+//    mmio_wr32(0x0800a504, rddata);
+//    rddata = mmio_rd32(0x0800a500);
+//    //rddata[31:16] = {rddata[30:16],0b0};
+//    rddata = modified_bits_by_value(rddata, get_bits_from_value(rddata, 30, 16)<<1, 31, 16);
+//    mmio_wr32(0x0800a500, rddata);
+#ifndef LP4
+	// 9. Set MSTR.dll_off_mode = 0
+	rddata = mmio_rd32(cfg_base + 0x0);
+	// rddata[15] = 0x0;
+	rddata = modified_bits_by_value(rddata, 0, 15, 15);
+	mmio_wr32(cfg_base + 0x0, rddata);
+#endif
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.selfref_type = 0b00\n");
+
+		if (get_bits_from_value(rddata, 5, 4) == 0) {
+			break;
+		}
+	}
+	while (1) {
+		rddata = mmio_rd32(cfg_base + 0x4);
+		KC_MSG("Poll STAT.operating_mode for Normal Mode entry\n");
+
+		if (get_bits_from_value(rddata, 1, 0) == 1) {
+			break;
+		}
+	}
+#ifdef DDR4
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// DDR4: Write 1 to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 1) << 1 | 1);
+	uartlog("DDR4: Write 1 to MR1[0]\n");
+	KC_MSG("DDR4: Write 1 to MR1[0]\n");
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// opdelay(0).7us; //wait tDLLK ??
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0,
+		       ((get_bits_from_value(rddata, 31, 25) << 9) | (0b1 << 8) | get_bits_from_value(rddata, 23, 16)));
+	uartlog("15. Perform an MRS command\n");
+	KC_MSG("15. Perform an MRS command\n");
+
+	// 17. Re-enable RTT_PARK (DDR4 only) and RTT_NOM by performing MRS commands (if required).
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// cvx16_synp_mrw(0x1,  {rddata[15:11], rtt_nom[2:0], rddata[7:0]});
+	cvx16_synp_mrw(0x1, ((get_bits_from_value(rddata, 15, 11) << 11) | (get_bits_from_value(rtt_nom, 2, 0) << 8) |
+			     get_bits_from_value(rddata, 7, 0)));
+	uartlog("Re-enable RTT_NOM\n");
+	KC_MSG("Re-enable RTT_NOM\n");
+
+	// read mr5 @INIT6
+	rddata = mmio_rd32(cfg_base + 0xe8);
+	// cvx16_synp_mrw(0x5,  {rddata[15:9], rtt_park[2:0], rddata[5:0]});
+	cvx16_synp_mrw(0x5, ((get_bits_from_value(rddata, 15, 9) << 9) | (get_bits_from_value(rtt_park, 2, 0) << 6) |
+			     get_bits_from_value(rddata, 5, 0)));
+	uartlog("Re-enable RTT_PARK\n");
+	KC_MSG("Re-enable RTT_PARK\n");
+
+#endif
+#ifdef DDR3
+	////read mr1 @INIT3
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	////DDR3: Write ????to MR1[0]
+	// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+	//  17. Re-enable RTT_PARK (DDR4 only) and RTT_NOM by performing MRS commands (if required).
+	// read mr1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	//cvx16_synp_mrw(0x1,
+	//		{rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+	cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 | get_bits_from_value(rtt_nom, 2, 2) << 9 |
+				    get_bits_from_value(rddata, 8, 7) << 7 | get_bits_from_value(rtt_nom, 1, 1) << 5 |
+				    get_bits_from_value(rddata, 5, 3) << 3 | get_bits_from_value(rtt_nom, 0, 0) << 2 |
+				    get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+	uartlog("Re-enable RTT_NOM\n");
+	KC_MSG("Re-enable RTT_NOM\n");
+
+	// read mr0 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+	// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+	// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	opdelay(600); // don't remove. wait tDLLK ??
+#endif
+#ifdef DDR2
+	// reset the DLL
+	// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+	// The uMCTL2 sets this bit appropriately.
+	// read EMR1 @INIT3
+	rddata = mmio_rd32(cfg_base + 0xdc);
+	////DDR2: Write ????to EMR1
+	////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+	// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+	// rddata = mmio_rd32(cfg_base+0xdc);
+	cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 | get_bits_from_value(rddata, 23, 16));
+	KC_MSG("15. Perform an MRS command\n");
+
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		////read mr1 @INIT3
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		////DDR3: Write ????to MR1[0]
+		// cvx16_synp_mrw(0x1,  {rddata[15:1], 0b0});
+		//  17. Re-enable RTT_PARK (DDR4 only) and RTT_NOM by performing MRS commands (if required).
+		// read mr1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		//cvx16_synp_mrw(0x1,
+		//	{rddata[15:10], rtt_nom[2], rddata[8:7], rtt_nom[1], rddata[5:3], rtt_nom[0], rddata[1], 0b0});
+		cvx16_synp_mrw(0x1, get_bits_from_value(rddata, 15, 10) << 10 |
+						get_bits_from_value(rtt_nom, 2, 2) << 9 |
+						get_bits_from_value(rddata, 8, 7) << 7 |
+						get_bits_from_value(rtt_nom, 1, 1) << 5 |
+						get_bits_from_value(rddata, 5, 3) << 3 |
+						get_bits_from_value(rtt_nom, 0, 0) << 2 |
+						get_bits_from_value(rddata, 1, 1) << 1 | 0b0);
+		uartlog("Re-enable RTT_NOM\n");
+		KC_MSG("Re-enable RTT_NOM\n");
+
+		// read mr0 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		// 15. Perform an MRS command (using MRCTRL0 and MRCTRL1 registers) to reset the DLL explicitly by
+		// writing to MR0, bit A8. The timing of this MRS is automatically handled by the uMCTL2
+		// cvx16_synp_mrw(0x0,  {rddata[31:25], 0b1, rddata[23:16]});
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+						get_bits_from_value(rddata, 23, 16));
+		opdelay(600); // don't remove. wait tDLLK ??
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		// reset the DLL
+		// DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.
+		// The uMCTL2 sets this bit appropriately.
+		// read EMR1 @INIT3
+		rddata = mmio_rd32(cfg_base + 0xdc);
+		////DDR2: Write ????to EMR1
+		////cvx16_synp_mrw(0x1,  {rddata[15:1], 0b1});
+		// cvx16_synp_mrw(0x1,  get_bits_from_value(rddata, 15, 1)<<1 | 0);
+		// rddata = mmio_rd32(cfg_base+0xdc);
+		cvx16_synp_mrw(0x0, get_bits_from_value(rddata, 31, 25) << 9 | 0b1 << 8 |
+						get_bits_from_value(rddata, 23, 16));
+		KC_MSG("15. Perform an MRS command\n");
+	}
+#endif
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	rddata = mmio_rd32(cfg_base + 0x30);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3);
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1);
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	uartlog("restore selfref_en powerdown_en\n");
+#ifdef DDR4
+	rddata = mmio_rd32(0x0b0c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) << 1), 6, 0);
+	mmio_wr32(0x0b0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0b3c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, (get_bits_from_value(rddata, 6, 0) << 1), 6, 0);
+	mmio_wr32(0x0b3c + PHYD_BASE_ADDR, rddata);
+	cvx16_dll_sw_upd();
+#endif
+	cvx16_clk_gating_disable();
+	for (int i = 0; i < port_num; i++) {
+		mmio_wr32(cfg_base + 0x490 + 0xb0 * i, 0x1);
+	}
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	//KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	//        rddata[0], rddata[9:8], rddata[5:4]);
+
+	KC_MSG("TOP_REG_EN_PLL_SPEED_CHG = %x, TOP_REG_NEXT_PLL_SPEED = %x, TOP_REG_CUR_PLL_SPEED= %x ...\n",
+	       get_bits_from_value(rddata, 0, 0), get_bits_from_value(rddata, 9, 8), get_bits_from_value(rddata, 5, 4));
+
+	KC_MSG("LTOH Frequency Change Finished\n");
+}
+
+void cvx16_set_dq_vref(uint32_t vref)
+{
+#ifdef DDR4
+	uint32_t en_dfi_dram_clk_disable;
+	uint32_t powerdown_en;
+	uint32_t selfref_en;
+	uint32_t mr6_tmp;
+#endif //DDR4
+	uartlog("cvx16_set_dq_vref\n");
+	ddr_debug_wr32(0x3b);
+	ddr_debug_num_write();
+#ifdef DDR4
+	// save lowpower setting
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// en_dfi_dram_clk_disable = rddata[3];
+	//  powerdown_en            = rddata[1];
+	//  selfref_en              = rddata[0];
+	en_dfi_dram_clk_disable = get_bits_from_value(rddata, 3, 3);
+	powerdown_en = get_bits_from_value(rddata, 1, 1);
+	selfref_en = get_bits_from_value(rddata, 0, 0);
+	rddata = modified_bits_by_value(rddata, 0, 3, 3);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// dis_auto_refresh = 1
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	// read mr6 @INIT7
+	rddata = mmio_rd32(cfg_base + 0xec);
+	rddata = modified_bits_by_value(rddata, vref, 6, 0);
+	mr6_tmp = modified_bits_by_value(rddata, 1, 7, 7);
+	cvx16_synp_mrw(0x6, mr6_tmp);
+	uartlog("vrefDQ Training Enable\n");
+	KC_MSG("vrefDQ Training Enable\n");
+
+	opdelay(150);
+	cvx16_synp_mrw(0x6, mr6_tmp);
+	uartlog("vrefDQ set\n");
+	opdelay(150);
+	mr6_tmp = modified_bits_by_value(mr6_tmp, 0, 7, 7);
+	cvx16_synp_mrw(0x6, mr6_tmp);
+	uartlog("vrefDQ Training disable\n");
+	KC_MSG("vrefDQ Training disable\n");
+
+	opdelay(150);
+	// dis_auto_refresh = 0
+	rddata = mmio_rd32(cfg_base + 0x60);
+	rddata = modified_bits_by_value(rddata, 0, 0, 0);
+	mmio_wr32(cfg_base + 0x60, rddata);
+	// restore
+	rddata = mmio_rd32(cfg_base + 0x30);
+	// rddata[5] = 0x0; //PWRCTL.selfref_sw
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	// rddata[3] = en_dfi_dram_clk_disable; //PWRCTL.en_dfi_dram_clk_disable
+	rddata = modified_bits_by_value(rddata, en_dfi_dram_clk_disable, 3, 3);
+	// rddata[1] = powerdown_en; //PWRCTL.powerdown_en
+	rddata = modified_bits_by_value(rddata, powerdown_en, 1, 1);
+	// rddata[0] = selfref_en; //PWRCTL.selfref_en
+	rddata = modified_bits_by_value(rddata, selfref_en, 0, 0);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	uartlog("restore selfref_en powerdown_en\n");
+#endif
+#ifdef DDR3
+	// f0_param_phya_reg_tx_vref_sel	[20:16]
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, vref, 20, 16);
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+#endif
+#ifdef DDR2
+	// f0_param_phya_reg_tx_vref_sel	[20:16]
+	rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, vref, 20, 16);
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		// f0_param_phya_reg_tx_vref_sel	[20:16]
+		rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref, 20, 16);
+		mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		// f0_param_phya_reg_tx_vref_sel	[20:16]
+		rddata = mmio_rd32(0x0410 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, vref, 20, 16);
+		mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	}
+#endif
+}
+
+void cvx16_set_dfi_init_start(void)
+{
+	// synp setting
+	// phy is ready for initial dfi_init_start request
+	// set umctl2 to tigger dfi_init_start
+	uartlog("cvx16_set_dfi_init_start\n");
+	ddr_debug_wr32(0x0d);
+	ddr_debug_num_write();
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001b0); // dfi_init_start @ rddata[5];
+	rddata = modified_bits_by_value(rddata, 1, 5, 5);
+	mmio_wr32(cfg_base + 0x000001b0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 1);
+	KC_MSG("dfi_init_start finish\n");
+}
+
+void cvx16_ddr_phya_pd(void)
+{
+	uartlog("cvx16_ddr_phya_pd\n");
+	ddr_debug_wr32(0x3d);
+	ddr_debug_num_write();
+	// ----------- PHY oen/pd reset ----------------
+	// OEN
+	// param_phyd_tx_ca_oenz         0
+	// param_phyd_tx_ca_clk0_oenz    8
+	// param_phyd_tx_ca_clk1_oenz    16
+	rddata = 0x00010101;
+	mmio_wr32(0x0130 + PHYD_BASE_ADDR, rddata);
+	// PD
+	// TOP_REG_TX_CA_PD_CA       22	0
+	// TOP_REG_TX_CA_PD_CKE0     24	24
+	// TOP_REG_TX_CLK_PD_CLK0    26	26
+	// TOP_REG_TX_CA_PD_CSB0     28	28
+	// TOP_REG_TX_CA_PD_RESETZ   30	30
+	// TOP_REG_TX_ZQ_PD          31	31
+	// rddata[31:0] = 0x947f_ffff;
+	rddata = 0x947fffff;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("All PHYA CA PD=0 ...\n");
+
+	// TOP_REG_TX_BYTE0_PD	0
+	// TOP_REG_TX_BYTE1_PD	1
+	rddata = 0x00000003;
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TX_BYTE PD=0 ...\n");
+
+	// OEN
+	// param_phyd_sel_cke_oenz        <= `PI_SD int_regin[0];
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	// rddata[0] = 0b1;
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(0x0154 + PHYD_BASE_ADDR, rddata);
+	uartlog("[KC Info] : CKE and RESETZ oenz\n");
+
+	// PD
+	// All PHYA PD=0
+	rddata = 0xffffffff;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	uartlog("[KC Info] : RESETZ CKE PD !!!\n\n");
+
+	// PLL PD
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	// rddata[15]   = 1;    //TOP_REG_DDRPLL_PD
+	rddata = modified_bits_by_value(rddata, 1, 15, 15);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("PLL PD\n");
+
+	// ----------- PHY oen/pd reset ----------------
+}
+
+void cvx16_ddr_phyd_save(uint32_t sram_base_addr)
+{
+	int sram_offset = 0;
+
+	uartlog("cvx16_ddr_phyd_save\n");
+	ddr_debug_wr32(0x46);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xc + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x10 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x14 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x18 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x1c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x20 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x24 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x28 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x2c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x40 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x44 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x48 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x4c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x50 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x54 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x58 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x5c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x60 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x64 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x68 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x70 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x74 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x80 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x84 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x88 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x8c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x90 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x94 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xac + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xbc + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xf0 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xf4 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xf8 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xfc + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x100 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x104 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x10c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x110 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x114 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x118 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x11c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x120 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x124 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x128 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x12c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x130 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x134 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x138 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x140 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x144 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x148 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x14c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x150 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x154 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x158 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x15c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x164 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x168 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x16c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x170 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x174 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x180 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x184 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x188 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x18c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x190 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x200 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x204 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x208 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x220 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x224 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x228 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x400 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x404 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x408 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x40c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x410 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x414 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x418 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x41c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x500 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x504 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x508 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x50c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x510 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x514 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x518 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x51c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x520 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x540 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x544 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x548 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x54c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x550 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x554 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x558 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x55c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x560 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x900 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	// rddata = mmio_rd32(0x904 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x908 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x90c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x910 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x914 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x918 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x91c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x920 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x924 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x928 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	rddata = mmio_rd32(0x92c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x930 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x934 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x938 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x940 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	// rddata = mmio_rd32(0x944 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x948 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x94c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x950 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x954 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x958 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x95c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x960 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x964 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x968 + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	// rddata = mmio_rd32(0x96c + PHYD_BASE_ADDR);
+	// ddr_sram_wr32(sram_base_addr + sram_offset, rddata );
+	//  sram_offset += 4;
+	rddata = mmio_rd32(0x970 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x974 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x978 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x97c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0x980 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa00 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa04 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa08 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa0c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa10 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa14 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa18 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa1c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa20 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa24 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa28 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa2c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa30 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa34 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa38 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa3c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa40 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa44 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa48 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa4c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa50 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa54 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa58 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa5c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa60 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa64 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa68 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa6c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa70 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa74 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa78 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xa7c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb00 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb04 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb08 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb0c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb10 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb14 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb18 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb1c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb20 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb24 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb30 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb34 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb38 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb3c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb40 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb44 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb48 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb4c + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb50 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+	rddata = mmio_rd32(0xb54 + PHYD_BASE_ADDR);
+	ddr_sram_wr32(sram_base_addr + sram_offset, rddata);
+	sram_offset += 4;
+}
+
+void cvx16_ddr_phyd_restore(uint32_t sram_base_addr)
+{
+	int sram_offset = 0x0;
+	{
+		uartlog("cvx16_ddr_phyd_restore\n");
+		ddr_debug_wr32(0x47);
+		ddr_debug_num_write();
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xc + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x10 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x14 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x18 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x1c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x20 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x24 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x28 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x2c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x44 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x48 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x4c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x50 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x54 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x58 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x5c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x60 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x64 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x68 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x70 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x74 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x80 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x84 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x88 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x8c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x90 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x94 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xac + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xbc + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xf0 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xf4 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xf8 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xfc + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x100 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x104 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x10c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x110 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x114 + PHYD_BASE_ADDR, rddata);
+		// reset param_phyd_clkctrl_init_complete
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x118 + PHYD_BASE_ADDR, rddata & 0x00000000);
+		//------------------------------------------------------------
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x11c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x120 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x124 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x128 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x12c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// mmio_wr32    ( 0x130 + PHYD_BASE_ADDR, rddata );
+		// ca oenz set by c-code
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x134 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x138 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x140 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x144 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x148 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x14c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x150 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// param_phyd_sel_cke_oenz=1
+		mmio_wr32(0x154 + PHYD_BASE_ADDR, (rddata | 0x00000001));
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x158 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x15c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x164 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x168 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x16c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x170 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x174 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x180 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x184 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x188 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x18c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x190 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x200 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline =0
+		mmio_wr32(0x204 + PHYD_BASE_ADDR, (rddata & 0xFFFBFFFF));
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x208 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x220 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		// param_phya_reg_tx_byte1_en_extend_oenz_gated_dline =0
+		mmio_wr32(0x224 + PHYD_BASE_ADDR, (rddata & 0xFFFBFFFF));
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x228 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x400 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x404 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x408 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x40c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x410 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x414 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x418 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x41c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x500 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x504 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x508 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x50c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x510 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x514 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x518 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x51c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x520 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x540 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x544 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x548 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x54c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x550 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x554 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x558 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x55c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x560 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x900 + PHYD_BASE_ADDR, rddata);
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x904 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x908 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x90c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x910 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x914 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x918 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x91c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x920 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x924 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x928 + PHYD_BASE_ADDR, rddata );
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x92c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x930 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x934 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x938 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x940 + PHYD_BASE_ADDR, rddata);
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x944 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x948 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x94c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x950 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x954 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x958 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x95c + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x960 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x964 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x968 + PHYD_BASE_ADDR, rddata );
+		// rddata  = mmio_rd32(sram_base_addr + sram_offset);
+		//  sram_offset += 4;
+		// mmio_wr32    ( 0x96c + PHYD_BASE_ADDR, rddata );
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x970 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x974 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x978 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x97c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0x980 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa00 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa04 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa08 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa0c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa10 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa14 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa18 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa1c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa20 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa24 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa28 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa2c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa30 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa34 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa38 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa3c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa44 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa48 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa4c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa50 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa54 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa58 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa5c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa60 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa64 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa68 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa6c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa70 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa74 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa78 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xa7c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb00 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb04 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb08 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb0c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb10 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb14 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb18 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb1c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb20 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb24 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb30 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb34 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb38 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb3c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb40 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb44 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb48 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb4c + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb50 + PHYD_BASE_ADDR, rddata);
+		rddata = mmio_rd32(sram_base_addr + sram_offset);
+		sram_offset += 4;
+		mmio_wr32(0xb54 + PHYD_BASE_ADDR, rddata);
+	}
+}
+
+void cvx16_dll_sw_upd(void)
+{
+	uartlog("cvx16_dll_sw_upd\n");
+	ddr_debug_wr32(0x4B);
+	ddr_debug_num_write();
+	rddata = 0x1;
+	mmio_wr32(0x0170 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		rddata = mmio_rd32(0x302C + PHYD_BASE_ADDR);
+		if (rddata == 0xffffffff) {
+			break;
+		}
+		KC_MSG("DLL SW UPD finish\n");
+	}
+}
+
+void cvx16_bist_mask_shift_delay(uint32_t shift_delay, uint32_t en_lead)
+{
+	uint8_t shift_tmp;
+	uint8_t delay_tmp;
+	uint8_t dlie_sub;
+
+	uartlog("cvx16_bist_mask_shift_delay\n");
+	ddr_debug_wr32(0x4b);
+	ddr_debug_num_write();
+	//{shift_tmp, delay_tmp} = shift_delay;
+	shift_tmp = get_bits_from_value(shift_delay, 12, 7);
+	delay_tmp = get_bits_from_value(shift_delay, 6, 0);
+	if (shift_tmp > en_lead) {
+		dlie_sub = shift_tmp - en_lead;
+	} else {
+		dlie_sub = 0;
+	}
+	rddata = 0x00000000;
+	rddata = shift_tmp << 8 | delay_tmp;
+	mmio_wr32(0x0B0C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0B3C + PHYD_BASE_ADDR, rddata);
+	rddata = 0x00000000;
+	rddata = dlie_sub << 24 | dlie_sub << 8;
+	mmio_wr32(0x0B10 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0B40 + PHYD_BASE_ADDR, rddata);
+	cvx16_dll_sw_clr();
+	KC_MSG("cvx16_bist_mask_shift_delay Fisish\n");
+}
+
+void cvx16_set_dq_trig_lvl(uint32_t trig_lvl)
+{
+	uartlog("cvx16_set_dq_trig_lvl\n");
+	ddr_debug_wr32(0x4c);
+	ddr_debug_num_write();
+	rddata = 0x00000000;
+	rddata = trig_lvl << 16 | trig_lvl;
+	mmio_wr32(0x0B24 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0B54 + PHYD_BASE_ADDR, rddata);
+}
+
+void cvx16_pll_init(void)
+{
+	// opdelay(10);
+	uartlog("pll_init\n");
+	ddr_debug_wr32(0x00);
+	ddr_debug_num_write();
+	// TX_VREF_PD
+	rddata = 0x00000000;
+	mmio_wr32(0x28 + CV_DDR_PHYD_APB, rddata);
+	// ZQ_240 OPTION
+	rddata = 0x00080001;
+	mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+#ifdef DDR3
+// GPO setting
+#ifdef _mem_freq_2133
+	rddata = 0x01000808; // TOP_REG_TX_DDR3_GPO_IN =0
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+#else
+	rddata = 0x01010808; // TOP_REG_TX_DDR3_GPO_IN =1
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+#endif
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		rddata = 0x01010808; // TOP_REG_TX_DDR3_GPO_IN =1
+		mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	}
+#endif
+#ifdef SSC_EN
+	//==============================================================
+	// Enable SSC
+	//==============================================================
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	KC_MSG("reg_step = %lx\n", reg_step);
+
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 1, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // extpulse
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_EN\n");
+#else
+#ifdef SSC_BYPASS
+	rddata = (reg_set & 0xfc000000) + 0x04000000; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 1, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_BYPASS\n");
+#else
+	//==============================================================
+	// SSC_EN =0
+	//==============================================================
+	uartlog("SSC_EN =0\n");
+	rddata = reg_set; // TOP_REG_SSC_SET
+	mmio_wr32(0x54 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_span, 15, 0); // TOP_REG_SSC_SPAN
+	mmio_wr32(0x58 + 0x03002900, rddata);
+	rddata = get_bits_from_value(reg_step, 23, 0); // TOP_REG_SSC_STEP
+	mmio_wr32(0x5C + 0x03002900, rddata);
+	rddata = mmio_rd32(0x50 + 0x03002900);
+	rddata = modified_bits_by_value(rddata, ~get_bits_from_value(rddata, 0, 0), 0, 0); // TOP_REG_SSC_SW_UP
+	rddata = modified_bits_by_value(rddata, 0, 1, 1); // TOP_REG_SSC_EN_SSC
+	rddata = modified_bits_by_value(rddata, 0, 3, 2); // TOP_REG_SSC_SSC_MODE
+	rddata = modified_bits_by_value(rddata, 0, 4, 4); // TOP_REG_SSC_BYPASS
+	rddata = modified_bits_by_value(rddata, 1, 5, 5); // TOP_REG_SSC_EXTPULSE
+	rddata = modified_bits_by_value(rddata, 0, 6, 6); // ssc_syn_fix_div
+	mmio_wr32(0x50 + 0x03002900, rddata);
+	uartlog("SSC_OFF\n");
+#endif // SSC_BYPASS
+#endif // SSC_EN
+	// opdelay(1000);
+	// DDRPLL setting
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	//[0]    = 1;      //TOP_REG_DDRPLL_EN_DLLCLK
+	//[1]    = 1;      //TOP_REG_DDRPLL_EN_LCKDET
+	//[2]    = 0;      //TOP_REG_DDRPLL_EN_TST
+	//[5:3]  = 0b001; //TOP_REG_DDRPLL_ICTRL
+	//[6]    = 0;      //TOP_REG_DDRPLL_MAS_DIV_SEL
+	//[7]    = 0;      //TOP_REG_DDRPLL_MAS_RSTZ_DIV
+	//[8]    = 1;      //TOP_REG_DDRPLL_SEL_4BIT
+	//[10:9] = 0b01;  //TOP_REG_DDRPLL_SEL_MODE
+	//[12:11]= 0b00;  //Rev
+	//[13]   = 0;      //TOP_REG_DDRPLL_SEL_LOW_SPEED
+	//[14]   = 0;      //TOP_REG_DDRPLL_MAS_DIV_OUT_SEL
+	//[15]   = 0;      //TOP_REG_DDRPLL_PD
+	rddata = modified_bits_by_value(rddata, 0x030b, 15, 0);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+	//[7:0] = 0x0;   //TOP_REG_DDRPLL_TEST
+	rddata = modified_bits_by_value(rddata, 0, 7, 0); // TOP_REG_DDRPLL_TEST
+	mmio_wr32(0x10 + CV_DDR_PHYD_APB, rddata);
+	//[0]   = 1;    //TOP_REG_RESETZ_DIV
+	rddata = 0x1;
+	mmio_wr32(0x04 + CV_DDR_PHYD_APB, rddata);
+	uartlog("RSTZ_DIV=1\n");
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	//[7]   = 1;    //TOP_REG_DDRPLL_MAS_RSTZ_DIV
+	rddata = modified_bits_by_value(rddata, 1, 7, 7);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("Wait for DRRPLL LOCK=1... pll init\n");
+
+	uartlog("Start DRRPLL LOCK pll init\n");
+#ifdef REAL_LOCK
+	while (1) {
+		rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+		if (get_bits_from_value(rddata, 15, 15)) {
+			break;
+		}
+	}
+#else
+	KC_MSG("check PLL lock...  pll init\n");
+
+#endif
+	uartlog("End DRRPLL LOCK=1... pll init\n");
+	KC_MSG("PLL init finish !!!\n");
+}
+
+void cvx16_lb_0_phase40(void)
+{
+	uint32_t i, j;
+
+	KC_MSG("DQ loop back test -IO internal loop back-\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_0\n");
+	ddr_debug_wr32(0x4F);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	rddata = 0x00404000;
+	for (j = 0; j < 2; j = j + 1) {
+		mmio_wr32(0x0B08 + j * 0x30 + PHYD_BASE_ADDR, rddata);
+	}
+	KC_MSG("rddata= %x\n", rddata);
+
+	cvx16_dll_sw_upd();
+	rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_lb_dq_en
+	rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	rddata = modified_bits_by_value(rddata, 1, 1, 1); // param_phyd_lb_dq_go
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("wait for param_phyd_to_reg_lb_dq0_doing\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq1_doing\n");
+
+	while (1) {
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 1, 0) == 0x3) {
+			break;
+		}
+	}
+	KC_MSG("param_phyd_to_reg_lb_dq0_doing = 1\n");
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_doing = 1\n");
+
+	uartlog("\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq0_syncfound\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq1_syncfound\n");
+
+	while (1) {
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 9, 8) == 0x3) {
+			break;
+		}
+	}
+	KC_MSG("param_phyd_to_reg_lb_dq0_syncfound = 1\n");
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_syncfound = 1\n");
+
+	uartlog("\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq0_startfound\n");
+
+	KC_MSG("wait for param_phyd_to_reg_lb_dq1_startfound\n");
+
+	while (1) {
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 17, 16) == 0x3) {
+			break;
+		}
+	}
+	KC_MSG("param_phyd_to_reg_lb_dq0_startfound = 1\n");
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_startfound = 1\n");
+
+	// opdelay(1000);
+	// Read param_phyd_to_reg_lb_dq_fail
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+	uartlog("\n");
+
+	if (get_bits_from_value(rddata, 25, 24) != 0) {
+		KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+	}
+	// opdelay(1000);
+	// Read param_phyd_to_reg_lb_dq_fail
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+	uartlog("\n");
+
+	if (get_bits_from_value(rddata, 25, 24) != 0) {
+		KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+	}
+	// opdelay(1000);
+	// Read param_phyd_to_reg_lb_dq_fail
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+	KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+	uartlog("\n");
+
+	if (get_bits_from_value(rddata, 25, 24) != 0) {
+		KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+	}
+	uartlog("lb0 runing\n");
+}
+
+void cvx16_lb_0_external(void)
+{
+	uint32_t i, j;
+
+	KC_MSG("DQ loop back test - with front-} (Drivier / Receiver)-\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_0_external\n");
+	ddr_debug_wr32(0x4F);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	rddata = 0x00000000;
+	for (i = 0x00404000; i <= 0x00505000; i = i + 0x00101000) {
+		if (i == 0x00808000) {
+			rddata = 0x007f7f00;
+		} else {
+			rddata = i;
+		}
+		for (j = 0; j < 2; j = j + 1) {
+			mmio_wr32(0x0B08 + j * 0x30 + PHYD_BASE_ADDR, rddata);
+		}
+		KC_MSG("rddata= %x\n", rddata);
+
+		cvx16_dll_sw_upd();
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 1, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_doing\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_doing\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 1, 0) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_doing = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_doing = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_syncfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_syncfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 9, 8) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_syncfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_syncfound = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_startfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_startfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 17, 16) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_startfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_startfound = 1\n");
+
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail i Found ...\n");
+		}
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	}
+
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	// repeat(50) @(posedge axi3_ACLK);
+	uartlog("PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_1_dq_set_highlow(void)
+{
+	uint32_t i;
+	uint32_t pattern;
+
+	KC_MSG("DQ set highlow test\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_1_dq_set_highlow\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x0400001C;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_lb_sw_oenz_dout0      0
+	// param_phyd_lb_sw_oenz_dout1      1
+	// param_phyd_lb_sw_dqsn0           4
+	// param_phyd_lb_sw_dqsn1           5
+	// param_phyd_lb_sw_dqsp0           8
+	// param_phyd_lb_sw_dqsp1           9
+	// param_phyd_lb_sw_oenz_dqs_dout0  12
+	// param_phyd_lb_sw_oenz_dqs_dout1  13
+	rddata = 0x00003333;
+	mmio_wr32(0x010C + PHYD_BASE_ADDR, rddata);
+	// pattern all 0
+	rddata = 0x00000000;
+	mmio_wr32(0x0104 + PHYD_BASE_ADDR, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+	if (get_bits_from_value(rddata, 8, 0) != 0x000) {
+		KC_MSG("Error!!! RX loop back din0[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din0[8:0] is Pass..\n");
+	}
+	if (get_bits_from_value(rddata, 24, 16) != 0x000) {
+		KC_MSG("Error!!! RX loop back din1[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din1[8:0] is Pass..\n");
+	}
+	// pattern all 1
+	rddata = 0x01ff01ff;
+	mmio_wr32(0x0104 + PHYD_BASE_ADDR, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+	if (get_bits_from_value(rddata, 8, 0) != 0x1ff) {
+		KC_MSG("Error!!! RX loop back din0[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din0[8:0] is Pass..\n");
+	}
+	if (get_bits_from_value(rddata, 24, 16) != 0x1ff) {
+		KC_MSG("Error!!! RX loop back din1[8:0] is not correct...\n");
+	} else {
+		KC_MSG("Pass!!! RX loop back din1[8:0] is Pass..\n");
+	}
+	// pattern one hot
+	pattern = 0x1;
+	for (i = 0; i < 22; i = i + 1) {
+		uartlog("[DBG] YD, i= %x, pattern =%x\n", i, pattern);
+
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 8, 0), 8, 0);
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 17, 9), 24, 16);
+		mmio_wr32(0x0104 + PHYD_BASE_ADDR, rddata);
+		if (i < 18) {
+			rddata = mmio_rd32(0x010C + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, 0x3, 5, 4);
+			rddata = modified_bits_by_value(rddata, 0x3, 9, 8);
+			mmio_wr32(0x010C + PHYD_BASE_ADDR, rddata);
+		} else {
+			rddata = mmio_rd32(0x010C + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 19, 18), 5, 4);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(pattern, 21, 20), 9, 8);
+		}
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 8, 0) != get_bits_from_value(pattern, 8, 0)) {
+			KC_MSG("Error!!! RX loop back din0[8:0] is not correct...\n");
+		} else {
+			KC_MSG("Pass!!! RX loop back din0[8:0] is Pass..\n");
+		}
+		if (get_bits_from_value(rddata, 24, 16) != get_bits_from_value(pattern, 17, 9)) {
+			KC_MSG("Error!!! RX loop back din1[8:0] is not correct...\n");
+		} else {
+			KC_MSG("Pass!!! RX loop back din1[8:0] is Pass..\n");
+		}
+		pattern = pattern << 1;
+	}
+	i = 0;
+	pattern = 0x1;
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000000;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	uartlog("LB_1 PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_2_mux_demux(void)
+{
+	uint32_t i, j;
+
+	KC_MSG("DQ loop back test 2 -DEMUX/MUX internal loop back-\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_2_mux_demux\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00004440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	rddata = 0x00000000;
+	for (i = 0x00404000; i <= 0x00404000; i = i + 0x00101000) {
+		if (i == 0x00808000) {
+			rddata = 0x007f7f00;
+		} else {
+			rddata = i;
+		}
+		for (j = 0; j < 2; j = j + 1) {
+			mmio_wr32(0x0B08 + j * 0x30 + PHYD_BASE_ADDR, rddata);
+		}
+		KC_MSG("rddata= %x\n", rddata);
+
+		cvx16_dll_sw_upd();
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 1, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_doing\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_doing\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 1, 0) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_doing = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_doing = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_syncfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_syncfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 9, 8) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_syncfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_syncfound = 1\n");
+
+		uartlog("\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq0_startfound\n");
+
+		KC_MSG("wait for param_phyd_to_reg_lb_dq1_startfound\n");
+
+		while (1) {
+			// opdelay(1000);
+			rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+			if (get_bits_from_value(rddata, 17, 16) == 0x3) {
+				break;
+			}
+		}
+		KC_MSG("param_phyd_to_reg_lb_dq0_startfound = 1\n");
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_startfound = 1\n");
+
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		// opdelay(1000);
+		// Read param_phyd_to_reg_lb_dq_fail
+		rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+		KC_MSG("param_phyd_to_reg_lb_dq0_fail = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		KC_MSG("param_phyd_to_reg_lb_dq1_fail = %x\n", get_bits_from_value(rddata, 25, 25));
+
+		uartlog("\n");
+
+		if (get_bits_from_value(rddata, 25, 24) != 0) {
+			KC_MSG("Error!!! DQ BIST Fail is Found ...\n");
+		}
+		rddata = mmio_rd32(0x0100 + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 0, 0, 0); // param_phyd_lb_dq_en
+		rddata = modified_bits_by_value(rddata, 0, 2, 2); // param_phyd_lb_sw_en for CA
+		rddata = modified_bits_by_value(rddata, 0x400, 31, 16); // param_phyd_lb_sync_len
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+		rddata = modified_bits_by_value(rddata, 0, 1, 1); // param_phyd_lb_dq_go
+		mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	}
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	// repeat(50) @(posedge axi3_ACLK);
+	uartlog("PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_3_ca_set_highlow(void)
+{
+	uint32_t i;
+	uint32_t pattern;
+	uint32_t rddata_addr;
+	uint32_t rddata_ctrl;
+
+	KC_MSG("CA set highlow test\n");
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_3_ca_set_highlow\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000004;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0134 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x1, 2, 2); // param_phya_reg_tx_ca_en_ca_loop_back
+	mmio_wr32(0x0134 + PHYD_BASE_ADDR, rddata);
+	// GPO
+	// TOP_REG_TX_DDR3_GPO_DRVN	    [4:	    0]
+	// TOP_REG_TX_DDR3_GPO_DRVP	    [12:	8]
+	// TOP_REG_TX_DDR3_GPO_IN	    [16:	16]
+	// TOP_REG_TX_DDR3_GPO_OENZ	    [17:	17]
+	// TOP_REG_TX_DDR3_GPO_PD_GPO	[18:	18]
+	// TOP_REG_TX_DDR3_GPO_SEL_GPIO	[19:	19]
+	rddata = 0x01010808; // TOP_REG_TX_DDR3_GPO_IN =1
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x58 + CV_DDR_PHYD_APB);
+	if (get_bits_from_value(rddata, 28, 28) != 0x1) {
+		KC_MSG("Error!!! GPO test Fail\n");
+	} else {
+		KC_MSG("Pass!!! GPO test pass\n");
+	}
+	rddata = 0x01000808; // TOP_REG_TX_DDR3_GPO_IN =0
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x58 + CV_DDR_PHYD_APB);
+	if (get_bits_from_value(rddata, 28, 28) != 0x0) {
+		KC_MSG("Error!!! GPO test Fail\n");
+	} else {
+		KC_MSG("Pass!!! GPO test pass\n");
+	}
+	// pattern all 0
+	rddata_addr = 0x00000000;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00000000;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [16:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern all 1
+	rddata_addr = 0x007fffff;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00010011;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern 01
+	rddata_addr = 0x00555555;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00000010;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern 10
+	rddata_addr = 0x002aaaaa;
+	mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr); // param_phyd_lb_sw_ca_dout
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata_ctrl = 0x00010001;
+	mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != rddata_addr) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if (rddata != rddata_ctrl) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// pattern one hot
+	pattern = 0x1;
+	for (i = 0; i < 25; i = i + 1) {
+		uartlog("[DBG] YD, i= %x, pattern =%x\n", i, pattern);
+
+		rddata_addr = 0x00000000;
+		rddata_addr = modified_bits_by_value(rddata_addr, get_bits_from_value(pattern, 22, 0), 22, 0);
+		mmio_wr32(0x0110 + PHYD_BASE_ADDR, rddata_addr);
+		// param_phyd_lb_sw_clkn0_dout   0
+		// param_phyd_lb_sw_clkp0_dout   4
+		// param_phyd_lb_sw_cke0_dout    8
+		// param_phyd_lb_sw_resetz_dout  12
+		// param_phyd_lb_sw_csb0_dout    16
+		rddata_ctrl = 0x00000000;
+		rddata_ctrl = modified_bits_by_value(rddata_ctrl, get_bits_from_value(pattern, 23, 23), 0, 0);
+		rddata_ctrl = modified_bits_by_value(rddata_ctrl, get_bits_from_value(pattern, 24, 24), 4, 4);
+		rddata_ctrl = modified_bits_by_value(rddata_ctrl, get_bits_from_value(pattern, 25, 25), 16, 16);
+		mmio_wr32(0x0114 + PHYD_BASE_ADDR, rddata_ctrl);
+		// opdelay(1000);
+		rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+		if (rddata != rddata_addr) {
+			KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+		} else {
+			KC_MSG("Pass!!! CA[22:0] is Pass..\n");
+		}
+		rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+		if (rddata != rddata_ctrl) {
+			KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+		} else {
+			KC_MSG("Pass!!! other pin [8:0]\n");
+		}
+		pattern = pattern << 1;
+	}
+	i = 0;
+	pattern = 0x1;
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000000;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	uartlog("LB_3 PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_lb_4_ca_clk_pat(void)
+{
+	uint32_t i;
+	// uint32_t pattern; //unused
+	// uint32_t rddata_addr; //unused
+	// uint32_t rddata_ctrl; //unused
+	KC_MSG("%s test\n", __func__);
+
+	// Disable controller update for synopsys
+	mmio_wr32(cfg_base + 0x00000320, 0x00000000);
+	rddata = mmio_rd32(cfg_base + 0x000001a0);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x000001a0, rddata);
+	mmio_wr32(cfg_base + 0x00000320, 0x00000001);
+	uartlog("cvx16_lb_4_ca_clk_pat\n");
+	ddr_debug_wr32(0x50);
+	ddr_debug_num_write();
+	cvx16_clk_gating_disable();
+	KC_MSG("cvx16_clk_gating_disable\n");
+
+	// param_phya_reg_sel_ddr4_mode    0
+	// param_phya_reg_sel_lpddr3_mode  1
+	// param_phya_reg_sel_lpddr4_mode  2
+	// param_phya_reg_sel_ddr3_mode    3
+	// param_phya_reg_sel_ddr2_mode    4
+	rddata = 0x00000008;
+	mmio_wr32(0x004C + PHYD_BASE_ADDR, rddata);
+	// param_phyd_dram_class
+	// DRAM class DDR2: 0b0100, DDR3: 0b0110, DDR4: 0b1010, LPDDR3: 0b0111, LPDDR4: 0b1011
+	rddata = 0x00000006;
+	mmio_wr32(0x0050 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("dram_class = %x\n", rddata);
+
+	// DDR tx vref on
+	rddata = 0x00100000;
+	// param_phya_reg_tx_vref_sel [20:16]
+	mmio_wr32(0x0410 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_vrefca_sel [20:16]
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("DDR tx vref on\n");
+
+	// TOP_REG_TX_VREF_PD/TOP_REG_TX_VREFCA_PD
+	rddata = 0x00000000;
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	KC_MSG("VREF_PD =0\n");
+
+	// param_phya_reg_tx_zq_drvn,param_phya_reg_tx_zq_drvp
+	rddata = 0x08080808;
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// CA DRVP/DRVN 0x08
+	rddata = 0x08080808;
+	mmio_wr32(0x097C + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0980 + PHYD_BASE_ADDR, rddata);
+	for (i = 0; i < 2; i = i + 1) {
+		// DRVP/DRVN 0x08
+		rddata = 0x08080808;
+		mmio_wr32(0x0A38 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A3C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// Reset TX delay line to zero
+		rddata = 0x06000600;
+		mmio_wr32(0x0A00 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A04 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A08 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A0C + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0A10 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// trig_lvl_dq
+		rddata = 0x00100010;
+		mmio_wr32(0x0B24 + i * 0x30 + PHYD_BASE_ADDR, rddata);
+		// sel_odt_center_tap
+		rddata = mmio_rd32(0x0500 + i * 0x40 + PHYD_BASE_ADDR);
+		// if odt on
+		// rddata = modified_bits_by_value(rddata, 1, 10, 10 );
+		mmio_wr32(0x0500 + i * 0x40 + PHYD_BASE_ADDR, rddata);
+		// param_phya_reg_tx_byte0_en_rx_awys_on   [0 :0 ]
+		// param_phya_reg_tx_byte0_sel_en_rx_dly    [5 :4 ]
+		// param_phya_reg_rx_byte0_sel_en_rx_gen_rst   [6 :6 ]
+		// param_phya_reg_byte0_mask_oenz   [8 :8 ]
+		// param_phya_reg_tx_byte0_en_mask   [10 :10 ]
+		// param_phya_reg_rx_byte0_sel_cnt_mode   [13 :12 ]
+		// param_phya_reg_tx_byte0_sel_int_loop_back    [14 :14 ]
+		// param_phya_reg_rx_byte0_sel_dqs_dly_for_gated   [17 :16 ]
+		// param_phya_reg_tx_byte0_en_extend_oenz_gated_dline   [18 :18 ]
+		rddata = 0x00000440;
+		mmio_wr32(0x0204 + i * 0x20 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("reg 0204 data = %x\n", rddata);
+	}
+	// ODT OFF
+	rddata = 0x00000000;
+	mmio_wr32(0x041C + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_rx_en_ca_train_mode
+	// rddata = mmio_rd32(0x0138 + PHYD_BASE_ADDR);
+	// rddata = modified_bits_by_value(rddata, 1, 0, 0 );
+	// mmio_wr32(0x0138 + PHYD_BASE_ADDR,  rddata);
+	// CKE/RESETN
+	rddata = 0x00000067; // TOP_REG_TX_CA_SEL_GPIO_CKE0  [2] = 1
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	rddata = 0x40000000; // TOP_REG_TX_CA_PD_RESETZ [30] = 1
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000044;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0134 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x1, 2, 2); // param_phya_reg_tx_ca_en_ca_loop_back
+	mmio_wr32(0x0134 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_ca_en_tx_de     24
+	// param_phya_reg_tx_clk0_en_tx_de   28
+	// param_phya_reg_tx_csb_en_tx_de    30
+	rddata = 0x51000000;
+	mmio_wr32(0x0404 + PHYD_BASE_ADDR, rddata);
+	// clock pattern
+	// opdelay(1000);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	if (rddata != 0x007fffff) {
+		KC_MSG("Error!!! CA BIST Fail is Found : CA[22:0] pin\n");
+	} else {
+		KC_MSG("Pass!!! CA[22:0] pin\n");
+	}
+	// param_phyd_lb_sw_clkn0_dout	0
+	// param_phyd_lb_sw_clkp0_dout	4
+	// param_phyd_lb_sw_cke0_dout	8
+	// param_phyd_lb_sw_resetz_dout	12
+	// param_phyd_lb_sw_csb0_dout	16
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	if ((rddata & 0x00010011) != 0x00010011) {
+		KC_MSG("Error!!! CA BIST Fail is Found : other pin [8:0] test\n");
+	} else {
+		KC_MSG("Pass!!! other pin is Pass..\n");
+	}
+	// param_phyd_lb_dq_en            [0:     0]
+	// param_phyd_lb_dq_go            [1:     1]
+	// param_phyd_lb_sw_en            [2:     2]
+	// param_phyd_lb_sw_rx_en         [3:     3]
+	// param_phyd_lb_sw_rx_mask       [4:     4]
+	// param_phyd_lb_sw_odt_en        [5:     5]
+	// param_phyd_lb_sw_ca_clkpattern [6:     6]
+	// param_phyd_lb_sync_len         [31:   16]
+	rddata = 0x04000000;
+	mmio_wr32(0x0100 + PHYD_BASE_ADDR, rddata);
+	/***************************************************************
+	 *      FINISHED!
+	 ***************************************************************/
+	uartlog("LB_4 PATTERN RAN TO COMPLETION\n");
+}
+
+void cvx16_clk_gating_disable(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x4C);
+	ddr_debug_num_write();
+	// TOP_REG_CG_EN_PHYD_TOP      0
+	// TOP_REG_CG_EN_CALVL         1
+	// TOP_REG_CG_EN_WRLVL         2
+	// N/A                         3
+	// TOP_REG_CG_EN_WRDQ          4
+	// TOP_REG_CG_EN_RDDQ          5
+	// TOP_REG_CG_EN_PIGTLVL       6
+	// TOP_REG_CG_EN_RGTRACK       7
+	// TOP_REG_CG_EN_DQSOSC        8
+	// TOP_REG_CG_EN_LB            9
+	// TOP_REG_CG_EN_DLL_SLAVE     10 //0:a-on
+	// TOP_REG_CG_EN_DLL_MST       11 //0:a-on
+	// TOP_REG_CG_EN_ZQ            12
+	// TOP_REG_CG_EN_PHY_PARAM     13 //0:a-on
+	// 0b01001011110101
+	rddata = 0x000012F5;
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	rddata = 0x00000000;
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, rddata); // PHYD_SHIFT_GATING_EN
+	rddata = mmio_rd32(cfg_base + 0x30); // phyd_stop_clk
+	rddata = modified_bits_by_value(rddata, 0, 9, 9);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	rddata = mmio_rd32(cfg_base + 0x148); // dfi read/write clock gatting
+	rddata = modified_bits_by_value(rddata, 0, 23, 23);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(cfg_base + 0x148, rddata);
+	KC_MSG("clk_gating_disable\n");
+
+	// disable clock gating
+	// mmio_wr32(0x0800_a000 + 0x14 , 0x00000fff);
+	// KC_MSG("axi disable clock gating\n");
+}
+
+void cvx16_clk_gating_enable(void)
+{
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x4D);
+	ddr_debug_num_write();
+	// TOP_REG_CG_EN_PHYD_TOP      0
+	// TOP_REG_CG_EN_CALVL         1
+	// TOP_REG_CG_EN_WRLVL         2
+	// N/A                         3
+	// TOP_REG_CG_EN_WRDQ          4
+	// TOP_REG_CG_EN_RDDQ          5
+	// TOP_REG_CG_EN_PIGTLVL       6
+	// TOP_REG_CG_EN_RGTRACK       7
+	// TOP_REG_CG_EN_DQSOSC        8
+	// TOP_REG_CG_EN_LB            9
+	// TOP_REG_CG_EN_DLL_SLAVE     10 //0:a-on
+	// TOP_REG_CG_EN_DLL_MST       11 //0:a-on
+	// TOP_REG_CG_EN_ZQ            12
+	// TOP_REG_CG_EN_PHY_PARAM     13 //0:a-on
+	// 0b10110010000001
+	rddata = 0x00002C81;
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	//    #ifdef _mem_freq_1333
+	//    #ifdef DDR2
+	rddata = mmio_rd32(cfg_base + 0x190);
+	rddata = modified_bits_by_value(rddata, 6, 28, 24);
+	mmio_wr32(cfg_base + 0x190, rddata);
+	//    #endif
+	rddata = 0x00030033;
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, rddata); // PHYD_SHIFT_GATING_EN
+	rddata = mmio_rd32(cfg_base + 0x30); // phyd_stop_clk
+	rddata = modified_bits_by_value(rddata, 1, 9, 9);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	rddata = mmio_rd32(cfg_base + 0x148); // dfi read/write clock gatting
+	rddata = modified_bits_by_value(rddata, 1, 23, 23);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(cfg_base + 0x148, rddata);
+	KC_MSG("clk_gating_enable\n");
+
+	// disable clock gating
+	// mmio_wr32(0x0800_a000 + 0x14 , 0x00000fff);
+	// KC_MSG("axi disable clock gating\n");
+}
+
+void cvx16_dfi_phyupd_req(void)
+{
+	uint32_t ca_raw_upd;
+	uint32_t byte0_wr_raw_upd;
+	uint32_t byte1_wr_raw_upd;
+	uint32_t byte0_wdqs_raw_upd;
+	uint32_t byte1_wdqs_raw_upd;
+	uint32_t byte0_rd_raw_upd;
+	uint32_t byte1_rd_raw_upd;
+	uint32_t byte0_rdg_raw_upd;
+	uint32_t byte1_rdg_raw_upd;
+	uint32_t byte0_rdqs_raw_upd;
+	uint32_t byte1_rdqs_raw_upd;
+
+	ca_raw_upd = 0x00000001 << 0;
+	byte0_wr_raw_upd = 0x00000001 << 4;
+	byte1_wr_raw_upd = 0x00000001 << 5;
+	byte0_wdqs_raw_upd = 0x00000001 << 8;
+	byte1_wdqs_raw_upd = 0x00000001 << 9;
+	byte0_rd_raw_upd = 0x00000001 << 12;
+	byte1_rd_raw_upd = 0x00000001 << 13;
+	byte0_rdg_raw_upd = 0x00000001 << 16;
+	byte1_rdg_raw_upd = 0x00000001 << 17;
+	byte0_rdqs_raw_upd = 0x00000001 << 20;
+	byte1_rdqs_raw_upd = 0x00000001 << 21;
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x54);
+	ddr_debug_num_write();
+	// if($test$plusargs("")) {
+	//}
+	// RAW DLINE_UPD
+	rddata = ca_raw_upd;
+	mmio_wr32(0x016C + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x0174 + PHYD_BASE_ADDR);
+}
+
+void cvx16_en_rec_vol_mode(void)
+{
+	uartlog("cvx16_en_rec_vol_mode\n");
+	ddr_debug_wr32(0x54);
+	ddr_debug_num_write();
+#ifdef DDR2
+	rddata = 0x00001001;
+	mmio_wr32(0x0500 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x0540 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("cvx16_en_rec_vol_mode done\n");
+
+#endif
+}
+
+void cvx16_dll_sw_clr(void)
+{
+	uint32_t phyd_stop_clk;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x56);
+	ddr_debug_num_write();
+	phyd_stop_clk = mmio_rd32(cfg_base + 0x30); // phyd_stop_clk
+	rddata = modified_bits_by_value(phyd_stop_clk, 0, 9, 9);
+	mmio_wr32(cfg_base + 0x30, rddata);
+	// param_phyd_sw_dfi_phyupd_req
+	rddata = 0x00000101;
+	mmio_wr32(0x0174 + PHYD_BASE_ADDR, rddata);
+	while (1) {
+		// param_phyd_to_reg_sw_phyupd_dline_done
+		rddata = mmio_rd32(0x3030 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 24, 24) == 0x1) {
+			break;
+		}
+	}
+	mmio_wr32(cfg_base + 0x30, phyd_stop_clk);
+}
+
+void cvx16_reg_toggle(void)
+{
+	uartlog("cvx16_reg_toggle\n");
+	ddr_debug_wr32(0x57);
+	ddr_debug_num_write();
+	rddata = mmio_rd32(0x0 + PHYD_BASE_ADDR);
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x4 + PHYD_BASE_ADDR);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x4 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x8 + PHYD_BASE_ADDR);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xc + PHYD_BASE_ADDR);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xc + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x10 + PHYD_BASE_ADDR);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x14 + PHYD_BASE_ADDR);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x18 + PHYD_BASE_ADDR);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x20 + PHYD_BASE_ADDR);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x24 + PHYD_BASE_ADDR);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x28 + PHYD_BASE_ADDR);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x28 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x2c + PHYD_BASE_ADDR);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x2c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x40 + PHYD_BASE_ADDR);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x44 + PHYD_BASE_ADDR);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x48 + PHYD_BASE_ADDR);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x4c + PHYD_BASE_ADDR);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50 + PHYD_BASE_ADDR);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x54 + PHYD_BASE_ADDR);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x58 + PHYD_BASE_ADDR);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x58 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x5c + PHYD_BASE_ADDR);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x5c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x60 + PHYD_BASE_ADDR);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x60 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x64 + PHYD_BASE_ADDR);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x64 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x68 + PHYD_BASE_ADDR);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x68 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x70 + PHYD_BASE_ADDR);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x70 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x74 + PHYD_BASE_ADDR);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x74 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x80 + PHYD_BASE_ADDR);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x80 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x84 + PHYD_BASE_ADDR);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x84 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x88 + PHYD_BASE_ADDR);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x88 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x8c + PHYD_BASE_ADDR);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x8c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x90 + PHYD_BASE_ADDR);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x90 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x94 + PHYD_BASE_ADDR);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x94 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa0 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa4 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa4 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa8 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xac + PHYD_BASE_ADDR);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xac + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb0 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb4 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb4 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb8 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xbc + PHYD_BASE_ADDR);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xbc + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xf8 + PHYD_BASE_ADDR);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xf8 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xfc + PHYD_BASE_ADDR);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xfc + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x100 + PHYD_BASE_ADDR);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x100 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x104 + PHYD_BASE_ADDR);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x104 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x10c + PHYD_BASE_ADDR);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x10c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x110 + PHYD_BASE_ADDR);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x110 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x114 + PHYD_BASE_ADDR);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x114 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x118 + PHYD_BASE_ADDR);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x118 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x11c + PHYD_BASE_ADDR);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x11c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x120 + PHYD_BASE_ADDR);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x120 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x124 + PHYD_BASE_ADDR);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x124 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x128 + PHYD_BASE_ADDR);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x128 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x12c + PHYD_BASE_ADDR);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x12c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x130 + PHYD_BASE_ADDR);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x130 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x134 + PHYD_BASE_ADDR);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x134 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x138 + PHYD_BASE_ADDR);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x138 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x140 + PHYD_BASE_ADDR);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x140 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x144 + PHYD_BASE_ADDR);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x144 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x148 + PHYD_BASE_ADDR);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x148 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x74 + PHYD_BASE_ADDR);
+	mmio_wr32(0x74 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x74 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x14c + PHYD_BASE_ADDR);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x14c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x150 + PHYD_BASE_ADDR);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x150 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x154 + PHYD_BASE_ADDR);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x154 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x158 + PHYD_BASE_ADDR);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x158 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x15c + PHYD_BASE_ADDR);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x15c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x168 + PHYD_BASE_ADDR);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x168 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x16c + PHYD_BASE_ADDR);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x16c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x170 + PHYD_BASE_ADDR);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x170 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x174 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x174 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x174 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x180 + PHYD_BASE_ADDR);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x180 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x184 + PHYD_BASE_ADDR);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x184 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x188 + PHYD_BASE_ADDR);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x188 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x18c + PHYD_BASE_ADDR);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x18c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x190 + PHYD_BASE_ADDR);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x190 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x200 + PHYD_BASE_ADDR);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x200 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x204 + PHYD_BASE_ADDR);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x204 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x208 + PHYD_BASE_ADDR);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x208 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x220 + PHYD_BASE_ADDR);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x220 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x224 + PHYD_BASE_ADDR);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x224 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x228 + PHYD_BASE_ADDR);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x228 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x400 + PHYD_BASE_ADDR);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x400 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x404 + PHYD_BASE_ADDR);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x404 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x408 + PHYD_BASE_ADDR);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x408 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x40c + PHYD_BASE_ADDR);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x40c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x410 + PHYD_BASE_ADDR);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x410 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x414 + PHYD_BASE_ADDR);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x414 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x418 + PHYD_BASE_ADDR);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x418 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x41c + PHYD_BASE_ADDR);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x41c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x500 + PHYD_BASE_ADDR);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x500 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x504 + PHYD_BASE_ADDR);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x504 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x508 + PHYD_BASE_ADDR);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x508 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50c + PHYD_BASE_ADDR);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x50c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x510 + PHYD_BASE_ADDR);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x510 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x514 + PHYD_BASE_ADDR);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x514 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x518 + PHYD_BASE_ADDR);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x518 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x51c + PHYD_BASE_ADDR);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x51c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x520 + PHYD_BASE_ADDR);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x520 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x540 + PHYD_BASE_ADDR);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x540 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x544 + PHYD_BASE_ADDR);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x544 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x548 + PHYD_BASE_ADDR);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x548 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x54c + PHYD_BASE_ADDR);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x54c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x550 + PHYD_BASE_ADDR);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x550 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x554 + PHYD_BASE_ADDR);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x554 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x558 + PHYD_BASE_ADDR);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x558 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x55c + PHYD_BASE_ADDR);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x55c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x560 + PHYD_BASE_ADDR);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x560 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x900 + PHYD_BASE_ADDR);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x900 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x904 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x904 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x904 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x908 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x908 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x908 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x90c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x90c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x90c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x910 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x910 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x910 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x914 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x914 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x914 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x918 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x918 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x918 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x91c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x91c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x91c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x920 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x920 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x920 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x924 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x924 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x924 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x928 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x928 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x928 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x92c + PHYD_BASE_ADDR);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x92c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x930 + PHYD_BASE_ADDR);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x930 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x934 + PHYD_BASE_ADDR);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x934 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x938 + PHYD_BASE_ADDR);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x938 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x940 + PHYD_BASE_ADDR);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x940 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x944 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x944 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x944 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x948 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x948 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x948 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x94c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x94c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x94c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x950 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x950 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x950 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x954 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x954 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x954 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x958 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x958 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x958 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x95c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x95c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x95c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x960 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x960 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x960 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x964 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x964 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x964 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x968 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x968 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x968 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x96c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x96c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x96c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x970 + PHYD_BASE_ADDR);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x970 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x974 + PHYD_BASE_ADDR);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x974 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x978 + PHYD_BASE_ADDR);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x978 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x97c + PHYD_BASE_ADDR);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x97c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x980 + PHYD_BASE_ADDR);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x980 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa00 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa04 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa08 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa0c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa10 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa14 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa18 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa1c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa20 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa24 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa28 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa28 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa2c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa2c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa30 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa34 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa38 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa3c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa40 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa44 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa48 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa4c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa50 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa54 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa58 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa58 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa5c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa5c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa60 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa60 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa64 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa64 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa68 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa68 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa6c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa6c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa70 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa70 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa74 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa74 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa78 + PHYD_BASE_ADDR);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa78 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xa7c + PHYD_BASE_ADDR);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xa7c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb00 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb04 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb08 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb0c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb10 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb14 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb18 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb1c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb20 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb24 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb30 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb34 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb38 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb3c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb40 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb44 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb48 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb4c + PHYD_BASE_ADDR);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb50 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0xb54 + PHYD_BASE_ADDR);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0xb54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1400 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1400 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1404 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1404 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1408 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1408 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x140c + PHYD_BASE_ADDR);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x140c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1410 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1410 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1414 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1414 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1418 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1418 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x141c + PHYD_BASE_ADDR);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x141c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1500 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1500 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1504 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1504 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1508 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1508 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x150c + PHYD_BASE_ADDR);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x150c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1510 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1510 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1514 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1514 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1518 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1518 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x151c + PHYD_BASE_ADDR);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x151c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1520 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1520 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1540 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1540 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1544 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1544 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1548 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1548 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x154c + PHYD_BASE_ADDR);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x154c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1550 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1550 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1554 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1554 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1558 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1558 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x155c + PHYD_BASE_ADDR);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x155c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1560 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1560 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1900 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1900 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x1904 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1904 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1904 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1908 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1908 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1908 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x190c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x190c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x190c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1910 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1910 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1910 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1914 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1914 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1914 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1918 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1918 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1918 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x191c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x191c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x191c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1920 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1920 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1920 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1924 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1924 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1924 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1928 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1928 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1928 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x192c + PHYD_BASE_ADDR);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x192c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1930 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1930 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1934 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1934 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1938 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1938 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1940 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1940 + PHYD_BASE_ADDR, rddata);
+	// rddata = mmio_rd32(0x1944 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1944 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1944 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1948 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1948 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1948 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x194c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x194c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x194c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1950 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1950 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1950 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1954 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1954 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1954 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1958 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1958 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1958 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x195c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x195c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x195c + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1960 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1960 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1960 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1964 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1964 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1964 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x1968 + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x1968 + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x1968 + PHYD_BASE_ADDR, rddata );
+	// rddata = mmio_rd32(0x196c + PHYD_BASE_ADDR);
+	// mmio_wr32    ( 0x196c + PHYD_BASE_ADDR, ~rddata );
+	// mmio_wr32    ( 0x196c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x1970 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1970 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1974 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1974 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1978 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1978 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x197c + PHYD_BASE_ADDR);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x197c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1980 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1980 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a00 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a04 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a08 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a0c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a10 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a14 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a18 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a1c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a20 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a24 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a28 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a28 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a2c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a2c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a30 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a34 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a38 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a3c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a40 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a44 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a48 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a4c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a50 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a54 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a58 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a58 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a5c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a5c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a60 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a60 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a64 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a64 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a68 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a68 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a6c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a6c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a70 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a70 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a74 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a74 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a78 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a78 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1a7c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1a7c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b00 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b00 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b04 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b04 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b08 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b08 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b0c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b0c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b10 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b10 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b14 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b14 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b18 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b18 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b1c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b1c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b20 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b20 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b24 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b24 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b30 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b30 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b34 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b34 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b38 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b38 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b3c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b3c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b40 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b40 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b44 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b44 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b48 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b48 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b4c + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b4c + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b50 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b50 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x1b54 + PHYD_BASE_ADDR);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x1b54 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x164 + PHYD_BASE_ADDR);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x164 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x41c + PHYD_BASE_ADDR);
+	mmio_wr32(0x41c + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x41c + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x204 + PHYD_BASE_ADDR);
+	mmio_wr32(0x204 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x204 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x224 + PHYD_BASE_ADDR);
+	mmio_wr32(0x224 + PHYD_BASE_ADDR, ~rddata);
+	// mmio_wr32    ( 0x224 + PHYD_BASE_ADDR, rddata );
+	rddata = mmio_rd32(0x3000 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3004 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3008 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x300c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3010 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3014 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3018 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x301c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3020 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3024 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3028 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x302c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3030 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3100 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3104 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3110 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3140 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3144 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3150 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3180 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3184 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3188 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x318c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3190 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3194 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3198 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x319c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31a0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31a4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31a8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31ac + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31b0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31b4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31c0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31c4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31c8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31cc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31d0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31d4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31d8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31dc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31e0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31e4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31e8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31ec + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31f0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x31f4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3280 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3284 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3288 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x328c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3290 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3294 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3298 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x329c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32a0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32a4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32a8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32c0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32c4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32c8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32cc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32d0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32d4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32d8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32dc + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32e0 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32e4 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x32e8 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3370 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3380 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3400 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3404 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x340c + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3410 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3414 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3418 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x3444 + PHYD_BASE_ADDR);
+	rddata = mmio_rd32(0x00 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x00 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x04 + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x08 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x08 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	rddata = mmio_rd32(0x10 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x10 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x10 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x1C + CV_DDR_PHYD_APB);
+	mmio_wr32(0x1C + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x1C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x20 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x20 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x20 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x24 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x24 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x24 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x28 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x28 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x28 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x44 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x44 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x48 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x48 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x48 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x4C + CV_DDR_PHYD_APB);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x4C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x54 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x54 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x58 + CV_DDR_PHYD_APB);
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x58 + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, ~rddata);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	rddata = mmio_rd32(0x00F0 + PHYD_BASE_ADDR);
+	mmio_wr32(0x00F0 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x00F0 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x00F4 + PHYD_BASE_ADDR);
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, ~rddata);
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, rddata);
+	mmio_wr32(0x00F4 + PHYD_BASE_ADDR, 0x00030033);
+	mmio_wr32(0x092C + PHYD_BASE_ADDR, 0x00000008);
+	for (int i = 0; i < 23; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x0000 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0004 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0008 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x000C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0010 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0014 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0018 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x001C + PHYD_BASE_ADDR, rddata);
+		rddata = i << 28 | i << 24 | i << 20 | i << 16 | i << 12 | i << 8 | i << 4 | i;
+		mmio_wr32(0x0020 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0024 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0028 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x002C + PHYD_BASE_ADDR, rddata);
+	}
+	for (int i = 0; i < 23; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x011C + PHYD_BASE_ADDR, rddata);
+	}
+	for (int i = 0; i < 128; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x0B0C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B10 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B14 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B3C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x0B44 + PHYD_BASE_ADDR, rddata);
+	}
+	cvx16_dll_cal();
+	for (int i = 0; i < 64; i++) {
+		rddata = i << 24 | i << 16 | i << 8 | i;
+		mmio_wr32(0x900 + PHYD_BASE_ADDR, rddata);
+		// mmio_wr32( 0x904 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x908 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x90C + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x910 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x914 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x918 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x91C + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x920 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x924 + PHYD_BASE_ADDR, rddata );
+		// mmio_wr32( 0x928 + PHYD_BASE_ADDR, rddata );
+		mmio_wr32(0x92C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x930 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x934 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0x938 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA00 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA04 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA08 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA0C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA10 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA14 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA18 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA40 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA44 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA48 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA4C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA50 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA54 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xA58 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB00 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB04 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB08 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB0C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB10 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB30 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB34 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB38 + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB3C + PHYD_BASE_ADDR, rddata);
+		mmio_wr32(0xB40 + PHYD_BASE_ADDR, rddata);
+		cvx16_lb_1_dq_set_highlow();
+		cvx16_lb_3_ca_set_highlow();
+		cvx16_dll_sw_clr();
+		KC_MSG("shift = %x\n", i);
+	}
+}
+
+void cvx16_ana_test(void)
+{
+	uint32_t i;
+	uint32_t j;
+
+	uartlog("%s\n", __func__);
+	ddr_debug_wr32(0x58);
+	ddr_debug_num_write();
+	//[31] TOP_REG_TX_ZQ_PD =0
+	//[24] TOP_REG_TX_CA_PD_CKE0=0
+	rddata = 0x7EFFFFFF;
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	//[1] TOP_REG_TX_CA_GPIO_OENZ=0
+	//[2] TOP_REG_TX_CA_SEL_GPIO_CKE0=1
+	rddata = 0x00000065;
+	mmio_wr32(0x1C + CV_DDR_PHYD_APB, rddata);
+	//[2] REG_DDRPLL_EN_TST=0b1
+	rddata = mmio_rd32(0x0C + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 2, 2);
+	mmio_wr32(0x0C + CV_DDR_PHYD_APB, rddata);
+	//[15] param_phya_reg_tx_zq_en_test_mux
+	rddata = mmio_rd32(0x014C + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 1, 1);
+	mmio_wr32(0x014C + PHYD_BASE_ADDR, rddata);
+	//[0] param_phya_reg_en_test
+	rddata = mmio_rd32(0x0134 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	mmio_wr32(0x0134 + PHYD_BASE_ADDR, rddata);
+	uartlog("start ana test\n");
+	for (i = 1; i < 9; i = i + 1) {
+		KC_MSG("param_phya_reg_zq_sel_test_out=%x\n", get_bits_from_value(i, 3, 0));
+
+		// param_phya_reg_zq_sel_test_out0	7	4
+		// param_phya_reg_zq_sel_test_out1	11	8
+		rddata = mmio_rd32(0x014C + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(i, 3, 0), 7, 4);
+		rddata = modified_bits_by_value(rddata, get_bits_from_value(i, 3, 0), 11, 8);
+		mmio_wr32(0x014C + PHYD_BASE_ADDR, rddata);
+		for (j = 0; j <= 15; j = j + 1) {
+			KC_MSG("param_phya_reg_rx_byte0_sel_test_in=%x\n", get_bits_from_value(j, 3, 0));
+
+			// param_phya_reg_rx_byte0_sel_test_in0	19 16
+			// param_phya_reg_rx_byte0_sel_test_in1	23 20
+			rddata = mmio_rd32(0x0200 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 19, 16);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 23, 20);
+			// param_phya_reg_rx_byte1_sel_test_in0  19  16
+			// param_phya_reg_rx_byte1_sel_test_in1  23  20
+			mmio_wr32(0x0200 + PHYD_BASE_ADDR, rddata);
+			rddata = mmio_rd32(0x0220 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 19, 16);
+			rddata = modified_bits_by_value(rddata, get_bits_from_value(j, 3, 0), 23, 20);
+			mmio_wr32(0x0220 + PHYD_BASE_ADDR, rddata);
+			// opdelay(1000);
+		}
+	}
+	KC_MSG("%s Fisish\n", __func__);
+}
+
+void cvx16_ddr_zq240(void)
+{
+	//        KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	int i;
+	int pre_zq240_cmp_out;
+
+	KC_MSG("START ZQ240 Calibration ...\n");
+
+	uartlog("ddr_zq240\n");
+	ddr_debug_wr32(0x2c1);
+	ddr_debug_num_write();
+	// VDDQ_TXr        = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// param_phyd_zqcal_hw_mode =1
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+	// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 2, 2);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+	// b.
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+	rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+	// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+	rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+	rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// d.
+	// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 0);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_SEL_GPIO         <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+	//  TOP_REG_TX_GPIO_OENZ        <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 7, 6);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	//------------------------------
+	// CMP offset Cal.
+	//------------------------------
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("zq_cmp_en\n");
+
+	//------------------------------
+	// ZQ Complete
+	//------------------------------
+	uartlog("wait hw_done\n");
+	// param_phyd_to_reg_zqcal_hw_done
+	while (1) {
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 16, 16) == 1) {
+			break;
+		}
+		KC_MSG("wait param_phyd_to_reg_zqcal_hw_done ...\n");
+	}
+	// check param_phya_reg_tx_zq_cmp_offset
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	KC_MSG("reg_tx_zq_cmp_offset = %x\n", get_bits_from_value(rddata, 12, 8));
+
+	uartlog("hw_done\n");
+	KC_MSG("param_phyd_to_reg_zqcal_hw_done ...\n");
+
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// param_phyd_zqcal_hw_mode =0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	//------------------------------
+	// ZQ240
+	//------------------------------
+	KC_MSG("START ZQ240 Calibration - ZQ 240 ...\n");
+
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	//         rddata=modified_bits_by_value(rddata, 0, 19, 16 );
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x15, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 19, 16);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	pre_zq240_cmp_out = 0x0;
+	for (i = 0; i < 16; i = i + 1) {
+		rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240_TRIM
+		rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240_TRIM
+		mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+		// opdelay(128);
+		KC_MSG("START ZQ240 Calibration ==> round %x...\n", i);
+
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		// param_phya_to_reg_zq_cmp_out
+		KC_MSG("START ZQ240 Calibration - cmp_out = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		if ((pre_zq240_cmp_out == 0x1) && (get_bits_from_value(rddata, 24, 24) == 0x0)) {
+			KC_MSG("ZQ240 Calibration = %x\n", i);
+
+			rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240
+			rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240
+			mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+			i = 18;
+		}
+		pre_zq240_cmp_out = get_bits_from_value(rddata, 24, 24);
+	}
+	if ((pre_zq240_cmp_out == 0x0) || (i == 16)) {
+		KC_MSG("Error !!! ZQ240 Calibration\n");
+	}
+	uartlog("zq240 done\n");
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM =0
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+	// opdelay(200);
+	KC_MSG("ZQ240 Complete ...\n");
+}
+
+void cvx16_ddr_zq240_ate(void)
+{
+	//        KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	int i;
+	int pre_zq240_cmp_out;
+
+	KC_MSG("START ZQ240 Calibration ...\n");
+
+	uartlog("ddr_zq240\n");
+	ddr_debug_wr32(0x2c1);
+	ddr_debug_num_write();
+	// VDDQ_TXr        = 0.6;
+	//------------------------------
+	//  Init setting
+	//------------------------------
+	// param_phyd_zqcal_hw_mode =1
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+	// param_phya_reg_sel_zq_high_swing  <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 2, 2);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_sel_lpddr4_pmos_ph <= `PI_SD int_regin[2];
+	rddata = mmio_rd32(0x0400 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 5, 5);
+	mmio_wr32(0x0400 + PHYD_BASE_ADDR, rddata);
+	// b.
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	rddata = modified_bits_by_value(rddata, 0x10, 12, 8);
+	rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// param_phya_reg_tx_zq_drvn[5:0] <= `PI_SD int_regin[20:16];
+	// param_phya_reg_tx_zq_drvp[5:0] <= `PI_SD int_regin[28:24];
+	rddata = mmio_rd32(0x0148 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x9, 20, 16);
+	rddata = modified_bits_by_value(rddata, 0x9, 28, 24);
+	mmio_wr32(0x0148 + PHYD_BASE_ADDR, rddata);
+	// d.
+	// param_phya_reg_tx_zq_en_test_aux <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_en_test_mux  <= `PI_SD int_regin[1];
+	rddata = mmio_rd32(0x014c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 1, 0);
+	mmio_wr32(0x014c + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_TX_SEL_GPIO         <= #RD (~pwstrb_mask[7] & TOP_REG_TX_SEL_GPIO) |  pwstrb_mask_pwdata[7];
+	//  TOP_REG_TX_GPIO_OENZ        <= #RD (~pwstrb_mask[6] & TOP_REG_TX_GPIO_OENZ) |  pwstrb_mask_pwdata[6];
+	rddata = mmio_rd32(0x1c + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 7, 6);
+	mmio_wr32(0x1c + CV_DDR_PHYD_APB, rddata);
+	//------------------------------
+	// CMP offset Cal.
+	//------------------------------
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x15, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	KC_MSG("zq_cmp_en\n");
+
+	//------------------------------
+	// ZQ Complete
+	//------------------------------
+	uartlog("wait hw_done\n");
+	// param_phyd_to_reg_zqcal_hw_done
+	while (1) {
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		if (get_bits_from_value(rddata, 16, 16) == 1) {
+			break;
+		}
+		KC_MSG("wait param_phyd_to_reg_zqcal_hw_done ...\n");
+	}
+	// check param_phya_reg_tx_zq_cmp_offset
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	KC_MSG("reg_tx_zq_cmp_offset = %x\n", get_bits_from_value(rddata, 12, 8));
+
+	uartlog("hw_done\n");
+	KC_MSG("param_phyd_to_reg_zqcal_hw_done ...\n");
+
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 0, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// param_phyd_zqcal_hw_mode =0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	//------------------------------
+	// ZQ240
+	//------------------------------
+	KC_MSG("START ZQ240 Calibration - ZQ 240 ...\n");
+
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 1, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// rddata = mmio_rd32(0x50+CV_DDR_PHYD_APB);
+	// rddata=modified_bits_by_value(rddata, 1, 0, 0 );
+	//          rddata=modified_bits_by_value(rddata, 0, 19, 16 );
+	// mmio_wr32(0x50+CV_DDR_PHYD_APB,  rddata);
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 0x15, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// rddata = mmio_rd32(0x50+CV_DDR_PHYD_APB);
+	rddata = 0x00000000;
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	rddata = modified_bits_by_value(rddata, 1, 19, 16);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	pre_zq240_cmp_out = 0x0;
+	for (i = 0; i < 16; i = i + 1) {
+		rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240_TRIM
+		rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240_TRIM
+		mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+		KC_MSG("START ZQ240 Calibration ==> round %x...\n", i);
+
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		// param_phya_to_reg_zq_cmp_out
+		KC_MSG("START ZQ240 Calibration - cmp_out = %x\n", get_bits_from_value(rddata, 24, 24));
+	}
+	uartlog("zq240 done\n");
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	// rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	// rddata=modified_bits_by_value(rddata, 0, 4, 0 );
+	// mmio_wr32(0x0144 + PHYD_BASE_ADDR,  rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM =0
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+	// opdelay(200);
+	KC_MSG("ZQ240 Complete ...\n");
+}
+
+void cvx16_ddr_zq240_cal(void)
+{
+	//        KC_MSG("cv181x without ZQ240 Calibration ...\n");
+
+	int i;
+	int pre_zq240_cmp_out;
+
+	KC_MSG("START ZQ240 Calibration ...\n");
+
+	uartlog("ddr_zq240_cal\n");
+	ddr_debug_wr32(0x2c1);
+	ddr_debug_num_write();
+	//------------------------------
+	// ZQ240
+	//------------------------------
+	KC_MSG("START ZQ240 Calibration - ZQ 240 ...\n");
+
+	// param_phyd_zqcal_hw_mode =0
+	rddata = mmio_rd32(0x0074 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 18, 16);
+	mmio_wr32(0x0074 + PHYD_BASE_ADDR, rddata);
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 0...\n");
+
+	// param_phya_reg_tx_zq_cmp_en = 1
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM = 1
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 0, 0);
+	//         rddata=modified_bits_by_value(rddata, 0, 19, 16 );
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];            =1
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];            =1
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];            =1
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0x15, 4, 0);
+#ifdef DDR4
+	rddata = modified_bits_by_value(rddata, 0x10, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+#else
+	// for zq pull high 60ohm
+	rddata = modified_bits_by_value(rddata, 0x1A, 20, 16);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+#endif
+	// rddata = mmio_rd32(0x50+CV_DDR_PHYD_APB);
+	// rddata=modified_bits_by_value(rddata, 1, 0, 0 );
+	// rddata=modified_bits_by_value(rddata, 1, 19, 16 );
+	// mmio_wr32(0x50+CV_DDR_PHYD_APB,  rddata);
+	pre_zq240_cmp_out = 0x0;
+	for (i = 0; i < 16; i = i + 1) {
+		rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240_TRIM
+		rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240_TRIM
+		mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+		// opdelay(128);
+		KC_MSG("START ZQ240 Calibration ==> round %x...\n", i);
+
+		rddata = mmio_rd32(0x3440 + PHYD_BASE_ADDR);
+		// param_phya_to_reg_zq_cmp_out
+		KC_MSG("START ZQ240 Calibration - cmp_out = %x\n", get_bits_from_value(rddata, 24, 24));
+
+		if ((pre_zq240_cmp_out == 0x1) && (get_bits_from_value(rddata, 24, 24) == 0x0)) {
+			KC_MSG("ZQ240 Calibration = %x\n", i);
+
+			rddata = 0x00000001; // TOP_REG_ZQ_EN_ZQ_240
+			rddata = modified_bits_by_value(rddata, i, 19, 16); // TOP_REG_ZQ_TRIM_ZQ_240
+			mmio_wr32(0x54 + CV_DDR_PHYD_APB, rddata);
+			i = 18;
+		}
+		pre_zq240_cmp_out = get_bits_from_value(rddata, 24, 24);
+	}
+	if ((i == 16)) {
+		KC_MSG("Error !!! ZQ240 Calibration\n");
+	}
+	uartlog("zq240 done\n");
+	// param_phya_reg_tx_zq_cmp_en    <= `PI_SD int_regin[0];
+	// param_phya_reg_tx_zq_cmp_offset_cal_en <= `PI_SD int_regin[1];
+	// param_phya_reg_tx_zq_ph_en     <= `PI_SD int_regin[2];
+	// param_phya_reg_tx_zq_pl_en     <= `PI_SD int_regin[3];
+	// param_phya_reg_tx_zq_step2_en  <= `PI_SD int_regin[4];
+	// param_phya_reg_tx_zq_cmp_offset[4:0] <= `PI_SD int_regin[12:8];
+	// param_phya_reg_tx_zq_sel_vref[4:0] <= `PI_SD int_regin[20:16];
+	rddata = mmio_rd32(0x0144 + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 0, 4, 0);
+	mmio_wr32(0x0144 + PHYD_BASE_ADDR, rddata);
+	// TOP_REG_ZQ_EN_ZQ_240_TRIM =0
+	rddata = mmio_rd32(0x50 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 0, 1, 1);
+	mmio_wr32(0x50 + CV_DDR_PHYD_APB, rddata);
+	// TOP_REG_TX_ZQ_PD        <= #RD (~pwstrb_mask[31] & TOP_REG_TX_ZQ_PD) |  pwstrb_mask_pwdata[31];
+	rddata = mmio_rd32(0x40 + CV_DDR_PHYD_APB);
+	rddata = modified_bits_by_value(rddata, 1, 31, 31);
+	mmio_wr32(0x40 + CV_DDR_PHYD_APB, rddata);
+	KC_MSG("TOP_REG_TX_ZQ_PD = 1...\n");
+
+	// opdelay(200);
+	KC_MSG("ZQ240 Complete ...\n");
+}
+
+void ctrl_init_detect_dram_size(uint8_t *dram_cap_in_mbyte)
+{
+	uint8_t cap_in_mbyte = 0;
+#ifdef DDR3
+	uint32_t cmd[6];
+	uint8_t i;
+
+	// dram_cap_in_mbyte = 4;
+	cap_in_mbyte = 4;
+
+	for (i = 0; i < 6; i++)
+		cmd[i] = 0x0;
+
+	// Axsize = 3, axlen = 4, cgen
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x000e0006);
+
+	// DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0xffffffff);
+
+	// specified AXI address step
+	mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+
+	// write PRBS to 0x0 as background {{{
+
+	cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0); // write 16 UI prbs
+
+	for (i = 0; i < 6; i++) {
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+	}
+
+	// bist_enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+
+	// polling BIST done
+
+	do {
+		rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+	} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+	// bist disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+	// }}}
+
+	do {
+		// *dram_cap_in_mbyte++;
+		cap_in_mbyte++;
+		uartlog("cap_in_mbyte =  %x\n", cap_in_mbyte);
+
+		// write ~PRBS to (0x1 << *dram_cap_in_mbyte) {{{
+
+		// DDR space
+		mmio_wr32(DDR_BIST_BASE + 0x10, 1 << (cap_in_mbyte + 20 - 4));
+
+		cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (1 << 8) + (0 << 0); // write 16 UI ~prbs
+
+		for (i = 0; i < 6; i++) {
+			mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+		}
+
+		// bist_enable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+		// polling BIST done
+
+		do {
+			rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+		// bist disable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+		// }}}
+
+		// check PRBS at 0x0 {{{
+
+		// DDR space
+		mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+		cmd[0] = (2 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0); // read 16 UI prbs
+
+		for (i = 0; i < 6; i++) {
+			mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+		}
+
+		// bist_enable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+		// polling BIST done
+
+		do {
+			rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+		// bist disable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+		// }}}
+
+	} while ((get_bits_from_value(rddata, 3, 3) == 0) && (cap_in_mbyte < 15)); // BIST fail stop the loop
+
+#endif
+#ifdef DDR2
+	// fix size for DDR2
+	cap_in_mbyte = 6;
+#endif
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		uint32_t cmd[6];
+		uint8_t i;
+
+		// dram_cap_in_mbyte = 4;
+		cap_in_mbyte = 4;
+
+		for (i = 0; i < 6; i++)
+			cmd[i] = 0x0;
+
+		// Axsize = 3, axlen = 4, cgen
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x000e0006);
+
+		// DDR space
+		mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+		mmio_wr32(DDR_BIST_BASE + 0x14, 0xffffffff);
+
+		// specified AXI address step
+		mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+
+		// write PRBS to 0x0 as background {{{
+
+		cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9)
+					+ (0 << 8) + (0 << 0); // write 16 UI prbs
+
+		for (i = 0; i < 6; i++) {
+			mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+		}
+
+		// bist_enable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+
+		// polling BIST done
+
+		do {
+			rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+		// bist disable
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+		// }}}
+
+		do {
+			// *dram_cap_in_mbyte++;
+			cap_in_mbyte++;
+			uartlog("cap_in_mbyte =  %x\n", cap_in_mbyte);
+
+			// write ~PRBS to (0x1 << *dram_cap_in_mbyte) {{{
+
+			// DDR space
+			mmio_wr32(DDR_BIST_BASE + 0x10, 1 << (cap_in_mbyte + 20 - 4));
+
+			cmd[0] = (1 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (1 << 8) + (0 << 0);//write 16 UI~prbs
+
+			for (i = 0; i < 6; i++) {
+				mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+			}
+
+			// bist_enable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+			// polling BIST done
+
+			do {
+				rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+			} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+			// bist disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+			// }}}
+
+			// check PRBS at 0x0 {{{
+
+			// DDR space
+			mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+			cmd[0] = (2 << 30) + (0 << 21) + (3 << 12) + (5 << 9) + (0 << 8) + (0 << 0); // read 16 UI prbs
+
+			for (i = 0; i < 6; i++) {
+				mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+			}
+
+			// bist_enable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+			// polling BIST done
+
+			do {
+				rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+			} while (get_bits_from_value(rddata, 2, 2) == 0);
+
+			// bist disable
+			mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010000);
+			// }}}
+
+		} while ((get_bits_from_value(rddata, 3, 3) == 0) && (cap_in_mbyte < 15)); // BIST fail stop the loop
+	}
+	if (get_ddr_type() == DDR_TYPE_DDR2) {
+		// fix size for DDR2
+		cap_in_mbyte = 6;
+	}
+#endif
+
+	*dram_cap_in_mbyte = cap_in_mbyte;
+
+	// save dram_cap_in_mbyte
+	rddata = cap_in_mbyte;
+	mmio_wr32(0x0208 + PHYD_BASE_ADDR, rddata);
+
+	// cgen disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00040000);
+}
+
+#if defined(FULL_MEM_BIST) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+uint32_t ddr_bist_all(uint32_t mode, uint32_t capacity, uint32_t x16_mode)
+{
+	uint32_t axi_len8;
+	int loop;
+	uint32_t cmd[6];
+	uint64_t cap;
+	uint32_t pattern;
+	uint32_t bist_result = 1;
+	uint32_t sram_sp;
+	uint32_t fmax;
+	uint32_t fmin;
+
+	// mode--> 0/1/2 = prbs/sram/01
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	// KC  KC_MSG("capacity=%x, x16_mode=%x\n", capacity, x16_mode);
+
+	if (capacity == 0)
+		cap = (2 << 9) << (20 - 3);
+	else
+		cap = capacity << (30 - 3);
+
+	if (mode == 0) {
+		//prbs
+		pattern = 5;
+		sram_sp = 511;
+	} else if (mode == 1) {
+		//sram
+		pattern = 6;
+		fmax = 15;
+		fmin = 5;
+		sram_sp = 511; //for all dram size, repeat sso pattern
+		//sram_sp = 9 * (fmin + fmax) * (fmax - fmin + 1) / 2 / 4 + (fmax - fmin + 1); // 8*f/4 -1
+		//KC_MSG("sram_sp = %x\n", sram_sp);
+
+		// bist sso_period
+		mmio_wr32(DDR_BIST_BASE + 0x24, (fmax << 8) + fmin);
+
+	} else {
+		pattern = 1;
+		sram_sp = 511;
+	}
+
+	loop = cap / (512 * 4 * 16 * 4 / (2 << x16_mode)) - 1;
+
+	// check xpi len
+	rddata = mmio_rd32(cfg_base + 0xc);
+	axi_len8 = FIELD_GET(rddata, 19, 19);
+	KC_MSG("cap=%x, loop=%x, axi_len8=%x\n", cap, loop, axi_len8);
+
+	// bist clock enable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00060006);
+	// sram based cmd
+	//        op_code     start       stop              pattern          dq_inv     dm_inv    dq_auto_rotate repeat
+	cmd[0] = (1 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (0 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	cmd[1] = (2 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (0 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	cmd[3] = (1 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (1 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	cmd[4] = (2 << 30) | (0 << 21) | (sram_sp << 12) | (pattern << 9) | (1 << 8) | (0 << 7) | (0 << 4) | (15 << 0);
+	//        op_code     addr_not_assert    goto_idx    loop
+	cmd[2] = (3 << 30) | (1 << 20) | (0 << 16) | (loop << 0);
+	cmd[5] = (3 << 30) | (1 << 20) | (3 << 16) | (loop << 0);
+
+	// write cmd queue
+	for (int i = 0; i < 6; i++)
+		mmio_wr32(DDR_BIST_BASE + 0x40 + i * 4, cmd[i]);
+
+	// DDR space
+	mmio_wr32(DDR_BIST_BASE + 0x10, 0x00000000);
+	mmio_wr32(DDR_BIST_BASE + 0x14, 0x00ffffff);
+	// set AXI_LEN8
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00080000 | (axi_len8 << 3));
+	// specified AXI address step
+	if (x16_mode == 0x1) {
+		if (axi_len8 == 0x1)
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+		else
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000002);
+	} else {
+		if (axi_len8 == 0x1)
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000008);
+		else
+			mmio_wr32(DDR_BIST_BASE + 0x18, 0x00000004);
+	}
+	// bist_enable & x16_en
+	if (x16_mode == 0x1) {
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00030003);
+	} else {
+		mmio_wr32(DDR_BIST_BASE + 0x0, 0x00010001);
+	}
+	// polling bist done
+	while (1) {
+		rddata = mmio_rd32(DDR_BIST_BASE + 0x80);
+		if (FIELD_GET(rddata, 2, 2) == 1)
+			break;
+	}
+
+	//aspi_axi_sr(`SPI_REG_DDR_BIST + 0x80, ptest_aspi_spi_rdata, 0x0000_000C, "INFO: polling bist done and pass")
+	if (FIELD_GET(rddata, 3, 2) == 1) {
+		KC_MSG("bist_Pass\n");
+		bist_result = 1 & bist_result;
+	} else {
+		KC_MSG("ERROR bist_fail\n");
+		bist_result = 0;
+	}
+	// bist disable
+	mmio_wr32(DDR_BIST_BASE + 0x0, 0x00050000);
+
+	return bist_result;
+}
+
+uint32_t bist_all_dram(uint32_t mode, uint32_t capacity)
+{
+	// mode--> 0/1/2 = prbs/sram/01
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	uint32_t bist_result;
+
+	bist_result = ddr_bist_all(mode, capacity, 1);
+
+	if (bist_result == 0)
+		NOTICE("ERROR bist_fail!(%d, %d)\n", mode, capacity);
+	else
+		NOTICE("ALL Bist_Pass!(%d, %d)\n", mode, capacity);
+
+	return bist_result;
+}
+
+void bist_all_dram_forever(uint32_t capacity)
+{
+	uint32_t count = 0;
+	uint32_t bist_result = 1;
+	// uint32_t sram_sp;
+
+	// sso_8x1_c(5, 15, 0, 1, &sram_sp);
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp);
+	while (1) {
+		NOTICE("%d\n", count++);
+		bist_result &= bist_all_dram(0, capacity);
+		bist_result &= bist_all_dram(1, capacity);
+		bist_result &= bist_all_dram(2, capacity);
+		if (bist_result == 0) {
+			NOTICE("BIST stress test FAIL\n");
+			break;
+		}
+	}
+}
+#endif // defined(FULL_MEM_BIST) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+
+#if defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+static void ddr_sys_init(void)
+{
+	KC_MSG("reset  !\n");
+	mmio_wr32(DDR_TOP_BASE + 0x20, 0x1);
+
+	KC_MSG("PLL INIT !\n");
+	cvx16_pll_init();
+
+	KC_MSG("DDRC_INIT !\n");
+	// ddrc_init_ddr3_4g_2133();
+	ddrc_init();
+
+	// cvx16_ctrlupd_short();
+
+	// release ddrc soft reset
+	KC_MSG("releast reset  !\n");
+	mmio_wr32(DDR_TOP_BASE + 0x20, 0x0);
+
+	KC_MSG("phy_init!\n");
+	phy_init();
+
+	cvx16_setting_check();
+	KC_MSG("cvx16_setting_check  finish");
+
+	cvx16_pinmux();
+	KC_MSG("cvx16_pinmux finish");
+
+	cvx16_en_rec_vol_mode();
+	KC_MSG("cvx16_en_rec_vol_mode finish");
+
+	// set_dfi_init_start
+	cvx16_set_dfi_init_start();
+	KC_MSG("set_dfi_init_start finish\n");
+
+	// ddr_phy_power_on_seq1
+	cvx16_ddr_phy_power_on_seq1();
+	KC_MSG("ddr_phy_power_on_seq1 finish\n");
+
+	// first dfi_init_start
+	KC_MSG("first dfi_init_start\n");
+
+	cvx16_polling_dfi_init_start();
+
+	KC_MSG("cvx16_polling_dfi_init_start finish");
+
+	cvx16_INT_ISR_08();
+	KC_MSG("cvx16_INT_ISR_08 finish");
+
+	// ddr_phy_power_on_seq3
+	cvx16_ddr_phy_power_on_seq3();
+	KC_MSG("ddr_phy_power_on_seq3 finish\n");
+
+	// wait_for_dfi_init_complete
+	cvx16_wait_for_dfi_init_complete();
+	KC_MSG("wait_for_dfi_init_complete finish\n");
+
+	// polling_synp_normal_mode
+	cvx16_polling_synp_normal_mode();
+	KC_MSG("polling_synp_normal_mode finish\n");
+}
+
+static void set_ca_vref(uint32_t vref)
+{
+	rddata = mmio_rd32(0x0414 + PHYD_BASE_ADDR);
+	rddata = FIELD_SET(rddata, vref, 20, 16); //param_phya_reg_tx_vrefca_sel
+	mmio_wr32(0x0414 + PHYD_BASE_ADDR, rddata);
+	uartlog("vrefca = %08x\n", vref);
+	//time.sleep(0.01);
+	mdelay(10);
+}
+#endif // defined(SHMOO_CA) || defined(SHMOO_CS)
+
+#if defined(DBG_SHMOO_CA)
+static uint32_t bist_all_dram_calvl(uint32_t mode, uint32_t capacity, uint32_t shift_delay, uint32_t vrefca)
+{
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	uint32_t bist_result;
+	uint32_t bist_err;
+
+	bist_result = ddr_bist_all(mode, capacity, 1);
+
+	if (bist_result == 0) {
+		bist_err = 0xffffffff;
+	} else {
+		bist_err = 0x00000000;
+	}
+	SHMOO_MSG_CA("vref = %02x, sw_ca__training_start = %08x , err_data_rise/err_data_fall = %08x, %08x\n",
+		  vrefca, shift_delay, bist_err, bist_err);
+
+	return bist_result;
+}
+#endif // defined(DBG_SHMOO_CA)
+
+#if defined(DBG_SHMOO_CS)
+static uint32_t bist_all_dram_cslvl(uint32_t mode, uint32_t capacity, uint32_t shift_delay, uint32_t vrefca)
+{
+	// capacity--> 0/1/2/4/8/16 = 0.5/1/2/4/8/16 Gb
+	uint32_t bist_result;
+	uint32_t bist_err;
+
+	bist_result = ddr_bist_all(mode, capacity, 1);
+
+	if (bist_result == 0) {
+		bist_err = 0xffffffff;
+	} else {
+		bist_err = 0x00000000;
+	}
+	SHMOO_MSG_CS("vref = %02x, sw_cs__training_start = %08x , err_data_rise/err_data_fall = %08x, %08x\n",
+		  vrefca, shift_delay, bist_err, bist_err);
+
+	return bist_result;
+}
+#endif // defined(DBG_SHMOO_CS)
+
+#if defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+static void bist_single(enum bist_mode mode)
+{
+	//uint32_t sram_sp;
+	uint32_t bist_result;
+	uint64_t err_data_odd;
+	uint64_t err_data_even;
+
+	if (mode == E_PRBS)
+		cvx16_bist_wr_prbs_init();
+	if (mode == E_SRAM) {
+		cvx16_bist_wr_sram_init();
+	}
+
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+
+	KC_MSG("bist_result=%x, err_data_odd=%x, err_data_even=%x\n", bist_result, err_data_odd, err_data_even);
+}
+
+void ddr_training(enum train_mode t_mode)
+{
+	uint32_t mode;
+	uint32_t rddata;
+
+	// sram_sp =0
+	if (t_mode == E_WRLVL) {
+		// wrlvl
+		cvx16_wrlvl_req();
+		// cvx16_wrlvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_RDGLVL) {
+		// rdglvl
+		cvx16_rdglvl_req();
+		// cvx16_rdglvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_WDQLVL) {
+		// wdqlvl
+		mode = 1;
+		// data_mode = 'h0 : phyd pattern
+		// data_mode = 'h1 : bist read/write
+		// data_mode = 'h11: with Error enject,  multi- bist write/read
+		// data_mode = 'h12: with Error enject,  multi- bist write/read
+		// lvl_mode  = 'h0 : wdmlvl
+		// lvl_mode  = 'h1 : wdqlvl
+		// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+		// cvx16_wdqlvl_req( data_mode,  lvl_mode,  sram_sp)
+		if (mode == 0) {
+			cvx16_wdqlvl_req(0, 2); // dq/dm
+		} else {
+			if (mode == 1) {
+				cvx16_wdqlvl_req(1, 2); // dq/dm
+				// cvx16_wdqlvl_req(1, 1); // dq
+				// cvx16_wdqlvl_req(1, 0); // dm
+			}
+		}
+		// cvx16_wdqlvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_RDLVL) {
+		// rdlvl
+		mode = 1;
+		// mode = 'h0  : MPR mode, DDR3 only.
+		// mode = 'h1  : sram write/read continuous goto
+		// mode = 'h2  : multi- bist write/read
+		// mode = 'h10 : with Error enject,  multi- bist write/read
+		// mode = 'h12 : with Error enject,  multi- bist write/read
+
+		if (mode == 0) {
+			rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, 1, 4, 4); // Dataflow from MPR
+			mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+			cvx16_rdlvl_req(0);
+			rddata = mmio_rd32(0x0188 + PHYD_BASE_ADDR);
+			rddata = modified_bits_by_value(rddata, 0, 4, 4); // Dataflow from MPR
+			mmio_wr32(0x0188 + PHYD_BASE_ADDR, rddata);
+		} else {
+			cvx16_rdlvl_req(mode);
+		}
+		// cvx16_rdlvl_status();
+		bist_single(E_PRBS);
+	}
+
+	if (t_mode == E_WDQLVL_SW) {
+		// wdqlvl_sw
+
+		KC_MSG("wdqlvl_SW_M1_ALL\n");
+		// data_mode = 'h0 : phyd pattern
+		// data_mode = 'h1 : bist read/write
+		// data_mode = 'h11: with Error enject,  multi- bist write/read
+		// data_mode = 'h12: with Error enject,  multi- bist write/read
+		// lvl_mode  = 'h0 : wdmlvl
+		// lvl_mode  = 'h1 : wdqlvl
+		// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+		// cvx16_wdqlvl_req(data_mode, lvl_mode)
+		rddata = 0x00000000;
+		rddata = modified_bits_by_value(rddata, 0x0c, 6, 0);  //param_phyd_dfi_wdqlvl_vref_start
+		rddata = modified_bits_by_value(rddata, 0x13, 14, 8); //param_phyd_dfi_wdqlvl_vref_end
+		rddata = modified_bits_by_value(rddata, 0x2, 19, 16); //param_phyd_dfi_wdqlvl_vref_step
+		mmio_wr32(0x0190 + PHYD_BASE_ADDR, rddata);
+		KC_MSG("cvx16_wdqlvl_sw_req\n");
+		cvx16_wdqlvl_sw_req(1, 2);
+		// cvx16_wdqlvl_status();
+		KC_MSG("cvx16_wdqlvl_req dq/dm finish\n");
+	}
+
+	if (t_mode == E_RDLVL_SW) {
+		// rdlvl_sw
+		rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+		rddata = modified_bits_by_value(rddata, 1, 7, 4); //param_phyd_pirdlvl_capture_cnt
+		mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+
+		KC_MSG("SW mode 1, sram write/read continuous goto\n");
+		cvx16_rdlvl_sw_req(1);
+		// cvx16_rdlvl_status();
+		KC_MSG("cvx16_rdlvl_req finish\n");
+	}
+}
+#endif // defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+
+#ifdef DBG_SHMOO_CA
+void calvl_req(uint32_t capacity)
+{
+	uint32_t i, j;
+	uint32_t vrefca_start = 0x02;
+	uint32_t vrefca_end   = 0x1f;
+	uint32_t vrefca_step  = 0x02;
+	uint32_t shift_start  = 0x02;
+	uint32_t shift_end    = 0x07;
+	uint32_t delay_start  = 0x00;
+	uint32_t delay_end    = 0x40;
+	uint32_t delay_step   = 0x04;
+
+	uartlog("=== calvl_req ===\n");
+	// if DDR3_4G:
+	//     capacity=4
+	// if DDR3_2G:
+	//     capacity=2
+	// if DDR3_1G:
+	//     capacity=1
+	// if DDR3_DBG:
+	//     capacity=4
+	// if N25_DDR2_512:
+	//     capacity=0
+
+	// for i in range(vrefca_start, vrefca_end+1, vrefca_step):
+	for (i = vrefca_start; i < (vrefca_end + 1); i += vrefca_step) {
+		uint32_t vrefca_sel = i;
+		uint32_t shift_delay_start = (shift_start << 7) + delay_start;
+		uint32_t shift_delay_end = (shift_end << 7) + delay_end + 1;
+		uint32_t bist_result = 0;
+
+		uartlog("vrefca_start = %08x\n", i);
+		// for j in range(shift_delay_start, shift_delay_end, delay_step):
+		for (j = shift_delay_start; j < shift_delay_end; j += delay_step) {
+			uint32_t shift_delay;
+
+			if (bist_result == 0) {
+				ddr_sys_init();
+				ddr_training(E_WRLVL);
+				ddr_training(E_RDGLVL);
+			#ifdef DDR3_DBG
+				ddr_training(E_RDLVL);
+			#endif //DDR3_DBG
+				ddr_training(E_WDQLVL);
+				ddr_training(E_RDLVL);
+				cvx16_clk_gating_disable();
+				set_ca_vref(vrefca_sel);
+			}
+			// #mmio_wr32(0x0414 + PHYD_BASE_ADDR, vrefca_sel) #param_phya_reg_tx_vrefca_sel
+			// #time.sleep(0.1)
+			uartlog("shift_delay_before = %08x\n", j);
+
+			shift_delay = ((get_bits_from_value(j, 12, 7)) << 8) + (get_bits_from_value(j, 6, 0));
+
+			uartlog("shift_delay_after = %08x\n", shift_delay);
+			cvx16_ca_shift_delay(shift_delay);
+			// #bist_single_calvl(mode="prbs", shift_delay=j, vrefca=vrefca_sel)
+
+		#if 1 //ca park 1
+			cvx16_dfi_ca_park_prbs(1);
+			bist_result = bist_all_dram_calvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#else //ca park 0
+			cvx16_dfi_ca_park_prbs(0);
+			bist_result = bist_all_dram_calvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#endif
+		}
+	}
+	// re-init
+	ddr_sys_init();
+	ddr_training(E_WRLVL);
+	ddr_training(E_RDGLVL);
+#ifdef DDR3_DBG
+	ddr_training(E_RDLVL);
+#endif //DDR3_DBG
+	ddr_training(E_WDQLVL);
+	ddr_training(E_RDLVL);
+
+	cvx16_clk_gating_enable();
+}
+#endif // DBG_SHMOO_CA
+
+#ifdef DBG_SHMOO_CS
+void cslvl_req(uint32_t capacity)
+{
+	uint32_t i, j;
+	//TODO
+	uint32_t vrefca_start = 0x02;
+	uint32_t vrefca_end   = 0x1f;
+	uint32_t vrefca_step  = 0x02;
+	uint32_t shift_start  = 0x02;
+	uint32_t shift_end    = 0x05;
+	uint32_t delay_start  = 0x40;
+	uint32_t delay_end    = 0x40;
+	uint32_t delay_step   = 0x04;
+
+	uartlog("=== cslvl_req ===\n");
+	// if DDR3_4G:
+	//     capacity=4
+	// if DDR3_2G:
+	//     capacity=2
+	// if DDR3_1G:
+	//     capacity=1
+	// if DDR3_DBG:
+	//     capacity=4
+	// if N25_DDR2_512:
+	//     capacity=0
+
+	// for i in range(vrefca_start, vrefca_end+1, vrefca_step):
+	for (i = vrefca_start; i < (vrefca_end + 1); i += vrefca_step) {
+		uint32_t vrefca_sel = i;
+		uint32_t shift_delay_start = (shift_start << 7) + delay_start;
+		uint32_t shift_delay_end = (shift_end << 7) + delay_end + 1;
+		uint32_t bist_result = 0;
+
+		uartlog("vrefca_start = %08x\n", i);
+		// for j in range(shift_delay_start, shift_delay_end, delay_step):
+		for (j = shift_delay_start; j < shift_delay_end; j += delay_step) {
+			uint32_t shift_delay;
+
+			if (bist_result == 0) {
+				ddr_sys_init();
+				ddr_training(E_WRLVL);
+				ddr_training(E_RDGLVL);
+			#ifdef DDR3_DBG
+				ddr_training(E_RDLVL);
+			#endif //DDR3_DBG
+				ddr_training(E_WDQLVL);
+				ddr_training(E_RDLVL);
+				cvx16_clk_gating_disable();
+				set_ca_vref(vrefca_sel);
+			}
+			// #mmio_wr32(0x0414 + PHYD_BASE_ADDR, vrefca_sel) #param_phya_reg_tx_vrefca_sel
+			// #time.sleep(0.1)
+			uartlog("shift_delay_before = %08x\n", j);
+
+			shift_delay = ((get_bits_from_value(j, 12, 7)) << 8) + (get_bits_from_value(j, 6, 0));
+
+			uartlog("shift_delay_after = %08x\n", shift_delay);
+			cvx16_cs_shift_delay(shift_delay);
+			// #bist_single_calvl(mode="prbs", shift_delay=j, vrefca=vrefca_sel)
+
+		#if 1 //ca park 1
+			cvx16_dfi_ca_park_prbs(1);
+			bist_result = bist_all_dram_cslvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#else //ca park 0
+			cvx16_dfi_ca_park_prbs(0);
+			bist_result = bist_all_dram_cslvl(0, capacity, j, vrefca_sel); //0: prbs
+			cvx16_dfi_ca_park_prbs(0);
+		#endif
+		}
+	}
+	// re-init
+	ddr_sys_init();
+	ddr_training(E_WRLVL);
+	ddr_training(E_RDGLVL);
+#ifdef DDR3_DBG
+	ddr_training(E_RDLVL);
+#endif //DDR3_DBG
+	ddr_training(E_WDQLVL);
+	ddr_training(E_RDLVL);
+
+	cvx16_clk_gating_enable();
+}
+#endif // DBG_SHMOO_CS
+
+#pragma GCC diagnostic pop
diff --git a/firmware/plat/cv181x/ddr/ddr_sys_bring_up.c b/firmware/plat/cv181x/ddr/ddr_sys_bring_up.c
new file mode 100644
index 0000000..b44288f
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/ddr_sys_bring_up.c
@@ -0,0 +1,547 @@
+#include <platform_def.h>
+#include <reg_soc.h>
+#include <phy_pll_init.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+#include <mmio.h>
+#include <bitwise_ops.h>
+#include <cvx16_dram_cap_check.h>
+#include <cvx16_pinmux.h>
+#include <regconfig.h>
+#include <console.h>
+#include <ddr_pkg_info.h>
+
+#define DO_BIST
+
+#define REMAPPING_BASE 0
+#define AXIMON_M1_WRITE	(REMAPPING_BASE + 0x0)
+#define AXIMON_M1_READ	(REMAPPING_BASE + 0x80)
+#define AXIMON_M2_WRITE	(REMAPPING_BASE + 0x100)
+#define AXIMON_M2_READ	(REMAPPING_BASE + 0x180)
+#define AXIMON_M3_WRITE	(REMAPPING_BASE + 0x200)
+#define AXIMON_M3_READ	(REMAPPING_BASE + 0x280)
+#define AXIMON_M4_WRITE	(REMAPPING_BASE + 0x300)
+#define AXIMON_M4_READ	(REMAPPING_BASE + 0x380)
+#define AXIMON_M5_WRITE	(REMAPPING_BASE + 0x400)
+#define AXIMON_M5_READ	(REMAPPING_BASE + 0x480)
+#define AXIMON_M6_WRITE	(REMAPPING_BASE + 0x500)
+#define AXIMON_M6_READ	(REMAPPING_BASE + 0x580)
+
+#define AXIMON_OFFSET_CYCLE 0x24
+#define AXIMON_OFFSET_BYTECNTS 0x2C
+#define AXIMON_OFFSET_LATENCYCNTS 0x34
+#define AXIMON_OFFSET_HITCNTS 0x28
+#define AXIMON_OFFSET_LAT_BIN_SIZE_SEL 0x50
+
+#define AXIMON_START_REGVALUE 0x30001
+#define AXIMON_STOP_REGVALUE 0x30002
+
+static void axi_mon_latency_setting(uint32_t lat_bin_size_sel)
+{
+	uint32_t rdata;
+
+	//for ddr3 1866: bin_size_sel=0d'5
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_WRITE + AXIMON_OFFSET_LAT_BIN_SIZE_SEL), lat_bin_size_sel);
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_READ + AXIMON_OFFSET_LAT_BIN_SIZE_SEL), lat_bin_size_sel);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_WRITE + 0x00), 0x01000100);//input clk sel
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M1_WRITE + 0x04));//hit sel setting
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_WRITE + 0x04), rdata);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_READ + 0x00), 0x01000100);
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M1_READ + 0x04));
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M1_READ + 0x04), rdata);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_WRITE + AXIMON_OFFSET_LAT_BIN_SIZE_SEL), lat_bin_size_sel);
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_READ + AXIMON_OFFSET_LAT_BIN_SIZE_SEL), lat_bin_size_sel);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_WRITE + 0x00), 0x01000100);
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M5_WRITE + 0x04));
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_WRITE + 0x04), rdata);
+
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_READ + 0x00), 0x01000100);
+	rdata = mmio_rd32((AXI_MON_BASE + AXIMON_M5_READ + 0x04));
+	rdata = rdata & 0xfffffc00;
+	rdata = rdata | 0x00000000;
+	mmio_wr32((AXI_MON_BASE + AXIMON_M5_READ + 0x04), rdata);
+
+	//ERROR("mon cg en.\n");
+	rdata = mmio_rd32((DDR_TOP_BASE+0x14));
+	rdata = rdata | 0x00000100;
+	mmio_wr32((DDR_TOP_BASE+0x14), rdata);
+}
+
+static void load_ddr_patch_set_data(void)
+{
+	// NOTICE("ddr_patch_regs_count=%d\n", ddr_patch_regs_count);
+#ifndef DDR2_3
+	for (int i = 0; i < ddr_patch_regs_count; i++) {
+		uint32_t addr = ddr_patch_regs[i].addr;
+		uint32_t mask = ddr_patch_regs[i].mask;
+		uint32_t val = ddr_patch_regs[i].val;
+
+		uint32_t orig;
+
+		orig = mmio_rd32(addr);
+		orig &= ~mask;
+		mmio_wr32(addr, orig | (val & mask));
+	}
+#else
+		if (get_ddr_type() == DDR_TYPE_DDR3) {
+			for (int i = 0; i < ddr3_1866_patch_regs_count; i++) {
+				uint32_t addr = ddr3_1866_patch_regs[i].addr;
+				uint32_t mask = ddr3_1866_patch_regs[i].mask;
+				uint32_t val = ddr3_1866_patch_regs[i].val;
+
+				uint32_t orig;
+
+				orig = mmio_rd32(addr);
+				orig &= ~mask;
+				mmio_wr32(addr, orig | (val & mask));
+			}
+		} else if (get_ddr_type() == DDR_TYPE_DDR2) {
+			for (int i = 0; i < ddr2_1333_patch_regs_count; i++) {
+				uint32_t addr = ddr2_1333_patch_regs[i].addr;
+				uint32_t mask = ddr2_1333_patch_regs[i].mask;
+				uint32_t val = ddr2_1333_patch_regs[i].val;
+
+				uint32_t orig;
+
+				orig = mmio_rd32(addr);
+				orig &= ~mask;
+				mmio_wr32(addr, orig | (val & mask));
+			}
+		} else {
+			NOTICE("error ddr type.\n");
+		}
+#endif
+}
+
+static void ddr_patch_set(void)
+{
+	load_ddr_patch_set_data();
+
+#ifdef DDR3_DBG
+	mmio_wr32(0x005C + PHYD_BASE_ADDR, 0x00FE0000); //wrlvl response only DQ0
+#endif //DDR3_DBG
+}
+
+static void axi_mon_start(uint32_t base_register)
+{
+	mmio_wr32((AXI_MON_BASE + base_register), AXIMON_START_REGVALUE);
+}
+
+void axi_mon_start_all(void)
+{
+	axi_mon_start(AXIMON_M1_WRITE);
+	axi_mon_start(AXIMON_M1_READ);
+	axi_mon_start(AXIMON_M2_WRITE);
+	axi_mon_start(AXIMON_M2_READ);
+	axi_mon_start(AXIMON_M3_WRITE);
+	axi_mon_start(AXIMON_M3_READ);
+	axi_mon_start(AXIMON_M4_WRITE);
+	axi_mon_start(AXIMON_M4_READ);
+	axi_mon_start(AXIMON_M5_WRITE);
+	axi_mon_start(AXIMON_M5_READ);
+	axi_mon_start(AXIMON_M6_WRITE);
+	axi_mon_start(AXIMON_M6_READ);
+}
+
+void dump_axi_mon_reg(uint32_t base_register)
+{
+	uint i = 0;
+
+	for (i = 0; i <= 0x7c; i = i+0x10) {
+		ERROR("0x%08x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n", AXI_MON_BASE + base_register+i,
+				mmio_rd32(AXI_MON_BASE + base_register+i),
+				mmio_rd32(AXI_MON_BASE + base_register+i+0x4),
+				mmio_rd32(AXI_MON_BASE + base_register+i+0x8),
+				mmio_rd32(AXI_MON_BASE + base_register+i+0xc));
+	}
+}
+
+void ddr_sys_bring_up(void)
+{
+	uint32_t bist_result;
+	uint64_t err_data_even, err_data_odd;
+	uint8_t dram_cap_in_mbyte;
+
+#if defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS) || defined(FULL_MEM_BIST) || defined(FULL_MEM_BIST_FOREVER)
+	uint32_t cap = 1;
+
+	// switch (get_ddr_capacity()) {
+	// case DDR_CAPACITY_1G: cap = 1; break;
+	// case DDR_CAPACITY_2G: cap = 2; break;
+	// case DDR_CAPACITY_4G: cap = 4; break;
+	// default: cap = 1;
+	// }
+	uartlog("cap=%d\n", cap);
+#endif //FULL_MEM_BIST || FULL_MEM_BIST_FOREVER
+
+	uartlog("%s pattern!\n", __func__);
+
+	// mmio_wr32(PLLG6_BASE+top_pll_g6_reg_ddr_ssc_syn_src_en,
+	//            mmio_rd32(PLLG6_BASE+top_pll_g6_reg_ddr_ssc_syn_src_en)
+	//            &(~top_pll_g6_reg_ddr_ssc_syn_src_en_MASK)
+	//            |0x1<<top_pll_g6_reg_ddr_ssc_syn_src_en_OFFSET);
+
+#ifdef REAL_DDRPHY
+	uartlog("PLL INIT !\n");
+	pll_init();
+#endif
+
+	uartlog("DDRC_INIT !\n");
+	ddrc_init();
+
+	// cvx16_ctrlupd_short();
+
+	// release ddrc soft reset
+	uartlog("releast reset  !\n");
+	mmio_wr32(DDR_TOP_BASE + 0x20, 0x0);
+
+	// set axi QOS
+	// M1 = 0xA (VIP realtime)
+	// M2 = 0x8 (VIP offline)
+	// M3 = 0x7 (CPU)
+	// M4 = 0x0 (TPU)
+	// M5 = 0x9 (Video codec)
+	// M6 = 0x2 (high speed peri)
+	mmio_wr32(0x030001D8, 0x007788aa);
+	mmio_wr32(0x030001DC, 0x00002299);
+
+#ifdef REAL_DDRPHY
+	uartlog("phy_init !\n");
+	phy_init();
+#endif
+
+	cvx16_setting_check();
+	KC_MSG("cvx16_setting_check  finish\n");
+
+	// pinmux
+	cvx16_pinmux();
+	KC_MSG("cvx16_pinmux finish\n");
+
+	ddr_patch_set();
+
+	cvx16_en_rec_vol_mode();
+	KC_MSG("cvx16_en_rec_vol_mode finish\n");
+
+	// set_dfi_init_start
+	cvx16_set_dfi_init_start();
+	KC_MSG("set_dfi_init_start finish\n");
+
+	// ddr_phy_power_on_seq1
+	cvx16_ddr_phy_power_on_seq1();
+	KC_MSG("ddr_phy_power_on_seq1 finish\n");
+
+	// first dfi_init_start
+	KC_MSG("first dfi_init_start\n");
+	cvx16_polling_dfi_init_start();
+	KC_MSG("cvx16_polling_dfi_init_start finish\n");
+
+	cvx16_INT_ISR_08();
+	KC_MSG("cvx16_INT_ISR_08 finish\n");
+
+	// ddr_phy_power_on_seq3
+	cvx16_ddr_phy_power_on_seq3();
+	KC_MSG("ddr_phy_power_on_seq3 finish\n");
+
+	// wait_for_dfi_init_complete
+	cvx16_wait_for_dfi_init_complete();
+	KC_MSG("wait_for_dfi_init_complete finish\n");
+
+	// polling_synp_normal_mode
+	cvx16_polling_synp_normal_mode();
+	KC_MSG("polling_synp_normal_mode finish\n");
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		ERROR("ERROR bist_fail\n");
+		ERROR("bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+			  err_data_even);
+	}
+#endif
+
+	ctrl_init_low_patch();
+	KC_MSG("ctrl_low_patch finish\n");
+
+	// cvx16_wrlvl_req
+#ifndef DDR2
+#ifdef DDR2_3
+	if (get_ddr_type() == DDR_TYPE_DDR3) {
+		cvx16_wrlvl_req();
+		KC_MSG("cvx16_wrlvl_req finish\n");
+	}
+#else
+	cvx16_wrlvl_req();
+	KC_MSG("cvx16_wrlvl_req finish\n");
+#endif
+#endif
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		ERROR("ERROR bist_fail\n");
+		ERROR("bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+			  err_data_even);
+	}
+#endif
+	// cvx16_rdglvl_req
+	cvx16_rdglvl_req();
+	KC_MSG("cvx16_rdglvl_req finish\n");
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		ERROR("ERROR bist_fail\n");
+		ERROR("bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+			  err_data_even);
+	}
+#endif
+
+	//ERROR("AXI mon setting for latency histogram.\n");
+	//axi_mon_set_lat_bin_size(0x5);
+
+#ifdef DBG_SHMOO
+	// DPHY WDQ
+	// param_phyd_dfi_wdqlvl_vref_start [6:0]
+	// param_phyd_dfi_wdqlvl_vref_end [14:8]
+	// param_phyd_dfi_wdqlvl_vref_step [19:16]
+	mmio_wr32(0x08000190, 0x00021E02);
+
+	// param_phyd_piwdqlvl_dly_step[23:20]
+	mmio_wr32(0x080000a4, 0x01220504);
+
+	// write start   shift = 5  /  dline = 78
+	mmio_wr32(0x080000a0, 0x0d400578);
+
+	//write
+	KC_MSG("wdqlvl_M1_ALL_DQ_DM\n");
+	// data_mode = 'h0 : phyd pattern
+	// data_mode = 'h1 : bist read/write
+	// data_mode = 'h11: with Error enject,  multi- bist write/read
+	// data_mode = 'h12: with Error enject,  multi- bist write/read
+	// lvl_mode  = 'h0 : wdmlvl
+	// lvl_mode  = 'h1 : wdqlvl
+	// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+	// cvx16_wdqlvl_req(data_mode, lvl_mode)
+	NOTICE("cvx16_wdqlvl_sw_req dq/dm\n"); console_getc();
+	cvx16_wdqlvl_sw_req(1, 2);
+	// cvx16_wdqlvl_status();
+	KC_MSG("cvx16_wdqlvl_req dq/dm finish\n");
+
+	NOTICE("cvx16_wdqlvl_sw_req dq\n"); console_getc();
+	cvx16_wdqlvl_sw_req(1, 1);
+	// cvx16_wdqlvl_status();
+	KC_MSG("cvx16_wdqlvl_req dq finish\n");
+
+	NOTICE("cvx16_wdqlvl_sw_req dm\n"); console_getc();
+	cvx16_wdqlvl_sw_req(1, 0);
+	// cvx16_wdqlvl_status();
+	NOTICE("cvx16_wdqlvl_req dm finish\n");
+#else //DBG_SHMOO
+	// cvx16_wdqlvl_req
+	KC_MSG("wdqlvl_M1_ALL_DQ_DM\n");
+	// sso_8x1_c(5, 15, 0, 1, &sram_sp);//mode = write, input int fmin = 5, input int fmax = 15,
+					    //input int sram_st = 0, output int sram_sp
+
+	// data_mode = 'h0 : phyd pattern
+	// data_mode = 'h1 : bist read/write
+	// data_mode = 'h11: with Error enject,  multi- bist write/read
+	// data_mode = 'h12: with Error enject,  multi- bist write/read
+	// lvl_mode  = 'h0 : wdmlvl
+	// lvl_mode  = 'h1 : wdqlvl
+	// lvl_mode  = 'h2 : wdqlvl and wdmlvl
+	// cvx16_wdqlvl_req(data_mode, lvl_mode);
+	cvx16_wdqlvl_req(1, 2);
+	KC_MSG("cvx16_wdqlvl_req dq/dm finish\n");
+
+	cvx16_wdqlvl_req(1, 1);
+	KC_MSG("cvx16_wdqlvl_req dq finish\n");
+
+	cvx16_wdqlvl_req(1, 0);
+	KC_MSG("cvx16_wdqlvl_req dm finish\n");
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR bist_fail\n");
+	}
+#endif
+#endif //!DBG_SHMOO
+
+#ifdef DBG_SHMOO
+	// param_phyd_pirdlvl_dly_step [3:0]
+	// param_phyd_pirdlvl_vref_step [11:8]
+	mmio_wr32(0x08000088, 0x0A010212);
+
+	//read
+	NOTICE("cvx16_rdlvl_req start\n"); console_getc();
+	NOTICE("SW mode 1, sram write/read continuous goto\n");
+	cvx16_rdlvl_sw_req(1);
+	// cvx16_rdlvl_status();
+	NOTICE("cvx16_rdlvl_req finish\n");
+#else //DBG_SHMOO
+	// cvx16_rdlvl_req
+	// mode = 'h0  : MPR mode, DDR3 only.
+	// mode = 'h1  : sram write/read continuous goto
+	// mode = 'h2  : multi- bist write/read
+	// mode = 'h10 : with Error enject,  multi- bist write/read
+	// mode = 'h12 : with Error enject,  multi- bist write/read
+	rddata = mmio_rd32(0x008c + PHYD_BASE_ADDR);
+	rddata = modified_bits_by_value(rddata, 1, 7, 4); // param_phyd_pirdlvl_capture_cnt
+	mmio_wr32(0x008c + PHYD_BASE_ADDR, rddata);
+
+	KC_MSG("mode multi- bist write/read\n");
+	// cvx16_rdlvl_req(2); // mode multi- PRBS bist write/read
+	cvx16_rdlvl_req(1); // mode multi- SRAM bist write/read
+	KC_MSG("cvx16_rdlvl_req finish\n");
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR bist_fail\n");
+	}
+#endif
+#endif //!DBG_SHMOO
+
+#ifdef DBG_SHMOO_CA
+	//CA training
+	NOTICE("\n===== calvl_req =====\n"); console_getc();
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp_1);
+	calvl_req(cap);
+#endif //DBG_SHMOO_CA
+
+#ifdef DBG_SHMOO_CS
+	//CS training
+	NOTICE("\n===== cslvl_req =====\n"); console_getc();
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp_1);
+	cslvl_req(cap);
+#endif // DBG_SHMOO_CS
+
+#ifdef DBG_SHMOO
+	cvx16_dll_cal_status();
+	cvx16_wrlvl_status();
+	cvx16_rdglvl_status();
+	cvx16_rdlvl_status();
+	cvx16_wdqlvl_status();
+#endif // DBG_SHMOO
+
+	// ctrl_high_patch
+	ctrl_init_high_patch();
+
+	ctrl_init_detect_dram_size(&dram_cap_in_mbyte);
+	KC_MSG("ctrl_init_detect_dram_size finish\n");
+
+	ctrl_init_update_by_dram_size(dram_cap_in_mbyte);
+	KC_MSG("ctrl_init_update_by_dram_size finish\n");
+
+	KC_MSG("dram_cap_in_mbyte = %x\n", dram_cap_in_mbyte);
+	cvx16_dram_cap_check(dram_cap_in_mbyte);
+	KC_MSG("cvx16_dram_cap_check finish\n");
+
+	// clk_gating_enable
+	cvx16_clk_gating_enable();
+	KC_MSG("cvx16_clk_gating_enable finish\n");
+
+#ifdef DO_BIST
+	cvx16_bist_wr_prbs_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR prbs bist_fail\n");
+		NOTICE("DDR BIST FAIL\n");
+		while (1) {
+		}
+	}
+
+	cvx16_bist_wr_sram_init();
+	cvx16_bist_start_check(&bist_result, &err_data_odd, &err_data_even);
+	KC_MSG(", bist_result = %x, err_data_odd = %lx, err_data_even = %lx\n", bist_result, err_data_odd,
+	       err_data_even);
+	if (bist_result == 0) {
+		KC_MSG("ERROR sram bist_fail\n");
+		NOTICE("DDR BIST FAIL\n");
+		while (1) {
+		}
+	}
+	NOTICE("DDR BIST PASS\n");
+#endif
+
+#ifdef FULL_MEM_BIST
+	//full memory
+	// sso_8x1_c(5, 15, 0, 1, &sram_sp);
+	// sso_8x1_c(5, 15, sram_sp, 1, &sram_sp);
+
+	NOTICE("====FULL_MEM_BIST====\n");
+	bist_result = bist_all_dram(0, cap);
+	if (bist_result == 0) {
+		NOTICE("bist_all_dram(prbs): ERROR bist_fail\n");
+	} else {
+		NOTICE("bist_all_dram(prbs): BIST PASS\n");
+	}
+
+	bist_result = bist_all_dram(1, cap);
+	if (bist_result == 0) {
+		NOTICE("bist_all_dram(sram): ERROR bist_fail\n");
+	} else {
+		NOTICE("bist_all_dram(sram): BIST PASS\n");
+	}
+
+	bist_result = bist_all_dram(2, cap);
+	if (bist_result == 0) {
+		NOTICE("bist_all_dram(01): ERROR bist_fail\n");
+	} else {
+		NOTICE("bist_all_dram(01): BIST PASS\n");
+	}
+
+	NOTICE("===== BIST END ======\n");
+#endif //FULL_MEM_BIST
+
+#ifdef FULL_MEM_BIST_FOREVER
+	NOTICE("Press any key to start stress test\n"); console_getc();
+	bist_all_dram_forever(cap);
+#endif //FULL_MEM_BIST_FOREVER
+
+	//ERROR("AXI mon setting for latency histogram.\n");
+	axi_mon_latency_setting(0x5);
+
+	//ERROR("AXI mon 0 register dump before start.\n");
+	//dump_axi_mon_reg(AXIMON_M1_WRITE);
+	//ERROR("AXI mon 1 register dump before start.\n");
+	//dump_axi_mon_reg(AXIMON_M1_READ);
+
+	axi_mon_start_all();
+
+#if defined(DBG_SHMOO) || defined(DBG_SHMOO_CA) || defined(DBG_SHMOO_CS)
+	while (1)
+		;
+#endif
+
+}
diff --git a/firmware/plat/cv181x/ddr/phy_pll_init.c b/firmware/plat/cv181x/ddr/phy_pll_init.c
new file mode 100644
index 0000000..754ffba
--- /dev/null
+++ b/firmware/plat/cv181x/ddr/phy_pll_init.c
@@ -0,0 +1,40 @@
+#include <platform.h>
+#include <ddr_sys.h>
+#ifdef DDR2_3
+#include <ddr3_1866_init.h>
+#include <ddr2_1333_init.h>
+#else
+#include <ddr_init.h>
+#endif
+
+uint32_t  freq_in;
+uint32_t  tar_freq;
+uint32_t  mod_freq;
+uint32_t  dev_freq;
+uint64_t  reg_set;
+uint64_t  reg_span;
+uint64_t  reg_step;
+
+void pll_init(void)
+{
+	freq_in = 752;
+	mod_freq = 100;
+	dev_freq = 15;
+	NOTICE("Data rate=%d.\n", ddr_data_rate);
+#ifdef SSC_EN
+	tar_freq = (ddr_data_rate >> 4) * 0.985;
+#else
+	tar_freq = (ddr_data_rate >> 4);
+#endif
+	reg_set = (uint64_t)freq_in * 67108864 / tar_freq;
+	reg_span = ((tar_freq * 250) / mod_freq);
+	reg_step = reg_set * dev_freq / (reg_span * 1000);
+	uartlog("ddr_data_rate = %d, freq_in = %d reg_set = %lx tar_freq = %x reg_span = %lx reg_step = %lx\n",
+		ddr_data_rate, freq_in, reg_set, tar_freq, reg_span, reg_step);
+	// uartlog("reg_set = %lx\n", reg_set);
+	// uartlog("tar_freq = %x\n", tar_freq);
+	// uartlog("reg_span = %lx\n", reg_span);
+	// uartlog("reg_step = %lx\n", reg_step);
+
+	cvx16_pll_init();
+}
diff --git a/firmware/plat/cv181x/include/platform.h b/firmware/plat/cv181x/include/platform.h
index e610c18..b899e88 100644
--- a/firmware/plat/cv181x/include/platform.h
+++ b/firmware/plat/cv181x/include/platform.h
@@ -51,6 +51,12 @@ enum CHIP_CONF_CMD {
 	CHIP_CONF_CMD_DELAY_MS = 0xFFFFFFFD
 };
 
+enum CHIP_CLK_MODE {
+	CLK_ND = 0,
+	CLK_OD,
+	CLK_VC_OD
+};
+
 void apply_chip_conf(const struct chip_conf chip_conf[], uint32_t size, enum CHIP_CONF_CMD scan_start,
 		     enum CHIP_CONF_CMD scan_end);
 
@@ -112,14 +118,12 @@ void set_rtc_en_registers(void);
 
 void apply_analog_trimming_data(void);
 
-void sys_pll_init(void);
-void sys_pll_init_od_sel(void);
+void sys_pll_init(enum CHIP_CLK_MODE mode);
 void sys_switch_all_to_pll(void);
 
 void lock_efuse_chipsn(void);
 int load_ddr(void);
-int load_rest(void);
-int load_rest_od_sel(void);
+int load_rest(enum CHIP_CLK_MODE mode);
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/firmware/plat/cv181x/include/platform_def.h b/firmware/plat/cv181x/include/platform_def.h
index 1ac5cde..85bf764 100644
--- a/firmware/plat/cv181x/include/platform_def.h
+++ b/firmware/plat/cv181x/include/platform_def.h
@@ -322,6 +322,7 @@ extern struct _time_records *time_records;
 #define BOOT_SOURCE_FLAG_SIZE 4
 #define MAGIC_NUM_USB_DL 0x4D474E31 // MGN1
 #define MAGIC_NUM_SD_DL 0x4D474E32 // MGN2
+#define MAGIC_NUM_UART_DL 0x4D474E33 // MGN3
 
 #define BOOT_LOG_LEN_ADDR (BOOT_SOURCE_FLAG_ADDR + BOOT_SOURCE_FLAG_SIZE) // 0x0E000008
 #define BOOT_LOG_LEN_SIZE 4
@@ -461,6 +462,7 @@ extern struct _time_records *time_records;
  */
 #define UART_DL_MAGIC 0x5552444c // "URDL"
 #define UART_DL_KERMIT_TIMEROUT 10000 // ms
+#define UART_DL_BAUDRATE 1500000
 
 /*
  * SD/EMMC definitions
diff --git a/firmware/plat/cv181x/platform.c b/firmware/plat/cv181x/platform.c
new file mode 100644
index 0000000..30af646
--- /dev/null
+++ b/firmware/plat/cv181x/platform.c
@@ -0,0 +1,540 @@
+#include <cpu.h>
+#include <mmio.h>
+#include <debug.h>
+#include <assert.h>
+#include <errno.h>
+#include <bl_common.h>
+#include <platform.h>
+#include <delay_timer.h>
+#include <console.h>
+#include <string.h>
+#include <rom_api.h>
+
+#include "ddr_pkg_info.h"
+#include "rtc.h"
+
+void panic_handler(void)
+{
+	void *ra;
+
+	ATF_ERR = ATF_ERR_PLAT_PANIC;
+
+	ra = __builtin_return_address(0);
+	mmio_write_32(ATF_ERR_INFO0, ((uint64_t)ra) & 0xFFFFFFFFUL);
+
+	ERROR("ra=0x%lx\n", (uint64_t)ra);
+
+	__system_reset("panic", -1);
+	__builtin_unreachable();
+}
+
+void __system_reset(const char *file, unsigned int line)
+{
+	ATF_ERR = ATF_ERR_PLAT_SYSTEM_RESET;
+	ERROR("RESET:%s:%d\n", file, line);
+
+	console_flush();
+
+	ATF_STATE = ATF_STATE_RESET_WAIT;
+	mdelay(5000);
+
+	// enable rtc wdt reset
+	mmio_write_32(0x050260E0, 0x0001); //enable rtc_core wathdog reset enable
+	mmio_write_32(0x050260C8, 0x0001); //enable rtc_core power cycle   enable
+
+	// sw delay 100us
+	ATF_STATE = ATF_STATE_RESET_RTC_WAIT;
+	udelay(100);
+
+	// mmio_write_32(0x05025018,0x00FFFFFF); //Mercury rtcsys_rstn_src_sel
+	mmio_write_32(0x050250AC, 0x00000000); //cv181x rtcsys_rstn_src_sel
+	mmio_write_32(0x05025004, 0x0000AB18);
+	mmio_write_32(0x05025008, 0x00400040); //enable rtc_ctrl wathdog reset enable
+
+	// printf("Enable TOP_WDT\n");
+	// mmio_write_32(0x03010004,0x00000000); //config watch dog 2.6ms
+	// mmio_write_32(0x03010004,0x00000022); //config watch dog 166ms
+	mmio_write_32(0x03010004, 0x00000066); //config watch dog 166ms
+	mmio_write_32(0x0301001c, 0x00000020);
+	mmio_write_32(0x0301000c, 0x00000076);
+	mmio_write_32(0x03010000, 0x00000011);
+
+	// ROM_PWR_CYC
+	if (get_sw_info()->reset_type == 1) {
+		ATF_ERR = ATF_ERR_PLAT_SYSTEM_PWR_CYC;
+		// printf("Issue RTCSYS_PWR_CYC\n");
+
+		// wait pmu state to ON
+		while (mmio_read_32(0x050260D4) != 0x00000003) {
+			;
+		}
+
+		mmio_write_32(0x05025008, 0x00080008);
+	}
+
+	while (1)
+		;
+
+	__builtin_unreachable();
+}
+
+void reset_c906l(uintptr_t reset_address)
+{
+	NOTICE("RSC.\n");
+
+	mmio_clrbits_32(0x3003024, 1 << 6);
+
+	mmio_setbits_32(SEC_SYS_BASE + 0x04, 1 << 13);
+	mmio_write_32(SEC_SYS_BASE + 0x20, reset_address);
+	mmio_write_32(SEC_SYS_BASE + 0x24, reset_address >> 32);
+
+	mmio_setbits_32(0x3003024, 1 << 6);
+}
+
+void setup_dl_flag(void)
+{
+	uint32_t v = p_rom_api_get_boot_src();
+
+	switch (v) {
+	case BOOT_SRC_UART:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, MAGIC_NUM_UART_DL);
+		break;
+	case BOOT_SRC_SD:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, MAGIC_NUM_SD_DL);
+		break;
+	case BOOT_SRC_USB:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, MAGIC_NUM_USB_DL);
+		break;
+	default:
+		mmio_write_32(BOOT_SOURCE_FLAG_ADDR, v);
+		break;
+	}
+}
+
+void config_core_power(uint32_t low_period)
+{
+	/*
+	 * low_period = 0x42; // 0.90V
+	 * low_period = 0x48; // 0.93V
+	 * low_period = 0x4F; // 0.96V
+	 * low_period = 0x58; // 1.00V
+	 * low_period = 0x5C; // 1.02V
+	 * low_period = 0x62; // 1.05V
+	 * low_period = 0x62; // 1.05V
+	 */
+	mmio_write_32(PWM0_BASE + PWM_HLPERIOD0, low_period);
+	mmio_write_32(PWM0_BASE + PWM_PERIOD0, 0x64);
+	mmio_write_32(PINMUX_BASE + 0xEC, 0x0); // set pinmux for pwm0
+	mmio_write_32(PWM0_BASE + PWM_START, 0x1); // enable bit0:pwm0 and bit3:pwm3
+	mmio_write_32(PWM0_BASE + PWM_OE, 0x1); // output enable bit0:pwm0 and bit3:pwm3
+	mdelay(10);
+}
+
+void sys_switch_all_to_pll(void)
+{
+	// Switch all clocks to PLL
+	mmio_write_32(0x03002030, 0x0); // REG_CLK_BYPASS_SEL0_REG
+	mmio_write_32(0x03002034, 0x0); // REG_CLK_BYPASS_SEL1_REG
+}
+
+void sys_pll_od(void)
+{
+	// OD clk setting
+	uint32_t value;
+	uint32_t byp0_value;
+
+	uint32_t pll_syn_set[] = {
+		614400000, // set apll synthesizer  98.304 M
+		610080582, // set disp synthesizer  99 M
+		610080582, // set cam0 synthesizer  99 M
+		586388132, // set cam1 synthesizer  103 M
+	};
+
+	uint32_t pll_csr[] = {
+		0x00208201, // set apll *16/2 (786.432 MHz)
+		0x00188101, // set disp *12/1 (1188 MHz)
+		// 0x00188101, // set cam0 *12/1 (1188 MHz)
+		0x00308201, // set cam0 *24/2 (1188 MHz)
+		0x00148101, // set cam1 *10/1 (1030 MHz)
+	};
+
+	NOTICE("PLLS/OD.\n");
+
+	// set vddc for OD clock
+	config_core_power(0x58); //1.00V
+
+	// store byp0 value
+	byp0_value = mmio_read_32(0x03002030);
+
+	// switch clock to xtal
+	mmio_write_32(0x03002030, 0xffffffff);
+	mmio_write_32(0x03002034, 0x0000003f);
+
+	//set mipipll = 900MHz
+	mmio_write_32(0x03002808, 0x05488101);
+
+	// set synthersizer clock
+	mmio_write_32(REG_PLL_G2_SSC_SYN_CTRL, 0x3F); // enable synthesizer clock enable,
+		// [0]: 1: MIPIMPLL(900)/1=900MHz,
+		//      0: MIPIMPLL(900)/2=450MHz
+
+	for (uint32_t i = 0; i < 4; i++) {
+		mmio_write_32(REG_APLL_SSC_SYN_SET + 0x10 * i, pll_syn_set[i]); // set pll_syn_set
+
+		value = mmio_read_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i);
+		value |= 1; // [0]: sw update (w1t: write one toggle)
+		value &= ~(1 << 4); // [4]: bypass = 0
+		mmio_write_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i, value);
+
+		mmio_write_32(REG_APLL0_CSR + 4 * i, pll_csr[i]); // set pll_csr
+	}
+
+	value = mmio_read_32(REG_PLL_G2_CTRL);
+	value = value & (~0x00011111);
+	mmio_write_32(REG_PLL_G2_CTRL, value); //clear all pll PD
+
+#ifdef __riscv
+	// set mpll = 1050MHz
+	mmio_write_32(0x03002908, 0x05548101);
+
+	// set clk_sel_23: [23] clk_sel for clk_c906_0 = 1 (DIV_IN0_SRC_MUX)
+	// set clk_sel_24: [24] clk_sel for clk_c906_1 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x01800000);
+
+	// set div, src_mux of clk_c906_0: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll), 1050/1 = 1050MHz
+	mmio_write_32(0x03002130, 0x00010309);
+
+	// set div, src_mux of clk_c906_1: [20:16]div_factor=1, [9:8]clk_src = 1 (a0pll), 786.432/1 = 786.432MHz
+	mmio_write_32(0x03002138, 0x00010109);
+#else
+	// set mpll = 1000MHz
+	mmio_write_32(0x03002908, 0x05508101);
+
+	// set clk_sel_0: [0] clk_sel for clk_a53 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x00000001);
+
+	// set div, src_mux of clk_a53: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll)
+	mmio_write_32(0x03002040, 0x00010309);
+#endif
+
+	// set tpll = 1400MHz
+	mmio_write_32(0x0300290C, 0x07708101);
+
+	mmio_write_32(0x03002048, 0x00030009); //clk_cpu_axi0 = FPLL(1500) / 3
+	mmio_write_32(0x03002054, 0x00020009); //clk_tpu = TPLL(1400) / 2 = 700MHz
+	mmio_write_32(0x03002064, 0x00080009); //clk_emmc = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002088, 0x00080009); //clk_spi_nand = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002098, 0x00200009); //clk_sdma_aud0 = APLL(786.432) / 32 = 24.576MHz
+	mmio_write_32(0x03002120, 0x000F0009); //clk_pwm_src = FPLL(1500) / 15 = 100MHz
+	mmio_write_32(0x030020A8, 0x00010009); //clk_uart -> clk_cam0_200 = XTAL(25) / 1 = 25MHz
+	mmio_write_32(0x030020E4, 0x00020109); //clk_axi_video_codec = MIPIMPLL(900) / 2 = 450MHz
+	mmio_write_32(0x030020EC, 0x00020209); //clk_vc_src0 = CAM1PLL(1030) / 2 = 515MHz
+	mmio_write_32(0x030020C8, 0x00030009); //clk_axi_vip = MIPIPLL(900) / 3 = 300MHz
+	mmio_write_32(0x030020D0, 0x00060309); //clk_src_vip_sys_0 = FPLL(1500) / 6 = 250MHz
+	mmio_write_32(0x030020D8, 0x00030209); //clk_src_vip_sys_1 = DISPPLL(1188)/ 3 = 396MHz
+	mmio_write_32(0x03002110, 0x00020209); //clk_src_vip_sys_2 = DISPPLL(1188) / 2 = 594MHz
+	mmio_write_32(0x03002140, 0x00020009); //clk_src_vip_sys_3 = MIPIPLL(900) / 2 = 450MHz
+	mmio_write_32(0x03002144, 0x00030209); //clk_src_vip_sys_4 = DISPPLL(1188) / 3 = 396MHz
+
+	// set hsperi clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x030020B8, 0x00050009); //--> CLK_AXI4
+
+	// set rtcsys clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x0300212C, 0x00050009); // CLK_SRC_RTC_SYS_0
+
+	// disable powerdown, mipimpll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028A0, 0x4);
+
+	// disable powerdown, cam0pll_d2_pd[1]/cam0pll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028AC, 0x6);
+
+	//wait for pll stable
+	udelay(200);
+
+	// switch clock to PLL from xtal except clk_axi4 & clk_spi_nand
+	byp0_value &= (1 << 8 | //clk_spi_nand
+		       1 << 19 //clk_axi4
+	);
+	mmio_write_32(0x03002030, byp0_value); // REG_CLK_BYPASS_SEL0_REG
+	mmio_write_32(0x03002034, 0x0); // REG_CLK_BYPASS_SEL1_REG
+}
+
+void sys_pll_nd(int vc_overdrive)
+{
+	// ND clk setting
+	uint32_t value;
+	uint32_t byp0_value;
+
+	uint32_t pll_syn_set[] = {
+		614400000, // set apll synthesizer  98.304 M
+		610080582, // set disp synthesizer  99 M
+		610080582, // set cam0 synthesizer  99 M
+		615164587, // set cam1 synthesizer  98.18181818 M
+	};
+
+	uint32_t pll_csr[] = {
+		0x00128201, // set apll *9/2 (442.368 MHz)
+		0x00188101, // set disp *12/1 (1188 MHz)
+		// 0x00188101, // set cam0 *12/1 (1188 MHz)
+		0x00308201, // set cam0 *24/2 (1188 MHz)
+		0x00168101, // set cam1 *11/1 (1080 MHz)
+	};
+
+	NOTICE("PLLS.\n");
+
+	if (vc_overdrive) {
+		pll_syn_set[3] = 586388132;
+		pll_csr[3] = 0x00148101;
+		// set vddc for OD clock
+		config_core_power(0x58); //1.00V
+	} else {
+#ifdef TPU_PERF_MODE
+		config_core_power(0x4F);
+#endif
+	}
+
+	// store byp0 value
+	byp0_value = mmio_read_32(0x03002030);
+
+	// switch clock to xtal
+	mmio_write_32(0x03002030, 0xffffffff);
+	mmio_write_32(0x03002034, 0x0000003f);
+
+	//set mipipll = 900MHz
+	mmio_write_32(0x03002808, 0x05488101);
+
+	// set synthersizer clock
+	mmio_write_32(REG_PLL_G2_SSC_SYN_CTRL, 0x3F); // enable synthesizer clock enable,
+		// [0]: 1: MIPIMPLL(900)/1=900MHz,
+		//      0: MIPIMPLL(900)/2=450MHz
+
+	for (uint32_t i = 0; i < 4; i++) {
+		mmio_write_32(REG_APLL_SSC_SYN_SET + 0x10 * i, pll_syn_set[i]); // set pll_syn_set
+
+		value = mmio_read_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i);
+		value |= 1; // [0]: sw update (w1t: write one toggle)
+		value &= ~(1 << 4); // [4]: bypass = 0
+		mmio_write_32(REG_APLL_SSC_SYN_CTRL + 0x10 * i, value);
+
+		mmio_write_32(REG_APLL0_CSR + 4 * i, pll_csr[i]); // set pll_csr
+	}
+
+	value = mmio_read_32(REG_PLL_G2_CTRL);
+	value = value & (~0x00011111);
+	mmio_write_32(REG_PLL_G2_CTRL, value); //clear all pll PD
+
+#ifdef __riscv
+	// set mpll = 850MHz
+	mmio_write_32(0x03002908, 0x00448101);
+
+	// set clk_sel_23: [23] clk_sel for clk_c906_0 = 1 (DIV_IN0_SRC_MUX)
+	// set clk_sel_24: [24] clk_sel for clk_c906_1 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x01800000);
+
+	// set div, src_mux of clk_c906_0: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll), 850/1 = 850MHz
+	mmio_write_32(0x03002130, 0x00010309);
+
+	// set div, src_mux of clk_c906_1: [20:16]div_factor=2, [9:8]clk_src = 2 (disppll), 1188/2 = 594MHz
+	mmio_write_32(0x03002138, 0x00020209);
+#else
+	// set mpll = 800MHz
+	mmio_write_32(0x03002908, 0x00408101);
+
+	// set clk_sel_0: [0] clk_sel for clk_a53 = 1 (DIV_IN0_SRC_MUX)
+	mmio_write_32(0x03002020, 0x00000001);
+
+	// set div, src_mux of clk_a53: [20:16]div_factor=1, [9:8]clk_src = 3 (mpll)
+	mmio_write_32(0x03002040, 0x00010309);
+#endif
+
+#ifdef TPU_PERF_MODE
+	// set tpll = 1400MHz
+	mmio_write_32(0x0300290C, 0x07708101);
+	mmio_write_32(0x03002054, 0x00020009); //clk_tpu = TPLL(1400) / 2 = 700MHz
+#else
+	// set tpll = 850MHz
+	mmio_write_32(0x0300290C, 0x00448101);
+	mmio_write_32(0x03002054, 0x00030309); //clk_tpu = FPLL(1500) / 3 = 500MHz
+#endif
+
+	mmio_write_32(0x03002048, 0x00030009); //clk_cpu_axi0 = FPLL(1500) / 3
+	mmio_write_32(0x03002064, 0x00080009); //clk_emmc = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002088, 0x00080009); //clk_spi_nand = FPLL(1500) / 8 = 187.5MHz
+	mmio_write_32(0x03002098, 0x00120009); //clk_sdma_aud0 = APLL(442.368) / 18 = 24.576MHz
+	mmio_write_32(0x03002120, 0x000F0009); //clk_pwm_src = FPLL(1500) / 15 = 100MHz
+	mmio_write_32(0x030020A8, 0x00010009); //clk_uart -> clk_cam0_200 = XTAL(25) / 1 = 25MHz
+	mmio_write_32(0x030020C8, 0x00030009); //clk_axi_vip = MIPIPLL(900) / 3 = 300MHz
+	mmio_write_32(0x03002110, 0x00020209); //clk_src_vip_sys_2 = DISPPLL(1188) / 2 = 594MHz
+	mmio_write_32(0x03002144, 0x00030209); //clk_src_vip_sys_4 = DISPPLL(1188) / 3 = 396MHz
+
+	if (vc_overdrive) {
+		mmio_write_32(0x030020E4, 0x00020109); //clk_axi_video_codec = MIPIMPLL(900) / 2 = 450MHz
+		mmio_write_32(0x030020EC, 0x00020209); //clk_vc_src0 = CAM1PLL(1030) / 2 = 515MHz
+		mmio_write_32(0x030020D0, 0x00060309); //clk_src_vip_sys_0 = FPLL(1500) / 6 = 250MHz
+		mmio_write_32(0x030020D8, 0x00030209); //clk_src_vip_sys_1 = DISPPLL(1188)/ 3 = 396MHz
+		mmio_write_32(0x03002140, 0x00020009); //clk_src_vip_sys_3 = MIPIPLL(900) / 2 = 450MHz
+	} else {
+		mmio_write_32(0x030020E4, 0x00030209); //clk_axi_video_codec = CAM1PLL(1080) / 3 = 360MHz
+		mmio_write_32(0x030020EC, 0x00030009); //clk_vc_src0 = DISPPLL(1188) / 3 = 396MHz
+		mmio_write_32(0x030020D0, 0x00060209); //clk_src_vip_sys_0 = DISPPLL(1188) / 6 = 198MHz
+		mmio_write_32(0x030020D8, 0x00030009); //clk_src_vip_sys_1 = MIPIPLL(900) / 3 = 300MHz
+		mmio_write_32(0x03002140, 0x00030009); //clk_src_vip_sys_3 = MIPIPLL(900) / 3 = 300MHz
+	}
+
+	// set hsperi clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x030020B8, 0x00050009); //--> CLK_AXI4
+
+	// set rtcsys clock to PLL (FPLL) div by 5  = 300MHz
+	mmio_write_32(0x0300212C, 0x00050009); // CLK_SRC_RTC_SYS_0
+
+	// disable powerdown, mipimpll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028A0, 0x4);
+
+	// disable powerdown, cam0pll_d2_pd[1]/cam0pll_d3_pd[2] = 0
+	mmio_clrbits_32(0x030028AC, 0x6);
+
+	//wait for pll stable
+	udelay(200);
+
+	// switch clock to PLL from xtal except clk_axi4 & clk_spi_nand
+	byp0_value &= (1 << 8 | //clk_spi_nand
+		       1 << 19 //clk_axi4
+	);
+	mmio_write_32(0x03002030, byp0_value); // REG_CLK_BYPASS_SEL0_REG
+	mmio_write_32(0x03002034, 0x0); // REG_CLK_BYPASS_SEL1_REG
+	NOTICE("PLLE.\n");
+}
+
+void sys_pll_init(enum CHIP_CLK_MODE mode)
+{
+	switch (mode) {
+	case CLK_VC_OD:
+		sys_pll_nd(1);
+		break;
+	case CLK_OD:
+		sys_pll_od();
+		break;
+	case CLK_ND:
+	default:
+		sys_pll_nd(0);
+		break;
+	}
+
+}
+
+void switch_rtc_mode_1st_stage(void)
+{
+	uint32_t read_data;
+	uint32_t write_data;
+	uint32_t rtc_mode;
+
+#ifdef CV181X_SUPPORT_SUSPEND_RESUME
+	void (*warmboot_entry)(void) = get_warmboot_entry();
+
+	if (warmboot_entry == (void *)BL31_WARMBOOT_ENTRY)
+		return;
+#endif
+
+	// reg_rtc_mode = rtc_ctrl0[10]
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	rtc_mode = (read_data >> 10) & 0x1;
+	if (rtc_mode == 0x1) {
+		NOTICE("By pass rtc mode switch\n");
+		return;
+	}
+
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+
+	// reg_clk32k_cg_en = rtc_ctrl0[11] -> 0
+	write_data = 0x08000000 | (read_data & 0xfffff7ff);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data);
+
+	//cg_en_out_clk_32k = rtc_ctrl_status0[25]
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0_STATUS0);
+	while ((read_data & 0x02000000) != 0x00)
+		read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0_STATUS0);
+
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	//r eg_rtc_mode = rtc_ctrl0[10];
+	write_data = 0x04000000 | (read_data & 0xfffffbff) | (0x1 << 10);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data);
+
+	// DA_SOC_READY = 1
+	mmio_write_32(RTC_MACRO_BASE + 0x8C, 0x01);
+	// DA_SOC_READY = 0
+	mmio_write_32(RTC_MACRO_BASE + 0x8C, 0x0);
+
+	udelay(200); // delay ~200us
+
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	// reg_clk32k_cg_en = rtc_ctrl0[11] -> 1
+	write_data = 0x0C000000 | (read_data & 0xffffffff) | (0x1 << 11);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data); //rtc_ctrl0
+}
+
+void switch_rtc_mode_2nd_stage(void)
+{
+	uint32_t read_data;
+	uint32_t write_data;
+
+	// mdelay(50);
+	read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0_STATUS0);
+	if (get_pkg() == PKG_QFN || (read_data & 0x02000000) == 0x00) {
+		read_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+		// reg_rtc_mode = rtc_ctrl0[10]
+		write_data = 0x0C000000 | (read_data & 0xfffffbff);
+		mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data);
+		//DA_SOC_READY = 1
+		mmio_write_32(RTC_MACRO_BASE + 0x8C, 0x01);
+		//DA_SOC_READY = 0
+		mmio_write_32(RTC_MACRO_BASE + 0x8C, 0x00);
+		NOTICE("Use internal 32k\n");
+	} else
+		NOTICE("Switch RTC mode to xtal32k\n");
+}
+
+void set_rtc_en_registers(void)
+{
+	uint32_t write_data;
+	uint32_t read_data;
+
+	read_data = mmio_read_32(REG_RTC_BASE + RTC_ST_ON_REASON);
+	NOTICE("st_on_reason=%x\n", read_data);
+	read_data = mmio_read_32(REG_RTC_BASE + RTC_ST_OFF_REASON);
+	NOTICE("st_off_reason=%x\n", read_data);
+
+	mmio_write_32(REG_RTC_BASE + RTC_EN_SHDN_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_SHDN_REQ) != 0x01)
+		;
+
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != 0x01)
+		;
+
+	mmio_write_32(REG_RTC_BASE + RTC_EN_PWR_CYC_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_PWR_CYC_REQ) != 0x01)
+		;
+
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WDT_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WDT_RST_REQ) != 0x01)
+		;
+
+	// Set rtcsys_rst_ctrl[24] = 1; bit 24 is reg_rtcsys_reset_en
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_POR_RST_CTRL, 0X1);
+
+	// rtc_ctrl0_unlockkey
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+
+	// Enable hw_wdg_rst_en
+	write_data = mmio_read_32(REG_RTC_CTRL_BASE + RTC_CTRL0);
+	write_data = 0xffff0000 | write_data | (0x1 << 11) | (0x01 << 6);
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0, write_data);
+
+	// Avoid power up again after poweroff
+	mmio_clrbits_32(REG_RTC_BASE + RTC_EN_PWR_VBAT_DET, BIT(2));
+}
+
+void apply_analog_trimming_data(void)
+{
+}
diff --git a/firmware/plat/cv181x/platform.mk b/firmware/plat/cv181x/platform.mk
index ad82dff..e899a17 100644
--- a/firmware/plat/cv181x/platform.mk
+++ b/firmware/plat/cv181x/platform.mk
@@ -46,7 +46,7 @@ INCLUDES += \
 	${STDLIB_INCLUDES} \
 	${CRYPT_INCLUDES}
 
-#BL_COMMON_SOURCES = \
+BL_COMMON_SOURCES = \
 	${CPU_SOURCES} \
 	lib/tf_printf/tf_printf.c \
 	plat/${CHIP_ARCH}/platform.c \
@@ -54,12 +54,12 @@ INCLUDES += \
 	${STDLIB_SRCS} \
 	${CRYPT_SOURCES}
 
-#DECOMPRESSION_SOURCES = \
+DECOMPRESSION_SOURCES = \
 	lib/lzma/LzmaDec.c \
 	lib/lz4/lz4_all.c \
 	lib/lz4/xxhash.c
 
-#BL2_SRCS = \
+BL2_SRCS = \
 	${BL_COMMON_SOURCES} \
 	plat/${CHIP_ARCH}/bl2/bl2_opt.c \
 	lib/utils/decompress.c \
@@ -70,7 +70,7 @@ BL2_SOURCES = \
 	${BL2_SRCS} \
 	plat/${CHIP_ARCH}/bl2/bl2_main.c
 
-#include plat/${CHIP_ARCH}/ddr/ddr.mk
+include plat/${CHIP_ARCH}/ddr/ddr.mk
 
 BL2_LINKERFILE := plat/${CHIP_ARCH}/bl2/bl2.ld.S
-BL2_RLS_OBJS := plat/${CHIP_ARCH}/bl2_objs/${PROJECT_FULLNAME}/bl2/*.o
+#BL2_RLS_OBJS := plat/${CHIP_ARCH}/bl2_objs/${PROJECT_FULLNAME}/bl2/*.o
diff --git a/firmware/plat/cv181x/security/security.c b/firmware/plat/cv181x/security/security.c
new file mode 100644
index 0000000..e725335
--- /dev/null
+++ b/firmware/plat/cv181x/security/security.c
@@ -0,0 +1,213 @@
+#include <debug.h>
+#include <string.h>
+#include <platform.h>
+#include <mmio.h>
+#include <utils.h>
+#include <errno.h>
+#include <delay_timer.h>
+#include <security/efuse.h>
+
+#include <security/security.h>
+#include <security/cryptodma.h>
+
+#include <bigdigits.h>
+#include <tomcrypt.h>
+
+static DIGIT_T rsa_e[RSA_N_BYTES / sizeof(DIGIT_T)] = { 0x10001 };
+static DIGIT_T current_pk[RSA_N_BYTES / sizeof(DIGIT_T)];
+static DIGIT_T current_sig[RSA_N_BYTES / sizeof(DIGIT_T)];
+static DIGIT_T decrypted_sig[RSA_N_BYTES / sizeof(DIGIT_T)];
+static uint8_t current_digest[SHA256_SIZE];
+
+int cryptodma_aes_decrypt(const void *plain, const void *encrypted, uint64_t len, uint8_t *key, uint8_t *iv)
+{
+	__aligned(32) uint32_t dma_descriptor[22] = { 0 };
+
+	uint32_t status;
+	uint32_t ts;
+
+	uint64_t dest = phys_to_dma((uintptr_t)plain);
+	uint64_t src = phys_to_dma((uintptr_t)encrypted);
+
+	INFO("AES/0x%lx/0x%lx/0x%lx\n", src, dest, len);
+
+	// Prepare descriptor
+	dma_descriptor[CRYPTODMA_CTRL] = DES_USE_DESCRIPTOR_IV | DES_USE_DESCRIPTOR_KEY | DES_USE_AES | 0xF;
+	dma_descriptor[CRYPTODMA_CIPHER] = AES_KEY_MODE << 3 | CBC_ENABLE << 1 | DECRYPT_ENABLE;
+
+	dma_descriptor[CRYPTODMA_SRC_ADDR_L] = (uint32_t)(src & 0xFFFFFFFF);
+	dma_descriptor[CRYPTODMA_SRC_ADDR_H] = (uint32_t)(src >> 32);
+
+	dma_descriptor[CRYPTODMA_DST_ADDR_L] = (uint32_t)(dest & 0xFFFFFFFF);
+	dma_descriptor[CRYPTODMA_DST_ADDR_H] = (uint32_t)(dest >> 32);
+
+	dma_descriptor[CRYPTODMA_DATA_AMOUNT_L] = (uint32_t)(len & 0xFFFFFFFF);
+	dma_descriptor[CRYPTODMA_DATA_AMOUNT_H] = (uint32_t)(len >> 32);
+
+	memcpy(&dma_descriptor[CRYPTODMA_KEY], key, 16);
+	memcpy(&dma_descriptor[CRYPTODMA_IV], iv, 16);
+
+	// Set cryptodma control
+	mmio_write_32(SEC_CRYPTODMA_BASE + CRYPTODMA_INT_MASK, 0x3);
+	mmio_write_32(SEC_CRYPTODMA_BASE + CRYPTODMA_DES_BASE_L,
+		      (uint32_t)(phys_to_dma((uintptr_t)dma_descriptor) & 0xFFFFFFFF));
+	mmio_write_32(SEC_CRYPTODMA_BASE + CRYPTODMA_DES_BASE_H,
+		      (uint32_t)(phys_to_dma((uintptr_t)dma_descriptor) >> 32));
+
+	status = mmio_read_32(SEC_CRYPTODMA_BASE + CRYPTODMA_DMA_CTRL);
+
+	flush_dcache_range((unsigned long)dma_descriptor, sizeof(dma_descriptor));
+	flush_dcache_range((uintptr_t)plain, len);
+	flush_dcache_range((uintptr_t)encrypted, len);
+
+	// Clear interrupt
+	mmio_write_32(SEC_CRYPTODMA_BASE + CRYPTODMA_WR_INT, 0x3);
+	// Trigger cryptodma engine
+	mmio_write_32(SEC_CRYPTODMA_BASE + CRYPTODMA_DMA_CTRL,
+		      DMA_WRITE_MAX_BURST << 24 | DMA_READ_MAX_BURST << 16 | DMA_DESCRIPTOR_MODE << 1 | DMA_ENABLE);
+
+	ts = get_timer(0);
+	do {
+		status = mmio_read_32(SEC_CRYPTODMA_BASE + CRYPTODMA_WR_INT);
+		INFO("INT status 0x%x\n", status);
+		if (get_timer(ts) >= 1000) {
+			ERROR("Decryption timeout\n");
+			return -EIO;
+		}
+	} while (status == 0);
+
+	return 0;
+}
+
+int verify_rsa(const void *message, size_t n, const void *sig, void *rsa_n, size_t rsa_nbytes)
+{
+	hash_state md;
+
+	NOTICE("VI/0x%lx/0x%lx\n", (uintptr_t)message, n);
+
+	mpConvFromOctets(current_pk, rsa_nbytes / sizeof(DIGIT_T), rsa_n, rsa_nbytes);
+	mpConvFromOctets(current_sig, rsa_nbytes / sizeof(DIGIT_T), sig, rsa_nbytes);
+	/** Computes y = x^e mod m */
+	mpModExp(decrypted_sig, current_sig, rsa_e, current_pk, rsa_nbytes / sizeof(DIGIT_T));
+
+	sha256_init(&md);
+	sha256_process(&md, message, n);
+	sha256_done(&md, current_digest);
+
+	bytes_reverse(current_digest, sizeof(current_digest));
+
+	if (memcmp(current_digest, decrypted_sig, SHA256_SIZE))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+ * image (size) = body (size - RSA_N_BYTES) + sig (RSA_N_BYTES)
+ */
+int dec_verify_image(const void *image, size_t size, size_t dec_skip, struct fip_param1 *fip_param1)
+{
+	const void *sig = image + size - RSA_N_BYTES;
+	uint8_t iv[AES128_SIZE] = { 0 };
+
+	if (size <= RSA_N_BYTES) {
+		ERROR("image size <= signature size\n");
+		return -EFAULT;
+	}
+
+	if (!security_is_tee_enabled())
+		return 0;
+
+	if (security_is_tee_encrypted()) {
+		NOTICE("DI/0x%lx/0x%lx\n", (uintptr_t)image, size);
+		cryptodma_aes_decrypt(image + dec_skip, image + dec_skip, size - dec_skip, fip_param1->bl_ek, iv);
+	}
+
+	size -= RSA_N_BYTES;
+
+	return verify_rsa(image, size, sig, fip_param1->bl_pk, RSA_N_BYTES);
+}
+
+int efuse_wait_idle(void)
+{
+	uint32_t status;
+	uint32_t time_count = 0;
+	int ret = 0;
+
+	do {
+		status = mmio_read_32(EFUSE_BASE + EFUSE_STATUS);
+		time_count++;
+
+		if (time_count > 0x1000) {
+			NOTICE("wait idle timeout\n");
+			return -1;
+		}
+	} while ((status & 0x1) != 0);
+
+	return ret;
+}
+
+int efuse_power_on(void)
+{
+	int ret = 0;
+
+	if (efuse_wait_idle() != 0) {
+		return -1;
+	}
+
+	mmio_write_32(EFUSE_BASE + EFUSE_MODE, 0x10);
+
+	return ret;
+}
+
+int efuse_program_bit(uint32_t addr, const uint32_t bit)
+{
+	uint16_t w_addr = (bit << 7) | ((addr & 0x3F) << 1);
+
+	if (efuse_wait_idle() != 0) {
+		return -1;
+	}
+
+	mmio_write_32(EFUSE_BASE + EFUSE_ADR, (w_addr & 0xFFF));
+	mmio_write_32(EFUSE_BASE + EFUSE_MODE, 0x14);
+
+	if (efuse_wait_idle() != 0) {
+		return -1;
+	}
+
+	w_addr |= 0x1;
+	mmio_write_32(EFUSE_BASE + EFUSE_ADR, (w_addr & 0xFFF));
+	mmio_write_32(EFUSE_BASE + EFUSE_MODE, 0x14);
+
+	return 0;
+}
+
+int efuse_refresh_shadow(void)
+{
+	int ret = 0;
+
+	if (efuse_wait_idle() != 0) {
+		return -1;
+	}
+
+	mmio_write_32(EFUSE_BASE + EFUSE_MODE, 0x30);
+
+	if (efuse_wait_idle() != 0) {
+		return -1;
+	}
+
+	return ret;
+}
+
+int efuse_power_off(void)
+{
+	int ret = 0;
+
+	if (efuse_wait_idle() != 0) {
+		return -1;
+	}
+
+	mmio_write_32(EFUSE_BASE + EFUSE_MODE, 0x18);
+
+	return ret;
+}
diff --git a/firmware/plat/cv181x/uart/16550_console_aarch64.S b/firmware/plat/cv181x/uart/16550_console_aarch64.S
new file mode 100644
index 0000000..e646288
--- /dev/null
+++ b/firmware/plat/cv181x/uart/16550_console_aarch64.S
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2015-2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <cpu.h>
+#include <aarch64/asm_macros.S>
+#include <uart_16550.h>
+
+	.globl	console_core_init
+	.globl	console_core_putc
+	.globl	console_core_getc
+	.globl	console_core_flush
+	.globl	console_core_tstc
+
+	/* -----------------------------------------------
+	 * int console_core_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the console without a
+	 * C Runtime to print debug information. This
+	 * function will be accessed by console_init and
+	 * crash reporting.
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * Out: return 1 on success
+	 * Clobber list : x1, x2, x3
+	 * -----------------------------------------------
+	 */
+func console_core_init
+	/* Check the input base address */
+	cbz	x0, init_fail
+	/* Check baud rate and uart clock for sanity */
+	cbz	w1, init_fail
+	cbz	w2, init_fail
+
+	/* Program the baudrate */
+	/* Divisor =  Uart clock / (16 * baudrate) */
+	lsl	w2, w2, #4
+	udiv	w2, w1, w2
+	and	w1, w2, #0xff		/* w1 = DLL */
+	lsr	w2, w2, #8
+	and	w2, w2, #0xff		/* w2 = DLLM */
+	ldr	w3, [x0, #UARTLCR]
+	orr	w3, w3, #UARTLCR_DLAB
+	str	w3, [x0, #UARTLCR]	/* enable DLL, DLLM programming */
+	str	w1, [x0, #UARTDLL]	/* program DLL */
+	str	w2, [x0, #UARTDLLM]	/* program DLLM */
+	mov	w2, #~UARTLCR_DLAB
+	and	w3, w3, w2
+	str	w3, [x0, #UARTLCR]	/* disable DLL, DLLM programming */
+
+	/* 8n1 */
+	mov	w3, #3
+	str	w3, [x0, #UARTLCR]
+	/* no interrupt */
+	mov	w3, #0
+	str	w3, [x0, #UARTIER]
+	/* enable fifo, DMA */
+	mov	w3, #(UARTFCR_FIFOEN | UARTFCR_DMAEN)
+	str	w3, [x0, #UARTFCR]
+	/* DTR + RTS */
+	mov	w3, #3
+	str	w3, [x0, #UARTMCR]
+	mov	w0, #1
+init_fail:
+	ret
+endfunc console_core_init
+
+	/* --------------------------------------------------------
+	 * int console_core_putc(int c, unsigned int base_addr)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_core_putc
+	/* Check the input parameter */
+	cbz	x1, putc_error
+
+	/* Prepend '\r' to '\n' */
+	cmp	w0, #0xA
+	b.ne	2f
+	/* Check if the transmit FIFO is full */
+1:	ldr	w2, [x1, #UARTLSR]
+	and	w2, w2, #(UARTLSR_TEMT | UARTLSR_THRE)
+	cmp	w2, #(UARTLSR_TEMT | UARTLSR_THRE)
+	b.ne	1b
+	mov	w2, #0xD		/* '\r' */
+	str	w2, [x1, #UARTTX]
+
+	/* Check if the transmit FIFO is full */
+2:	ldr	w2, [x1, #UARTLSR]
+	and	w2, w2, #(UARTLSR_TEMT | UARTLSR_THRE)
+	cmp	w2, #(UARTLSR_TEMT | UARTLSR_THRE)
+	b.ne	2b
+	str	w0, [x1, #UARTTX]
+	ret
+putc_error:
+	mov	w0, #-1
+	ret
+endfunc console_core_putc
+
+	/* ---------------------------------------------
+	 * int console_core_getc(void)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on error.
+	 * In : w0 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_core_getc
+	/* Check if the receive FIFO is empty */
+1:	ldr	w1, [x0, #UARTLSR]
+	tbz	w1, #UARTLSR_RDR_BIT, 1b
+	ldr	w0, [x0, #UARTRX]
+	ret
+getc_error:
+	mov	w0, #-1
+	ret
+endfunc console_core_getc
+
+func console_core_tstc
+	ldr	w1, [x0, #UARTLSR]
+	tbz	w1, #UARTLSR_RDR_BIT, 1f
+	mov	w0, #1
+	ret
+1:	mov	w0, #0
+	ret
+endfunc console_core_tstc
+
+
+	/* ---------------------------------------------
+	 * int console_core_flush(uintptr_t base_addr)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - console base address
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_core_flush
+	/* Check the input parameter */
+	cbz	x0, flush_error
+
+1:	ldr	w1, [x0, #UARTLSR]
+	and	w1, w1, #(UARTLSR_TEMT | UARTLSR_THRE)
+	cmp	w1, #(UARTLSR_TEMT | UARTLSR_THRE)
+	b.ne	1b
+	mov	w0, #0
+	ret
+flush_error:
+	mov	w0, #-1
+	ret
+endfunc console_core_flush
diff --git a/firmware/plat/cv181x/uart/uart_dw.c b/firmware/plat/cv181x/uart/uart_dw.c
new file mode 100644
index 0000000..4a20afd
--- /dev/null
+++ b/firmware/plat/cv181x/uart/uart_dw.c
@@ -0,0 +1,124 @@
+#include <stdint.h>
+#include "platform_def.h"
+
+#define thr rbr
+#define iir fcr
+#define dll rbr
+#define dlm ier
+
+struct dw_regs {
+	uint32_t	rbr;		/* 0x00 Data register */
+	uint32_t	ier;		/* 0x04 Interrupt Enable Register */
+	uint32_t	fcr;		/* 0x08 FIFO Control Register */
+	uint32_t	lcr;		/* 0x0C Line control register */
+	uint32_t	mcr;		/* 0x10 Line control register */
+	uint32_t	lsr;		/* 0x14 Line Status Register */
+	uint32_t	msr;		/* 0x18 Modem Status Register */
+	uint32_t	spr;		/* 0x20 Scratch Register */
+};
+
+#define UART_LCR_WLS_MSK 0x03       /* character length select mask */
+#define UART_LCR_WLS_5  0x00        /* 5 bit character length */
+#define UART_LCR_WLS_6  0x01        /* 6 bit character length */
+#define UART_LCR_WLS_7  0x02        /* 7 bit character length */
+#define UART_LCR_WLS_8  0x03        /* 8 bit character length */
+#define UART_LCR_STB    0x04        /* # stop Bits, off=1, on=1.5 or 2) */
+#define UART_LCR_PEN    0x08        /* Parity eneble */
+#define UART_LCR_EPS    0x10        /* Even Parity Select */
+#define UART_LCR_STKP   0x20        /* Stick Parity */
+#define UART_LCR_SBRK   0x40        /* Set Break */
+#define UART_LCR_BKSE   0x80        /* Bank select enable */
+#define UART_LCR_DLAB   0x80        /* Divisor latch access bit */
+
+#define UART_MCR_DTR    0x01        /* DTR   */
+#define UART_MCR_RTS    0x02        /* RTS   */
+
+#define UART_LSR_THRE   0x20 /* Transmit-hold-register empty */
+#define UART_LSR_DR	    0x01 /* Receiver data ready */
+#define UART_LSR_TEMT   0x40        /* Xmitter empty */
+
+#define UART_FCR_FIFO_EN    0x01 /* Fifo enable */
+#define UART_FCR_RXSR       0x02 /* Receiver soft reset */
+#define UART_FCR_TXSR       0x04 /* Transmitter soft reset */
+
+#define UART_MCRVAL (UART_MCR_DTR | UART_MCR_RTS)      /* RTS/DTR */
+#define UART_FCR_DEFVAL	(UART_FCR_FIFO_EN | UART_FCR_RXSR | UART_FCR_TXSR)
+#define UART_LCR_8N1    0x03
+
+static struct dw_regs *uart = (struct dw_regs *)PLAT_BOOT_UART_BASE;
+
+void console_init(uintptr_t not_used, unsigned int uart_clk, unsigned int baud_rate)
+{
+	int baudrate = baud_rate;
+	int uart_clock = uart_clk;
+
+	int divisor = uart_clock / (16 * baudrate);
+
+	uart->lcr = uart->lcr | UART_LCR_DLAB | UART_LCR_8N1;
+	asm (""::: "memory");
+	uart->dll = divisor & 0xff;
+	asm (""::: "memory");
+	uart->dlm = (divisor >> 8) & 0xff;
+	asm (""::: "memory");
+	uart->lcr = uart->lcr & (~UART_LCR_DLAB);
+	asm (""::: "memory");
+	uart->ier = 0;
+	asm (""::: "memory");
+	uart->mcr = UART_MCRVAL;
+	asm (""::: "memory");
+	uart->fcr = UART_FCR_DEFVAL;
+	asm (""::: "memory");
+	uart->lcr = 3;
+}
+
+void _uart_putc(uint8_t ch)
+{
+	do {
+		asm (""::: "memory");
+	} while (!(uart->lsr & UART_LSR_THRE))
+		;
+	uart->rbr = ch;
+}
+
+void console_putc(uint8_t ch)
+{
+	if (ch == '\n') {
+		_uart_putc('\r');
+	}
+	_uart_putc(ch);
+}
+
+void console_puts(char *str)
+{
+	if (!str)
+		return;
+
+	while (*str) {
+		console_putc(*str++);
+	}
+}
+void console_flush(void)
+{
+	do {
+		asm ("" ::: "memory");
+	} while ((uart->lsr & (UART_LSR_THRE | UART_LSR_TEMT)) != (UART_LSR_THRE | UART_LSR_TEMT))
+		;
+}
+int console_getc(void)
+{
+	do {
+		asm (""::: "memory");
+	} while (!(uart->lsr & UART_LSR_DR))
+		;
+	return (int)uart->rbr;
+}
+
+int uart_tstc(void)
+{
+	return (!!(uart->lsr & UART_LSR_DR));
+}
+
+int console_tstc(void)
+{
+	return uart->lsr & UART_LSR_DR;
+}
